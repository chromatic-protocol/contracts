{
  "address": "0x316064E349C595c563EFa62a7aB22955C8E6eAA3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "ChainlinkAggregator",
          "name": "aggregator_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidOracleRound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnableToSyncError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "aggregator",
      "outputs": [
        {
          "internalType": "ChainlinkAggregator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "atVersion",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "version",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "price",
              "type": "int256"
            }
          ],
          "internalType": "struct IOracleProvider.OracleVersion",
          "name": "oracleVersion",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentVersion",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "version",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "price",
              "type": "int256"
            }
          ],
          "internalType": "struct IOracleProvider.OracleVersion",
          "name": "oracleVersion",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "description",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracleProviderName",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "sync",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "version",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "price",
              "type": "int256"
            }
          ],
          "internalType": "struct IOracleProvider.OracleVersion",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2cd58b69f811a4a852b779f7f6352d9ab84d6cdee399d67c53a2de5b803148df",
  "receipt": {
    "to": null,
    "from": "0x3bD0496CA35b200FCc21CAc644208F7b11838EF6",
    "contractAddress": "0x316064E349C595c563EFa62a7aB22955C8E6eAA3",
    "transactionIndex": 1,
    "gasUsed": "1087218",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x950ae29ccd4f58d34701dcc35128d17e827660e67b5e806a1bca26eb3de886cc",
    "transactionHash": "0x2cd58b69f811a4a852b779f7f6352d9ab84d6cdee399d67c53a2de5b803148df",
    "logs": [],
    "blockNumber": 52701003,
    "cumulativeGasUsed": "1087218",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x6550bc2301936011c1334555e62A87705A81C12C"
  ],
  "numDeployments": 2,
  "solcInputHash": "56bceea35be7e0d66214085237c57d89",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"ChainlinkAggregator\",\"name\":\"aggregator_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidOracleRound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnableToSyncError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"aggregator\",\"outputs\":[{\"internalType\":\"ChainlinkAggregator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"atVersion\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"internalType\":\"struct IOracleProvider.OracleVersion\",\"name\":\"oracleVersion\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentVersion\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"internalType\":\"struct IOracleProvider.OracleVersion\",\"name\":\"oracleVersion\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleProviderName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"internalType\":\"struct IOracleProvider.OracleVersion\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"One instance per Chainlink price feed should be deployed. Multiple products may use the same      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.      This implementation only support non-negative prices.\",\"errors\":{\"InvalidOracleRound()\":[{\"details\":\"Error for invalid oracle round\"}]},\"kind\":\"dev\",\"methods\":{\"atVersion(uint256)\":{\"params\":{\"version\":\"The version of which to lookup\"},\"returns\":{\"oracleVersion\":\"Oracle version at version `version`\"}},\"constructor\":{\"params\":{\"aggregator_\":\"Chainlink price feed aggregator\"}},\"currentVersion()\":{\"returns\":{\"oracleVersion\":\"Current oracle version\"}},\"description()\":{\"returns\":{\"_0\":\"A string representing the description of the Oracle Provider.\"}},\"oracleProviderName()\":{\"returns\":{\"_0\":\"A string representing the name of the Oracle Provider.\"}},\"sync()\":{\"details\":\"`sync` is expected to be called soon after a phase update occurs in the underlying proxy.      Phase updates should be detected using off-chain mechanism and should trigger a `sync` call      This is feasible in the short term due to how infrequent phase updates are, but phase update      and roundCount detection should eventually be implemented at the contract level.      Reverts if there is more than 1 phase to update in a single sync because we currently cannot      determine the startingRoundId for the intermediary phase.\",\"returns\":{\"_0\":\"The current oracle version after sync\"}}},\"stateVariables\":{\"_decimalOffset\":{\"details\":\"Decimal offset used to normalize chainlink price to 18 decimals\"},\"_phases\":{\"details\":\"Mapping of the starting data for each underlying phase\"},\"aggregator\":{\"details\":\"Chainlink feed aggregator address\"},\"lastSyncedRoundId\":{\"details\":\"Last roundID seen when `sync` was called\"}},\"title\":\"ChainlinkOracle\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"atVersion(uint256)\":{\"notice\":\"Returns the current oracle version\"},\"constructor\":{\"notice\":\"Initializes the contract state\"},\"currentVersion()\":{\"notice\":\"Returns the current oracle version\"},\"description()\":{\"notice\":\"Retrieves the description of the Oracle Provider.\"},\"oracleProviderName()\":{\"notice\":\"Retrieves the name of the Oracle Provider.\"},\"sync()\":{\"notice\":\"Checks for a new price and updates the internal phase annotation state accordingly\"}},\"notice\":\"Chainlink implementation of the IOracle interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/ChainlinkFeedOracle.sol\":\"ChainlinkFeedOracle\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":30000},\"remappings\":[\":@chromatic-protocol/contracts/=contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\"]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\",\"keccak256\":\"0xb496651006b9a2a07920ffe116928b11e2a6458e21361cecca51409522488ca7\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\",\"keccak256\":\"0x4a7757ff7bbafe044cd49c2a45c7c18ec50eff7c7af6869face5e1e9cda976f2\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"contracts/oracle/ChainlinkFeedOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"./interfaces/IOracleProvider.sol\\\";\\nimport \\\"./types/ChainlinkAggregator.sol\\\";\\n\\n/**\\n * @title ChainlinkOracle\\n * @notice Chainlink implementation of the IOracle interface.\\n * @dev One instance per Chainlink price feed should be deployed. Multiple products may use the same\\n *      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.\\n *      This implementation only support non-negative prices.\\n */\\ncontract ChainlinkFeedOracle is IOracleProvider {\\n    error UnableToSyncError();\\n\\n    int256 private constant BASE = 1e18;\\n\\n    /// @dev Chainlink feed aggregator address\\n    ChainlinkAggregator public immutable aggregator;\\n\\n    /// @dev Decimal offset used to normalize chainlink price to 18 decimals\\n    int256 private immutable _decimalOffset;\\n\\n    /// @dev Mapping of the starting data for each underlying phase\\n    Phase[] private _phases;\\n\\n    /// @dev Last roundID seen when `sync` was called\\n    uint256 private lastSyncedRoundId;\\n\\n    struct Phase {\\n        uint128 startingVersion;\\n        uint128 startingRoundId;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract state\\n     * @param aggregator_ Chainlink price feed aggregator\\n     */\\n    constructor(ChainlinkAggregator aggregator_) {\\n        aggregator = aggregator_;\\n\\n        _decimalOffset = SafeCast.toInt256(10 ** aggregator.decimals());\\n\\n        ChainlinkRound memory firstSeenRound = aggregator.getLatestRound();\\n\\n        // Load the phases array with empty phase values. these phases will be invalid if requested\\n        while (firstSeenRound.phaseId() > _phases.length) {\\n            _phases.push(Phase(uint128(0), uint128(0)));\\n        }\\n\\n        // first seen round starts as version 0 at current phase\\n        _phases.push(Phase(uint128(0), uint128(firstSeenRound.roundId)));\\n        lastSyncedRoundId = firstSeenRound.roundId;\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProvider\\n     */\\n    function sync() external returns (OracleVersion memory) {\\n        // Fetch latest round\\n        ChainlinkRound memory round = aggregator.getLatestRound();\\n\\n        // Revert if the round id is 0\\n        if (uint64(round.roundId) == 0) revert InvalidOracleRound();\\n\\n        // If there is more than 1 phase to update, revert\\n        if (round.phaseId() - _latestPhaseId() > 1) {\\n            revert UnableToSyncError();\\n        }\\n\\n        // Update phase annotation when new phase detected\\n        while (round.phaseId() > _latestPhaseId()) {\\n            // Get the round count for the latest phase\\n            (uint256 phaseRoundCount, uint256 nextStartingRoundId) = aggregator\\n                .getPhaseSwitchoverData(\\n                    _phases[_latestPhaseId()].startingRoundId,\\n                    lastSyncedRoundId,\\n                    round\\n                );\\n\\n            // The starting version for the next phase is startingVersionForLatestPhase + roundCount\\n            _phases.push(\\n                Phase(\\n                    uint128(phaseRoundCount) + _phases[_latestPhaseId()].startingVersion,\\n                    uint128(nextStartingRoundId)\\n                )\\n            );\\n        }\\n\\n        lastSyncedRoundId = round.roundId;\\n\\n        // Return packaged oracle version\\n        return _buildOracleVersion(round);\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProvider\\n     */\\n    function currentVersion() public view returns (OracleVersion memory oracleVersion) {\\n        return _buildOracleVersion(aggregator.getLatestRound());\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProvider\\n     */\\n    function atVersion(uint256 version) public view returns (OracleVersion memory oracleVersion) {\\n        return _buildOracleVersion(aggregator.getRound(_versionToRoundId(version)), version);\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProvider\\n     */\\n    function description() external view override returns (string memory) {\\n        return AggregatorV2V3Interface(ChainlinkAggregator.unwrap(aggregator)).description();\\n    }\\n\\n    /**\\n     * @notice Builds an oracle version object from a Chainlink round object\\n     * @dev Computes the version for the round\\n     * @param round Chainlink round to build from\\n     * @return Built oracle version\\n     */\\n    function _buildOracleVersion(\\n        ChainlinkRound memory round\\n    ) private view returns (OracleVersion memory) {\\n        Phase memory phase = _phases[round.phaseId()];\\n        uint256 version = uint256(phase.startingVersion) +\\n            round.roundId -\\n            uint256(phase.startingRoundId);\\n        return _buildOracleVersion(round, version);\\n    }\\n\\n    /**\\n     * @notice Builds an oracle version object from a Chainlink round object\\n     * @param round Chainlink round to build from\\n     * @param version Determined version for the round\\n     * @return Built oracle version\\n     */\\n    function _buildOracleVersion(\\n        ChainlinkRound memory round,\\n        uint256 version\\n    ) private view returns (OracleVersion memory) {\\n        int256 price = (round.answer * BASE) / _decimalOffset;\\n        return OracleVersion({version: version, timestamp: round.timestamp, price: price});\\n    }\\n\\n    /**\\n     * @notice Computes the chainlink round ID from a version\\n     * @param version Version to compute from\\n     * @return Chainlink round ID\\n     */\\n    function _versionToRoundId(uint256 version) private view returns (uint256) {\\n        Phase memory phase = _versionToPhase(version);\\n        return uint256(phase.startingRoundId) + version - uint256(phase.startingVersion);\\n    }\\n\\n    /**\\n     * @notice Computes the chainlink phase ID from a version\\n     * @param version Version to compute from\\n     * @return phase Chainlink phase\\n     */\\n    function _versionToPhase(uint256 version) private view returns (Phase memory phase) {\\n        uint256 phaseId = _latestPhaseId();\\n        phase = _phases[phaseId];\\n        while (uint256(phase.startingVersion) > version) {\\n            phaseId--;\\n            phase = _phases[phaseId];\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the latest phase ID that this contract has seen via `sync()`\\n     * @return Latest seen phase ID\\n     */\\n    function _latestPhaseId() private view returns (uint16) {\\n        return uint16(_phases.length - 1);\\n    }\\n\\n    function oracleProviderName() external pure override returns (string memory) {\\n        return \\\"chainlink\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x9c43cd7ec4e44e34b37fc5b40a784984335623b056f2659b99168bfd9fa1b212\",\"license\":\"Apache-2.0\"},\"contracts/oracle/interfaces/AggregatorProxyInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {AggregatorV2V3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\ninterface AggregatorProxyInterface is AggregatorV2V3Interface {\\n    function phaseAggregators(uint16 _phaseId) external view returns (address);\\n\\n    function phaseId() external view returns (uint16);\\n\\n    function proposedAggregator() external view returns (address);\\n\\n    function proposedGetRoundData(\\n        uint80 roundId\\n    )\\n        external\\n        view\\n        returns (\\n            uint80 id,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function proposedLatestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 id,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function aggregator() external view returns (address);\\n}\\n\",\"keccak256\":\"0x8087499d681a7fb762d93c5e350fb7821d5c84e2ec0482119e21423f93590d35\",\"license\":\"MIT\"},\"contracts/oracle/interfaces/IOracleProvider.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IOracleProvider {\\n    /// @dev Error for invalid oracle round\\n    error InvalidOracleRound();\\n\\n    /**\\n     * @dev A singular oracle version with its corresponding data\\n     * @param version The iterative version\\n     * @param timestamp the timestamp of the oracle update\\n     * @param price The oracle price of the corresponding version\\n     */\\n    struct OracleVersion {\\n        uint256 version;\\n        uint256 timestamp;\\n        int256 price;\\n    }\\n\\n    /**\\n     * @notice Checks for a new price and updates the internal phase annotation state accordingly\\n     * @dev `sync` is expected to be called soon after a phase update occurs in the underlying proxy.\\n     *      Phase updates should be detected using off-chain mechanism and should trigger a `sync` call\\n     *      This is feasible in the short term due to how infrequent phase updates are, but phase update\\n     *      and roundCount detection should eventually be implemented at the contract level.\\n     *      Reverts if there is more than 1 phase to update in a single sync because we currently cannot\\n     *      determine the startingRoundId for the intermediary phase.\\n     * @return The current oracle version after sync\\n     */\\n    function sync() external returns (OracleVersion memory);\\n\\n    /**\\n     * @notice Returns the current oracle version\\n     * @return oracleVersion Current oracle version\\n     */\\n    function currentVersion() external view returns (OracleVersion memory);\\n\\n    /**\\n     * @notice Returns the current oracle version\\n     * @param version The version of which to lookup\\n     * @return oracleVersion Oracle version at version `version`\\n     */\\n    function atVersion(uint256 version) external view returns (OracleVersion memory);\\n\\n    /**\\n     * @notice Retrieves the description of the Oracle Provider.\\n     * @return A string representing the description of the Oracle Provider.\\n     */\\n    function description() external view returns (string memory);\\n\\n    /**\\n     * @notice Retrieves the name of the Oracle Provider.\\n     * @return A string representing the name of the Oracle Provider.\\n     */\\n    function oracleProviderName() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x7578ac3fc7a41e93a3e3d0c8eebebd559a0a34f8464079914e9f4f5cf39e427d\",\"license\":\"Apache-2.0\"},\"contracts/oracle/types/ChainlinkAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport \\\"../interfaces/AggregatorProxyInterface.sol\\\";\\nimport \\\"./ChainlinkRound.sol\\\";\\n\\n/// @dev ChainlinkAggregator type\\ntype ChainlinkAggregator is address;\\nusing ChainlinkAggregatorLib for ChainlinkAggregator global;\\n\\n/**\\n * @title ChainlinkAggregatorLib\\n * @notice Library that manages interfacing with the Chainlink Feed Aggregator Proxy.\\n */\\nlibrary ChainlinkAggregatorLib {\\n    /**\\n     * @notice Returns the decimal amount for a specific feed\\n     * @param self Chainlink Feed Aggregator to operate on\\n     * @return Decimal amount\\n     */\\n    function decimals(ChainlinkAggregator self) internal view returns (uint8) {\\n        return AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).decimals();\\n    }\\n\\n    /**\\n     * @notice Returns the latest round data for a specific feed\\n     * @param self Chainlink Feed Aggregator to operate on\\n     * @return Latest round data\\n     */\\n    function getLatestRound(\\n        ChainlinkAggregator self\\n    ) internal view returns (ChainlinkRound memory) {\\n        //slither-disable-next-line unused-return\\n        (uint80 roundId, int256 answer, , uint256 updatedAt, ) = AggregatorProxyInterface(\\n            ChainlinkAggregator.unwrap(self)\\n        ).latestRoundData();\\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\\n    }\\n\\n    /**\\n     * @notice Returns a specific round's data for a specific feed\\n     * @param self Chainlink Feed Aggregator to operate on\\n     * @param roundId The specific round to fetch data for\\n     * @return Specific round's data\\n     */\\n    function getRound(\\n        ChainlinkAggregator self,\\n        uint256 roundId\\n    ) internal view returns (ChainlinkRound memory) {\\n        //slither-disable-next-line unused-return\\n        (, int256 answer, , uint256 updatedAt, ) = AggregatorProxyInterface(\\n            ChainlinkAggregator.unwrap(self)\\n        ).getRoundData(uint80(roundId));\\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\\n    }\\n\\n    /**\\n     * @notice Returns the round count and next phase starting round for the lastSyncedRound phase\\n     * @param self Chainlink Feed Aggregator to operate on\\n     * @param startingRoundId starting roundId for the aggregator proxy\\n     * @param lastSyncedRoundId last synced round ID for the proxy\\n     * @param latestRound latest round from the proxy\\n     * @return roundCount The number of rounds in the phase\\n     * @return nextPhaseStartingRoundId The starting round ID for the next phase\\n     */\\n    function getPhaseSwitchoverData(\\n        ChainlinkAggregator self,\\n        uint256 startingRoundId,\\n        uint256 lastSyncedRoundId,\\n        ChainlinkRound memory latestRound\\n    ) internal view returns (uint256 roundCount, uint256 nextPhaseStartingRoundId) {\\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\\n\\n        // Try to get the immediate next round in the same phase. If this errors, we know that the phase has ended\\n        //slither-disable-next-line unused-return\\n        try proxy.getRoundData(uint80(lastSyncedRoundId + 1)) returns (\\n            uint80 nextRoundId,\\n            int256,\\n            uint256,\\n            uint256 nextUpdatedAt,\\n            uint80\\n        ) {\\n            // If the next round in this phase is before the latest round, then we can safely mark that\\n            // as the end of the phase, and the latestRound as the start of the new phase\\n            // Else the next round in this phase is _after_ the latest round, then we\\n            // fallthrough to search for the next starting round ID using the walkback logic\\n            if (nextRoundId == 0 || nextUpdatedAt == 0) {\\n                // Invalid round\\n                // pass\\n            } else if (nextUpdatedAt < latestRound.timestamp) {\\n                return ((nextRoundId - startingRoundId) + 1, latestRound.roundId);\\n            }\\n        } catch {\\n            // pass\\n        }\\n\\n        // lastSyncedRound is the last round it's phase before latestRound, so we need to find where the next phase starts\\n        // The next phase should start at the round that is closest to but after lastSyncedRound.timestamp\\n        //slither-disable-next-line unused-return\\n        (, , , uint256 lastSyncedRoundTimestamp, ) = proxy.getRoundData(uint80(lastSyncedRoundId));\\n        nextPhaseStartingRoundId = latestRound.roundId;\\n        uint256 updatedAt = latestRound.timestamp;\\n        // Walk back in the new phase until we dip below the lastSyncedRound.timestamp\\n        while (updatedAt >= lastSyncedRoundTimestamp) {\\n            nextPhaseStartingRoundId--;\\n            //slither-disable-next-line unused-return\\n            (, , , updatedAt, ) = proxy.getRoundData(uint80(nextPhaseStartingRoundId));\\n        }\\n\\n        return ((lastSyncedRoundId - startingRoundId) + 1, nextPhaseStartingRoundId + 1);\\n    }\\n}\\n\",\"keccak256\":\"0xefb7692fdd5a196a3e87d6ddec539b4fb8200bc62f9e92e813558d675b48dbd4\",\"license\":\"Apache-2.0\"},\"contracts/oracle/types/ChainlinkRound.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\n/// @dev ChainlinkRound type\\nstruct ChainlinkRound {\\n    uint256 timestamp;\\n    int256 answer;\\n    uint256 roundId;\\n}\\nusing ChainlinkRoundLib for ChainlinkRound global;\\n\\n/**\\n * @title ChainlinkRoundLib\\n * @notice Library that manages Chainlink round parsing.\\n */\\nlibrary ChainlinkRoundLib {\\n    /// @dev Phase ID offset location in the round ID\\n    uint256 constant private PHASE_OFFSET = 64;\\n\\n    /**\\n     * @notice Computes the chainlink phase ID from a round\\n     * @param self Round to compute from\\n     * @return Chainlink phase ID\\n     */\\n    function phaseId(ChainlinkRound memory self) internal pure returns (uint16) {\\n        return uint16(self.roundId >> PHASE_OFFSET);\\n    }\\n}\\n\",\"keccak256\":\"0x30932df9b202188bc3ef87cbd08a0dd8972f2fb033a657bce46ee967688a6abe\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162001621380380620016218339810160408190526200003491620002f5565b6001600160a01b03811660808190526200006690620000539062000154565b6200006090600a6200043a565b620001c1565b60a05260805160009062000083906001600160a01b031662000234565b90505b600054604080830151901c61ffff161115620000f257604080518082019091526000808252602082018181528154600181018355918052915191516001600160801b03908116600160801b02921691909117600080516020620016018339815191529091015562000086565b60408051808201825260008082529290910180516001600160801b0390811660208401908152845460018181018755958052935190518216600160801b02911617600080516020620016018339815191529092019190915551905550620004e2565b6000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000195573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001bb91906200044b565b92915050565b60006001600160ff1b03821115620002305760405162461bcd60e51b815260206004820152602860248201527f53616665436173743a2076616c756520646f65736e27742066697420696e2061604482015267371034b73a191a9b60c11b606482015260840160405180910390fd5b5090565b6200025960405180606001604052806000815260200160008152602001600081525090565b6000806000846001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156200029d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620002c391906200048d565b506040805160608101825291825260208201939093526001600160501b03909316918301919091525095945050505050565b6000602082840312156200030857600080fd5b81516001600160a01b03811681146200032057600080fd5b9392505050565b634e487b7160e01b600052601160045260246000fd5b600181815b808511156200037e57816000190482111562000362576200036262000327565b808516156200037057918102915b93841c939080029062000342565b509250929050565b6000826200039757506001620001bb565b81620003a657506000620001bb565b8160018114620003bf5760028114620003ca57620003ea565b6001915050620001bb565b60ff841115620003de57620003de62000327565b50506001821b620001bb565b5060208310610133831016604e8410600b84101617156200040f575081810a620001bb565b6200041b83836200033d565b806000190482111562000432576200043262000327565b029392505050565b60006200032060ff84168362000386565b6000602082840312156200045e57600080fd5b815160ff811681146200032057600080fd5b80516001600160501b03811681146200048857600080fd5b919050565b600080600080600060a08688031215620004a657600080fd5b620004b18662000470565b9450602086015193506040860151925060608601519150620004d66080870162000470565b90509295509295909350565b60805160a0516110d76200052a60003960006106eb015260008181607c0152818161015b01528181610259015281816102b701528181610321015261045601526110d76000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c80637ece075d116100505780637ece075d146101125780639d888e8614610147578063fff6cae91461014f57600080fd5b8063245a7bfc1461007757806325882087146100c85780637284e4161461010a575b600080fd5b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b60408051808201909152600981527f636861696e6c696e6b000000000000000000000000000000000000000000000060208201525b6040516100bf9190610cef565b6100fd610157565b610125610120366004610d40565b61020f565b60408051825181526020808401519082015291810151908201526060016100bf565b61012561028b565b6101256102f6565b60607f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637284e4166040518163ffffffff1660e01b8152600401600060405180830381865afa1580156101c4573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261020a9190810190610d88565b905090565b61023360405180606001604052806000815260200160008152602001600081525090565b61028561027f61024284610581565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906105d9565b836106c3565b92915050565b6102af60405180606001604052806000815260200160008152602001600081525090565b61020a6102f17f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661074d565b61081a565b61031a60405180606001604052806000815260200160008152602001600081525090565b600061035b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661074d565b9050806040015167ffffffffffffffff166000036103a5576040517f5234755400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60016103af6108df565b6040838101516103c092911c610e82565b61ffff1611156103fc576040517f68e7727f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6104046108df565b61ffff1661041782604090810151901c90565b61ffff16111561056a576000806104b960006104316108df565b61ffff168154811061044557610445610ea4565b6000918252602090912001546001547f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169170010000000000000000000000000000000090046fffffffffffffffffffffffffffffffff1690866108ef565b915091506000604051806040016040528060006104d46108df565b61ffff16815481106104e8576104e8610ea4565b600091825260209091200154610510906fffffffffffffffffffffffffffffffff1686610ed3565b6fffffffffffffffffffffffffffffffff90811682529384166020918201528254600181018455600093845292819020825192909101518416700100000000000000000000000000000000029190931617910155506103fc565b604081015160015561057b8161081a565b91505090565b60008061058d83610bb3565b905080600001516fffffffffffffffffffffffffffffffff168382602001516fffffffffffffffffffffffffffffffff166105c89190610efc565b6105d29190610f0f565b9392505050565b6105fd60405180606001604052806000815260200160008152602001600081525090565b6040517f9a6fc8f500000000000000000000000000000000000000000000000000000000815269ffffffffffffffffffff83166004820152600090819073ffffffffffffffffffffffffffffffffffffffff861690639a6fc8f59060240160a060405180830381865afa158015610678573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069c9190610f41565b50604080516060810182529182526020820193909352918201969096529695505050505050565b6106e760405180606001604052806000815260200160008152602001600081525090565b60007f0000000000000000000000000000000000000000000000000000000000000000670de0b6b3a764000085602001516107229190610f91565b61072c9190610fdd565b60408051606081018252948552945160208501529383019390935250919050565b61077160405180606001604052806000815260200160008152602001600081525090565b60008060008473ffffffffffffffffffffffffffffffffffffffff1663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156107c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e59190610f41565b5060408051606081018252918252602082019390935269ffffffffffffffffffff909316918301919091525095945050505050565b61083e60405180606001604052806000815260200160008152602001600081525090565b60008061085084604090810151901c90565b61ffff168154811061086457610864610ea4565b6000918252602080832060408051808201825293909101546fffffffffffffffffffffffffffffffff808216808652700100000000000000000000000000000000909204169284018390529087015192945090916108c191610efc565b6108cb9190610f0f565b90506108d784826106c3565b949350505050565b6000805461020a90600190610f0f565b6000808573ffffffffffffffffffffffffffffffffffffffff8116639a6fc8f561091a876001610efc565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815269ffffffffffffffffffff909116600482015260240160a060405180830381865afa9250505080156109b3575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526109b091810190610f41565b60015b15610a175769ffffffffffffffffffff851615806109cf575081155b610a11578851821015610a11576109f28b69ffffffffffffffffffff8716610f0f565b6109fd906001610efc565b896040015197509750505050505050610baa565b50505050505b6040517f9a6fc8f500000000000000000000000000000000000000000000000000000000815269ffffffffffffffffffff8616600482015260009073ffffffffffffffffffffffffffffffffffffffff831690639a6fc8f59060240160a060405180830381865afa158015610a90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab49190610f41565b5060408901518951909750909450925050505b818110610b825783610ad88161106c565b6040517f9a6fc8f500000000000000000000000000000000000000000000000000000000815269ffffffffffffffffffff8216600482015290955073ffffffffffffffffffffffffffffffffffffffff85169150639a6fc8f59060240160a060405180830381865afa158015610b52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b769190610f41565b509350610ac792505050565b610b8c8888610f0f565b610b97906001610efc565b610ba2856001610efc565b945094505050505b94509492505050565b60408051808201909152600080825260208201526000610bd16108df565b61ffff16905060008181548110610bea57610bea610ea4565b6000918252602091829020604080518082019091529101546fffffffffffffffffffffffffffffffff8082168352700100000000000000000000000000000000909104169181019190915291505b81516fffffffffffffffffffffffffffffffff16831015610cc55780610c5d8161106c565b91505060008181548110610c7357610c73610ea4565b6000918252602091829020604080518082019091529101546fffffffffffffffffffffffffffffffff808216835270010000000000000000000000000000000090910416918101919091529150610c38565b50919050565b60005b83811015610ce6578181015183820152602001610cce565b50506000910152565b6020815260008251806020840152610d0e816040850160208701610ccb565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600060208284031215610d5257600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d9a57600080fd5b815167ffffffffffffffff80821115610db257600080fd5b818401915084601f830112610dc657600080fd5b815181811115610dd857610dd8610d59565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610e1e57610e1e610d59565b81604052828152876020848701011115610e3757600080fd5b610e48836020830160208801610ccb565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b61ffff828116828216039080821115610e9d57610e9d610e53565b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6fffffffffffffffffffffffffffffffff818116838216019080821115610e9d57610e9d610e53565b8082018082111561028557610285610e53565b8181038181111561028557610285610e53565b805169ffffffffffffffffffff81168114610f3c57600080fd5b919050565b600080600080600060a08688031215610f5957600080fd5b610f6286610f22565b9450602086015193506040860151925060608601519150610f8560808701610f22565b90509295509295909350565b808202600082127f800000000000000000000000000000000000000000000000000000000000000084141615610fc957610fc9610e53565b818105831482151761028557610285610e53565b600082611013577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f80000000000000000000000000000000000000000000000000000000000000008314161561106757611067610e53565b500590565b60008161107b5761107b610e53565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea26469706673582212203a8fa95e78931ed2f73d207a5632cb5bc5fe86983977a5bad49f45c4df4fdff864736f6c63430008130033290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100725760003560e01c80637ece075d116100505780637ece075d146101125780639d888e8614610147578063fff6cae91461014f57600080fd5b8063245a7bfc1461007757806325882087146100c85780637284e4161461010a575b600080fd5b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b60408051808201909152600981527f636861696e6c696e6b000000000000000000000000000000000000000000000060208201525b6040516100bf9190610cef565b6100fd610157565b610125610120366004610d40565b61020f565b60408051825181526020808401519082015291810151908201526060016100bf565b61012561028b565b6101256102f6565b60607f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637284e4166040518163ffffffff1660e01b8152600401600060405180830381865afa1580156101c4573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261020a9190810190610d88565b905090565b61023360405180606001604052806000815260200160008152602001600081525090565b61028561027f61024284610581565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906105d9565b836106c3565b92915050565b6102af60405180606001604052806000815260200160008152602001600081525090565b61020a6102f17f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661074d565b61081a565b61031a60405180606001604052806000815260200160008152602001600081525090565b600061035b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661074d565b9050806040015167ffffffffffffffff166000036103a5576040517f5234755400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60016103af6108df565b6040838101516103c092911c610e82565b61ffff1611156103fc576040517f68e7727f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6104046108df565b61ffff1661041782604090810151901c90565b61ffff16111561056a576000806104b960006104316108df565b61ffff168154811061044557610445610ea4565b6000918252602090912001546001547f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169170010000000000000000000000000000000090046fffffffffffffffffffffffffffffffff1690866108ef565b915091506000604051806040016040528060006104d46108df565b61ffff16815481106104e8576104e8610ea4565b600091825260209091200154610510906fffffffffffffffffffffffffffffffff1686610ed3565b6fffffffffffffffffffffffffffffffff90811682529384166020918201528254600181018455600093845292819020825192909101518416700100000000000000000000000000000000029190931617910155506103fc565b604081015160015561057b8161081a565b91505090565b60008061058d83610bb3565b905080600001516fffffffffffffffffffffffffffffffff168382602001516fffffffffffffffffffffffffffffffff166105c89190610efc565b6105d29190610f0f565b9392505050565b6105fd60405180606001604052806000815260200160008152602001600081525090565b6040517f9a6fc8f500000000000000000000000000000000000000000000000000000000815269ffffffffffffffffffff83166004820152600090819073ffffffffffffffffffffffffffffffffffffffff861690639a6fc8f59060240160a060405180830381865afa158015610678573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069c9190610f41565b50604080516060810182529182526020820193909352918201969096529695505050505050565b6106e760405180606001604052806000815260200160008152602001600081525090565b60007f0000000000000000000000000000000000000000000000000000000000000000670de0b6b3a764000085602001516107229190610f91565b61072c9190610fdd565b60408051606081018252948552945160208501529383019390935250919050565b61077160405180606001604052806000815260200160008152602001600081525090565b60008060008473ffffffffffffffffffffffffffffffffffffffff1663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156107c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e59190610f41565b5060408051606081018252918252602082019390935269ffffffffffffffffffff909316918301919091525095945050505050565b61083e60405180606001604052806000815260200160008152602001600081525090565b60008061085084604090810151901c90565b61ffff168154811061086457610864610ea4565b6000918252602080832060408051808201825293909101546fffffffffffffffffffffffffffffffff808216808652700100000000000000000000000000000000909204169284018390529087015192945090916108c191610efc565b6108cb9190610f0f565b90506108d784826106c3565b949350505050565b6000805461020a90600190610f0f565b6000808573ffffffffffffffffffffffffffffffffffffffff8116639a6fc8f561091a876001610efc565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815269ffffffffffffffffffff909116600482015260240160a060405180830381865afa9250505080156109b3575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526109b091810190610f41565b60015b15610a175769ffffffffffffffffffff851615806109cf575081155b610a11578851821015610a11576109f28b69ffffffffffffffffffff8716610f0f565b6109fd906001610efc565b896040015197509750505050505050610baa565b50505050505b6040517f9a6fc8f500000000000000000000000000000000000000000000000000000000815269ffffffffffffffffffff8616600482015260009073ffffffffffffffffffffffffffffffffffffffff831690639a6fc8f59060240160a060405180830381865afa158015610a90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab49190610f41565b5060408901518951909750909450925050505b818110610b825783610ad88161106c565b6040517f9a6fc8f500000000000000000000000000000000000000000000000000000000815269ffffffffffffffffffff8216600482015290955073ffffffffffffffffffffffffffffffffffffffff85169150639a6fc8f59060240160a060405180830381865afa158015610b52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b769190610f41565b509350610ac792505050565b610b8c8888610f0f565b610b97906001610efc565b610ba2856001610efc565b945094505050505b94509492505050565b60408051808201909152600080825260208201526000610bd16108df565b61ffff16905060008181548110610bea57610bea610ea4565b6000918252602091829020604080518082019091529101546fffffffffffffffffffffffffffffffff8082168352700100000000000000000000000000000000909104169181019190915291505b81516fffffffffffffffffffffffffffffffff16831015610cc55780610c5d8161106c565b91505060008181548110610c7357610c73610ea4565b6000918252602091829020604080518082019091529101546fffffffffffffffffffffffffffffffff808216835270010000000000000000000000000000000090910416918101919091529150610c38565b50919050565b60005b83811015610ce6578181015183820152602001610cce565b50506000910152565b6020815260008251806020840152610d0e816040850160208701610ccb565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600060208284031215610d5257600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d9a57600080fd5b815167ffffffffffffffff80821115610db257600080fd5b818401915084601f830112610dc657600080fd5b815181811115610dd857610dd8610d59565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610e1e57610e1e610d59565b81604052828152876020848701011115610e3757600080fd5b610e48836020830160208801610ccb565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b61ffff828116828216039080821115610e9d57610e9d610e53565b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6fffffffffffffffffffffffffffffffff818116838216019080821115610e9d57610e9d610e53565b8082018082111561028557610285610e53565b8181038181111561028557610285610e53565b805169ffffffffffffffffffff81168114610f3c57600080fd5b919050565b600080600080600060a08688031215610f5957600080fd5b610f6286610f22565b9450602086015193506040860151925060608601519150610f8560808701610f22565b90509295509295909350565b808202600082127f800000000000000000000000000000000000000000000000000000000000000084141615610fc957610fc9610e53565b818105831482151761028557610285610e53565b600082611013577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f80000000000000000000000000000000000000000000000000000000000000008314161561106757611067610e53565b500590565b60008161107b5761107b610e53565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea26469706673582212203a8fa95e78931ed2f73d207a5632cb5bc5fe86983977a5bad49f45c4df4fdff864736f6c63430008130033",
  "devdoc": {
    "details": "One instance per Chainlink price feed should be deployed. Multiple products may use the same      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.      This implementation only support non-negative prices.",
    "errors": {
      "InvalidOracleRound()": [
        {
          "details": "Error for invalid oracle round"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "atVersion(uint256)": {
        "params": {
          "version": "The version of which to lookup"
        },
        "returns": {
          "oracleVersion": "Oracle version at version `version`"
        }
      },
      "constructor": {
        "params": {
          "aggregator_": "Chainlink price feed aggregator"
        }
      },
      "currentVersion()": {
        "returns": {
          "oracleVersion": "Current oracle version"
        }
      },
      "description()": {
        "returns": {
          "_0": "A string representing the description of the Oracle Provider."
        }
      },
      "oracleProviderName()": {
        "returns": {
          "_0": "A string representing the name of the Oracle Provider."
        }
      },
      "sync()": {
        "details": "`sync` is expected to be called soon after a phase update occurs in the underlying proxy.      Phase updates should be detected using off-chain mechanism and should trigger a `sync` call      This is feasible in the short term due to how infrequent phase updates are, but phase update      and roundCount detection should eventually be implemented at the contract level.      Reverts if there is more than 1 phase to update in a single sync because we currently cannot      determine the startingRoundId for the intermediary phase.",
        "returns": {
          "_0": "The current oracle version after sync"
        }
      }
    },
    "stateVariables": {
      "_decimalOffset": {
        "details": "Decimal offset used to normalize chainlink price to 18 decimals"
      },
      "_phases": {
        "details": "Mapping of the starting data for each underlying phase"
      },
      "aggregator": {
        "details": "Chainlink feed aggregator address"
      },
      "lastSyncedRoundId": {
        "details": "Last roundID seen when `sync` was called"
      }
    },
    "title": "ChainlinkOracle",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "atVersion(uint256)": {
        "notice": "Returns the current oracle version"
      },
      "constructor": {
        "notice": "Initializes the contract state"
      },
      "currentVersion()": {
        "notice": "Returns the current oracle version"
      },
      "description()": {
        "notice": "Retrieves the description of the Oracle Provider."
      },
      "oracleProviderName()": {
        "notice": "Retrieves the name of the Oracle Provider."
      },
      "sync()": {
        "notice": "Checks for a new price and updates the internal phase annotation state accordingly"
      }
    },
    "notice": "Chainlink implementation of the IOracle interface.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 33709,
        "contract": "contracts/oracle/ChainlinkFeedOracle.sol:ChainlinkFeedOracle",
        "label": "_phases",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_struct(Phase)33717_storage)dyn_storage"
      },
      {
        "astId": 33712,
        "contract": "contracts/oracle/ChainlinkFeedOracle.sol:ChainlinkFeedOracle",
        "label": "lastSyncedRoundId",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_array(t_struct(Phase)33717_storage)dyn_storage": {
        "base": "t_struct(Phase)33717_storage",
        "encoding": "dynamic_array",
        "label": "struct ChainlinkFeedOracle.Phase[]",
        "numberOfBytes": "32"
      },
      "t_struct(Phase)33717_storage": {
        "encoding": "inplace",
        "label": "struct ChainlinkFeedOracle.Phase",
        "members": [
          {
            "astId": 33714,
            "contract": "contracts/oracle/ChainlinkFeedOracle.sol:ChainlinkFeedOracle",
            "label": "startingVersion",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 33716,
            "contract": "contracts/oracle/ChainlinkFeedOracle.sol:ChainlinkFeedOracle",
            "label": "startingRoundId",
            "offset": 16,
            "slot": "0",
            "type": "t_uint128"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}