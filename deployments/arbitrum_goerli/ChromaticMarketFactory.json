{
  "address": "0xE51aBa7d3B09Ae73D36863B9fA5F20B5348DF542",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_marketDiamondCutFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketLoupeFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketStateFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketLiquidityFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketTradeFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketLiquidateFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketSettleFacet",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadySetKeeperFeePayer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AlreadySetLiquidator",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AlreadySetVault",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ExistMarket",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotRegisteredOracleProvider",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotRegisteredSettlementToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyAccessableByDao",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "annualRateBPS",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "beginTimestamp",
          "type": "uint256"
        }
      ],
      "name": "InterestRateRecordAppended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "annualRateBPS",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "beginTimestamp",
          "type": "uint256"
        }
      ],
      "name": "LastInterestRateRecordRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "settlementToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "market",
          "type": "address"
        }
      ],
      "name": "MarketCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "minTakeProfitBPS",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "maxTakeProfitBPS",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "leverageLevel",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct IOracleProviderRegistry.OracleProviderProperties",
          "name": "properties",
          "type": "tuple"
        }
      ],
      "name": "OracleProviderRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        }
      ],
      "name": "OracleProviderUnregistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "earningDistributionThreshold",
          "type": "uint256"
        }
      ],
      "name": "SetEarningDistributionThreshold",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "flashLoanFeeRate",
          "type": "uint256"
        }
      ],
      "name": "SetFlashLoanFeeRate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "keeperFeePayer",
          "type": "address"
        }
      ],
      "name": "SetKeeperFeePayer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "liquidator",
          "type": "address"
        }
      ],
      "name": "SetLiquidator",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "minimumMargin",
          "type": "uint256"
        }
      ],
      "name": "SetMinimumMargin",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "uniswapFeeTier",
          "type": "uint24"
        }
      ],
      "name": "SetUniswapFeeTier",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "SetVault",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "minimumMargin",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "flashLoanFeeRate",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earningDistributionThreshold",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint24",
          "name": "uniswapFeeTier",
          "type": "uint24"
        }
      ],
      "name": "SettlementTokenRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "dao",
          "type": "address"
        }
      ],
      "name": "UpdateDao",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint8",
          "name": "level",
          "type": "uint8"
        }
      ],
      "name": "UpdateLeverageLevel",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "minTakeProfitBPS",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "maxTakeProfitBPS",
          "type": "uint32"
        }
      ],
      "name": "UpdateTakeProfitBPSRange",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "treasury",
          "type": "address"
        }
      ],
      "name": "UpdateTreasury",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "annualRateBPS",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "beginTimestamp",
          "type": "uint256"
        }
      ],
      "name": "appendInterestRateRecord",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "to",
          "type": "uint256"
        }
      ],
      "name": "calculateInterest",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "settlementToken",
          "type": "address"
        }
      ],
      "name": "createMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "currentInterestRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "annualRateBPS",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dao",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getEarningDistributionThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getFlashLoanFeeRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getInterestRateRecords",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "annualRateBPS",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beginTimestamp",
              "type": "uint256"
            }
          ],
          "internalType": "struct InterestRate.Record[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "settlementToken",
          "type": "address"
        }
      ],
      "name": "getMarket",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMarkets",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "settlementToken",
          "type": "address"
        }
      ],
      "name": "getMarketsBySettlmentToken",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getMinimumMargin",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        }
      ],
      "name": "getOracleProviderProperties",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "minTakeProfitBPS",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "maxTakeProfitBPS",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "leverageLevel",
              "type": "uint8"
            }
          ],
          "internalType": "struct IOracleProviderRegistry.OracleProviderProperties",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getUniswapFeeTier",
      "outputs": [
        {
          "internalType": "uint24",
          "name": "",
          "type": "uint24"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "market",
          "type": "address"
        }
      ],
      "name": "isRegisteredMarket",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        }
      ],
      "name": "isRegisteredOracleProvider",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "isRegisteredSettlementToken",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "keeperFeePayer",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidator",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "parameters",
      "outputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "settlementToken",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "minTakeProfitBPS",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "maxTakeProfitBPS",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "leverageLevel",
              "type": "uint8"
            }
          ],
          "internalType": "struct IOracleProviderRegistry.OracleProviderProperties",
          "name": "properties",
          "type": "tuple"
        }
      ],
      "name": "registerOracleProvider",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minimumMargin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "flashLoanFeeRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "earningDistributionThreshold",
          "type": "uint256"
        },
        {
          "internalType": "uint24",
          "name": "uniswapFeeTier",
          "type": "uint24"
        }
      ],
      "name": "registerSettlementToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "registeredOracleProviders",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "registeredSettlementTokens",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "removeLastInterestRateRecord",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "earningDistributionThreshold",
          "type": "uint256"
        }
      ],
      "name": "setEarningDistributionThreshold",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "flashLoanFeeRate",
          "type": "uint256"
        }
      ],
      "name": "setFlashLoanFeeRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_keeperFeePayer",
          "type": "address"
        }
      ],
      "name": "setKeeperFeePayer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_liquidator",
          "type": "address"
        }
      ],
      "name": "setLiquidator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minimumMargin",
          "type": "uint256"
        }
      ],
      "name": "setMinimumMargin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint24",
          "name": "uniswapFeeTier",
          "type": "uint24"
        }
      ],
      "name": "setUniswapFeeTier",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        }
      ],
      "name": "setVault",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        }
      ],
      "name": "unregisterOracleProvider",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_dao",
          "type": "address"
        }
      ],
      "name": "updateDao",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "level",
          "type": "uint8"
        }
      ],
      "name": "updateLeverageLevel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oracleProvider",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "minTakeProfitBPS",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "maxTakeProfitBPS",
          "type": "uint32"
        }
      ],
      "name": "updateTakeProfitBPSRange",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_treasury",
          "type": "address"
        }
      ],
      "name": "updateTreasury",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vault",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2d4a05de12e143482fc2ae661471397a3b3f3c26b4bcbc77cc43e3242d9a3866",
  "receipt": {
    "to": null,
    "from": "0x3bD0496CA35b200FCc21CAc644208F7b11838EF6",
    "contractAddress": "0xE51aBa7d3B09Ae73D36863B9fA5F20B5348DF542",
    "transactionIndex": 1,
    "gasUsed": "3125695",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb580f36794e61d2566e09ea5413ec0bf87ddfb08ddf85061aa4ea87569a2b737",
    "transactionHash": "0x2d4a05de12e143482fc2ae661471397a3b3f3c26b4bcbc77cc43e3242d9a3866",
    "logs": [],
    "blockNumber": 31059299,
    "cumulativeGasUsed": "3125695",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x56c6Aae1CE48091026bF54fe673ac870897Fd183",
    "0x67eCa3E955Ac48cd65FE271bD28A5B6f42470013",
    "0x846614f97e8985D2699a500939B6BE2C0A51479D",
    "0x460248fDd9Ff3c64534b917D7f03907E24644E98",
    "0x049164542dA0b648813e523884aE87B158b188D5",
    "0x4F4fEdFB43ac819B7A0481DBE89dad29069045bF",
    "0x6d5923139137139eA0C12A3242D914EB862439a2"
  ],
  "numDeployments": 6,
  "solcInputHash": "c3a3aa6825039bf158183995a7642b86",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketDiamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketLoupeFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketStateFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketLiquidityFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketTradeFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketLiquidateFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketSettleFacet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadySetKeeperFeePayer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySetLiquidator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySetVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExistMarket\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRegisteredOracleProvider\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRegisteredSettlementToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAccessableByDao\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"annualRateBPS\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"beginTimestamp\",\"type\":\"uint256\"}],\"name\":\"InterestRateRecordAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"annualRateBPS\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"beginTimestamp\",\"type\":\"uint256\"}],\"name\":\"LastInterestRateRecordRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"settlementToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"MarketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"minTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"leverageLevel\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct IOracleProviderRegistry.OracleProviderProperties\",\"name\":\"properties\",\"type\":\"tuple\"}],\"name\":\"OracleProviderRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"}],\"name\":\"OracleProviderUnregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"earningDistributionThreshold\",\"type\":\"uint256\"}],\"name\":\"SetEarningDistributionThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"flashLoanFeeRate\",\"type\":\"uint256\"}],\"name\":\"SetFlashLoanFeeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeperFeePayer\",\"type\":\"address\"}],\"name\":\"SetKeeperFeePayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"SetLiquidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"minimumMargin\",\"type\":\"uint256\"}],\"name\":\"SetMinimumMargin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"uniswapFeeTier\",\"type\":\"uint24\"}],\"name\":\"SetUniswapFeeTier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"SetVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"minimumMargin\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flashLoanFeeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earningDistributionThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"uniswapFeeTier\",\"type\":\"uint24\"}],\"name\":\"SettlementTokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"UpdateDao\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"UpdateLeverageLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"minTakeProfitBPS\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"maxTakeProfitBPS\",\"type\":\"uint32\"}],\"name\":\"UpdateTakeProfitBPSRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"UpdateTreasury\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"annualRateBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beginTimestamp\",\"type\":\"uint256\"}],\"name\":\"appendInterestRateRecord\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"calculateInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementToken\",\"type\":\"address\"}],\"name\":\"createMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"currentInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"annualRateBPS\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getEarningDistributionThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFlashLoanFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getInterestRateRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"annualRateBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beginTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct InterestRate.Record[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementToken\",\"type\":\"address\"}],\"name\":\"getMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarkets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"settlementToken\",\"type\":\"address\"}],\"name\":\"getMarketsBySettlmentToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMinimumMargin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"}],\"name\":\"getOracleProviderProperties\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"minTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"leverageLevel\",\"type\":\"uint8\"}],\"internalType\":\"struct IOracleProviderRegistry.OracleProviderProperties\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUniswapFeeTier\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"isRegisteredMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"}],\"name\":\"isRegisteredOracleProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isRegisteredSettlementToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperFeePayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"minTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"leverageLevel\",\"type\":\"uint8\"}],\"internalType\":\"struct IOracleProviderRegistry.OracleProviderProperties\",\"name\":\"properties\",\"type\":\"tuple\"}],\"name\":\"registerOracleProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashLoanFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earningDistributionThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"uniswapFeeTier\",\"type\":\"uint24\"}],\"name\":\"registerSettlementToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registeredOracleProviders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registeredSettlementTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeLastInterestRateRecord\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earningDistributionThreshold\",\"type\":\"uint256\"}],\"name\":\"setEarningDistributionThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashLoanFeeRate\",\"type\":\"uint256\"}],\"name\":\"setFlashLoanFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeperFeePayer\",\"type\":\"address\"}],\"name\":\"setKeeperFeePayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"}],\"name\":\"setLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumMargin\",\"type\":\"uint256\"}],\"name\":\"setMinimumMargin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"uniswapFeeTier\",\"type\":\"uint24\"}],\"name\":\"setUniswapFeeTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"}],\"name\":\"unregisterOracleProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"updateDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"updateLeverageLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProvider\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minTakeProfitBPS\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTakeProfitBPS\",\"type\":\"uint32\"}],\"name\":\"updateTakeProfitBPSRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"updateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract for managing the creation and registration of Chromatic markets.\",\"errors\":{\"AlreadySetKeeperFeePayer()\":[{\"details\":\"Throws an error indicating that the keeper fee payer address is already set.\"}],\"AlreadySetLiquidator()\":[{\"details\":\"Throws an error indicating that the chromatic liquidator address is already set.\"}],\"AlreadySetVault()\":[{\"details\":\"Throws an error indicating that the chromatic vault address is already set.\"}],\"ExistMarket()\":[{\"details\":\"Throws an error indicating that a market already exists for the given oracle provider and settlement token.\"}],\"NotRegisteredOracleProvider()\":[{\"details\":\"Throws an error indicating that the oracle provider is not registered.\"}],\"NotRegisteredSettlementToken()\":[{\"details\":\"Throws an error indicating that the settlement token is not registered.\"}],\"OnlyAccessableByDao()\":[{\"details\":\"Throws an error indicating that the caller is not the DAO.\"}]},\"events\":{\"InterestRateRecordAppended(address,uint256,uint256)\":{\"details\":\"Emitted when an interest rate record is appended for a settlement token.\",\"params\":{\"annualRateBPS\":\"The annual interest rate in basis points (BPS).\",\"beginTimestamp\":\"The timestamp when the interest rate record begins.\",\"token\":\"The address of the settlement token.\"}},\"LastInterestRateRecordRemoved(address,uint256,uint256)\":{\"details\":\"Emitted when the last interest rate record is removed for a settlement token.\",\"params\":{\"annualRateBPS\":\"The annual interest rate in basis points (BPS).\",\"beginTimestamp\":\"The timestamp when the interest rate record begins.\",\"token\":\"The address of the settlement token.\"}},\"MarketCreated(address,address,address)\":{\"params\":{\"market\":\"The address of the created market.\",\"oracleProvider\":\"The address of the oracle provider.\",\"settlementToken\":\"The address of the settlement token.\"}},\"OracleProviderRegistered(address,(uint32,uint32,uint8))\":{\"details\":\"Emitted when a new oracle provider is registered.\",\"params\":{\"oracleProvider\":\"The address of the registered oracle provider.\",\"properties\":\"The properties of the registered oracle provider.\"}},\"OracleProviderUnregistered(address)\":{\"details\":\"Emitted when an oracle provider is unregistered.\",\"params\":{\"oracleProvider\":\"The address of the unregistered oracle provider.\"}},\"SetEarningDistributionThreshold(address,uint256)\":{\"details\":\"Emitted when the earning distribution threshold for a settlement token is set.\",\"params\":{\"earningDistributionThreshold\":\"The new earning distribution threshold for the settlement token.\",\"token\":\"The address of the settlement token.\"}},\"SetFlashLoanFeeRate(address,uint256)\":{\"details\":\"Emitted when the flash loan fee rate for a settlement token is set.\",\"params\":{\"flashLoanFeeRate\":\"The new flash loan fee rate for the settlement token.\",\"token\":\"The address of the settlement token.\"}},\"SetKeeperFeePayer(address)\":{\"params\":{\"keeperFeePayer\":\"The keeper fee payer address.\"}},\"SetLiquidator(address)\":{\"params\":{\"liquidator\":\"The liquidator address.\"}},\"SetMinimumMargin(address,uint256)\":{\"details\":\"Emitted when the minimum margin for a settlement token is set.\",\"params\":{\"minimumMargin\":\"The new minimum margin for the settlement token.\",\"token\":\"The address of the settlement token.\"}},\"SetUniswapFeeTier(address,uint24)\":{\"details\":\"Emitted when the Uniswap fee tier for a settlement token is set.\",\"params\":{\"token\":\"The address of the settlement token.\",\"uniswapFeeTier\":\"The new Uniswap fee tier for the settlement token.\"}},\"SetVault(address)\":{\"params\":{\"vault\":\"The vault address.\"}},\"SettlementTokenRegistered(address,uint256,uint256,uint256,uint256,uint24)\":{\"details\":\"Emitted when a new settlement token is registered.\",\"params\":{\"earningDistributionThreshold\":\"The earning distribution threshold for the settlement token.\",\"flashLoanFeeRate\":\"The flash loan fee rate for the settlement token.\",\"interestRate\":\"The interest rate for the settlement token.\",\"minimumMargin\":\"The minimum margin for the markets using this settlement token.\",\"token\":\"The address of the registered settlement token.\",\"uniswapFeeTier\":\"The Uniswap fee tier for the settlement token.\"}},\"UpdateDao(address)\":{\"params\":{\"dao\":\"The new DAO address.\"}},\"UpdateLeverageLevel(address,uint8)\":{\"details\":\"Emitted when the level of an oracle provider is set.\",\"params\":{\"level\":\"The new level set for the oracle provider.\",\"oracleProvider\":\"The address of the oracle provider.\"}},\"UpdateTakeProfitBPSRange(address,uint32,uint32)\":{\"details\":\"Emitted when the take-profit basis points range of an oracle provider is updated.\",\"params\":{\"maxTakeProfitBPS\":\"The new maximum take-profit basis points.\",\"minTakeProfitBPS\":\"The new minimum take-profit basis points.\",\"oracleProvider\":\"The address of the oracle provider.\"}},\"UpdateTreasury(address)\":{\"params\":{\"treasury\":\"The new DAO treasury address.\"}}},\"kind\":\"dev\",\"methods\":{\"appendInterestRateRecord(address,uint256,uint256)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"annualRateBPS\":\"The annual interest rate in basis points (BPS).\",\"beginTimestamp\":\"The timestamp when the interest rate record begins.\",\"token\":\"The address of the settlement token.\"}},\"calculateInterest(address,uint256,uint256,uint256)\":{\"params\":{\"amount\":\"The amount of the token.\",\"from\":\"The starting timestamp (inclusive) of the time range.\",\"to\":\"The ending timestamp (exclusive) of the time range.\",\"token\":\"The address of the token.\"},\"returns\":{\"_0\":\"The accrued interest for the specified token and amount within the given time range.\"}},\"constructor\":{\"details\":\"Initializes the ChromaticMarketFactory contract.\",\"params\":{\"_marketDiamondCutFacet\":\"The market diamond cut facet address.\",\"_marketLiquidateFacet\":\"The market liquidate facet address.\",\"_marketLiquidityFacet\":\"The market liquidity facet address.\",\"_marketLoupeFacet\":\"The market loupe facet address.\",\"_marketSettleFacet\":\"The market settle facet address.\",\"_marketStateFacet\":\"The market state facet address.\",\"_marketTradeFacet\":\"The market trade facet address.\"}},\"createMarket(address,address)\":{\"details\":\"This function creates a new market using the specified oracle provider and settlement token addresses.      Throws a `NotRegisteredSettlementToken` error if the settlement token is not registered.      Throws an `ExistMarket` error if the market already exists for the given oracle provider and settlement token.\",\"params\":{\"oracleProvider\":\"The address of the oracle provider.\",\"settlementToken\":\"The address of the settlement token.\"}},\"currentInterestRate(address)\":{\"params\":{\"token\":\"The address of the settlement token.\"},\"returns\":{\"annualRateBPS\":\"The current interest rate for the settlement token.\"}},\"getEarningDistributionThreshold(address)\":{\"params\":{\"token\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"The earning distribution threshold for the settlement token.\"}},\"getFlashLoanFeeRate(address)\":{\"params\":{\"token\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"The flash loan fee rate for the settlement token.\"}},\"getInterestRateRecords(address)\":{\"params\":{\"token\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"An array of interest rate records for the settlement token.\"}},\"getMarket(address,address)\":{\"params\":{\"oracleProvider\":\"The address of the oracle provider.\",\"settlementToken\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"The address of the market.\"}},\"getMarkets()\":{\"returns\":{\"_0\":\"An array of all market addresses.\"}},\"getMarketsBySettlmentToken(address)\":{\"params\":{\"settlementToken\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"An array of market addresses.\"}},\"getMinimumMargin(address)\":{\"details\":\"The minimumMargin is used as the minimum value for the taker margin of a position      or as the minimum value for the maker margin of each bin.\",\"params\":{\"token\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"The minimum margin for the settlement token.\"}},\"getOracleProviderProperties(address)\":{\"params\":{\"oracleProvider\":\"The address of the oracle provider.\"},\"returns\":{\"_0\":\"The properties of the oracle provider.\"}},\"getUniswapFeeTier(address)\":{\"params\":{\"token\":\"The address of the settlement token.\"},\"returns\":{\"_0\":\"The Uniswap fee tier for the settlement token.\"}},\"isRegisteredMarket(address)\":{\"params\":{\"market\":\"The address of the market.\"},\"returns\":{\"_0\":\"True if the market is registered, false otherwise.\"}},\"isRegisteredOracleProvider(address)\":{\"params\":{\"oracleProvider\":\"The address of the oracle provider to check.\"},\"returns\":{\"_0\":\"A boolean indicating if the oracle provider is registered.\"}},\"isRegisteredSettlementToken(address)\":{\"params\":{\"token\":\"The address of the settlement token to check.\"},\"returns\":{\"_0\":\"True if the settlement token is registered, false otherwise.\"}},\"parameters()\":{\"details\":\"Called by the market constructor to fetch the parameters of the market Returns underlyingAsset The underlying asset of the market Returns settlementToken The settlement token of the market Returns vPoolCapacity Capacity of virtual future pool Returns vPoolA Amplification coefficient of virtual future pool, precise value\"},\"registerOracleProvider(address,(uint32,uint32,uint8))\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"oracleProvider\":\"The address of the oracle provider to register.\",\"properties\":\"The properties of the oracle provider.\"}},\"registerSettlementToken(address,uint256,uint256,uint256,uint256,uint24)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"earningDistributionThreshold\":\"The earning distribution threshold for the settlement token.\",\"flashLoanFeeRate\":\"The flash loan fee rate for the settlement token.\",\"interestRate\":\"The interest rate for the settlement token.\",\"minimumMargin\":\"The minimum margin for the settlement token.\",\"token\":\"The address of the settlement token to register.\",\"uniswapFeeTier\":\"The Uniswap fee tier for the settlement token.\"}},\"registeredOracleProviders()\":{\"returns\":{\"_0\":\"An array of registered oracle provider addresses.\"}},\"registeredSettlementTokens()\":{\"returns\":{\"_0\":\"An array of addresses representing the registered settlement tokens.\"}},\"removeLastInterestRateRecord(address)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"token\":\"The address of the settlement token.\"}},\"setEarningDistributionThreshold(address,uint256)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"earningDistributionThreshold\":\"The new earning distribution threshold for the settlement token.\",\"token\":\"The address of the settlement token.\"}},\"setFlashLoanFeeRate(address,uint256)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"flashLoanFeeRate\":\"The new flash loan fee rate for the settlement token.\",\"token\":\"The address of the settlement token.\"}},\"setKeeperFeePayer(address)\":{\"details\":\"This function can only be called by the DAO address.      Throws an `AlreadySetKeeperFeePayer` error if the keeper fee payer address has already been set.\",\"params\":{\"keeperFeePayer\":\"The keeper fee payer address.\"}},\"setLiquidator(address)\":{\"details\":\"This function can only be called by the DAO address.      Throws an `AlreadySetLiquidator` error if the liquidator address has already been set.\",\"params\":{\"liquidator\":\"The liquidator address.\"}},\"setMinimumMargin(address,uint256)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"minimumMargin\":\"The new minimum margin for the settlement token.\",\"token\":\"The address of the settlement token.\"}},\"setUniswapFeeTier(address,uint24)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"token\":\"The address of the settlement token.\",\"uniswapFeeTier\":\"The new Uniswap fee tier for the settlement token.\"}},\"setVault(address)\":{\"details\":\"This function can only be called by the DAO address.      Throws an `AlreadySetVault` error if the vault address has already been set.\",\"params\":{\"vault\":\"The vault address.\"}},\"unregisterOracleProvider(address)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"oracleProvider\":\"The address of the oracle provider to unregister.\"}},\"updateDao(address)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"dao\":\"The new DAO address.\"}},\"updateLeverageLevel(address,uint8)\":{\"details\":\"This function can only be called by the DAO and registered oracle providers.\",\"params\":{\"level\":\"The new leverage level to be set for the oracle provider.\",\"oracleProvider\":\"The address of the oracle provider.\"}},\"updateTakeProfitBPSRange(address,uint32,uint32)\":{\"details\":\"This function can only be called by the DAO and registered oracle providers.\",\"params\":{\"maxTakeProfitBPS\":\"The new maximum take-profit basis points.\",\"minTakeProfitBPS\":\"The new minimum take-profit basis points.\",\"oracleProvider\":\"The address of the oracle provider.\"}},\"updateTreasury(address)\":{\"details\":\"This function can only be called by the DAO address.\",\"params\":{\"treasury\":\"The new DAO treasury address.\"}}},\"stateVariables\":{\"dao\":{\"return\":\"The address of the DAO.\",\"returns\":{\"_0\":\"The address of the DAO.\"}},\"keeperFeePayer\":{\"return\":\"The address of the keeper fee payer.\",\"returns\":{\"_0\":\"The address of the keeper fee payer.\"}},\"liquidator\":{\"return\":\"The address of the liquidator.\",\"returns\":{\"_0\":\"The address of the liquidator.\"}},\"treasury\":{\"return\":\"The address of the DAO treasury.\",\"returns\":{\"_0\":\"The address of the DAO treasury.\"}},\"vault\":{\"return\":\"The address of the vault.\",\"returns\":{\"_0\":\"The address of the vault.\"}}},\"title\":\"ChromaticMarketFactory\",\"version\":1},\"userdoc\":{\"events\":{\"MarketCreated(address,address,address)\":{\"notice\":\"Emitted when a market is created.\"},\"SetKeeperFeePayer(address)\":{\"notice\":\"Emitted when the keeper fee payer address is set.\"},\"SetLiquidator(address)\":{\"notice\":\"Emitted when the liquidator address is set.\"},\"SetVault(address)\":{\"notice\":\"Emitted when the vault address is set.\"},\"UpdateDao(address)\":{\"notice\":\"Emitted when the DAO address is updated.\"},\"UpdateTreasury(address)\":{\"notice\":\"Emitted when the DAO treasury address is updated.\"}},\"kind\":\"user\",\"methods\":{\"appendInterestRateRecord(address,uint256,uint256)\":{\"notice\":\"Appends an interest rate record for a settlement token.\"},\"calculateInterest(address,uint256,uint256,uint256)\":{\"notice\":\"Calculates the interest accrued for a given token and amount within a specified time range.\"},\"createMarket(address,address)\":{\"notice\":\"Creates a new market associated with an oracle provider and settlement token.\"},\"currentInterestRate(address)\":{\"notice\":\"Gets the current interest rate for a settlement token.\"},\"dao()\":{\"notice\":\"Returns the address of the DAO.\"},\"getEarningDistributionThreshold(address)\":{\"notice\":\"Gets the earning distribution threshold for a settlement token.\"},\"getFlashLoanFeeRate(address)\":{\"notice\":\"Gets the flash loan fee rate for a settlement token.\"},\"getInterestRateRecords(address)\":{\"notice\":\"Gets all the interest rate records for a settlement token.\"},\"getMarket(address,address)\":{\"notice\":\"Returns the address of a market associated with an oracle provider and settlement token.\"},\"getMarkets()\":{\"notice\":\"Returns an array of all market addresses.\"},\"getMarketsBySettlmentToken(address)\":{\"notice\":\"Returns an array of market addresses associated with a settlement token.\"},\"getMinimumMargin(address)\":{\"notice\":\"Gets the minimum margin for a settlement token.\"},\"getOracleProviderProperties(address)\":{\"notice\":\"Retrieves the properties of an oracle provider.\"},\"getUniswapFeeTier(address)\":{\"notice\":\"Gets the Uniswap fee tier for a settlement token.\"},\"isRegisteredMarket(address)\":{\"notice\":\"Checks if a market is registered.\"},\"isRegisteredOracleProvider(address)\":{\"notice\":\"Checks if an oracle provider is registered.\"},\"isRegisteredSettlementToken(address)\":{\"notice\":\"Checks if a settlement token is registered.\"},\"keeperFeePayer()\":{\"notice\":\"Returns the address of the keeper fee payer.\"},\"liquidator()\":{\"notice\":\"Returns the address of the liquidator.\"},\"parameters()\":{\"notice\":\"Get the parameters to be used in constructing the market, set transiently during market creation.\"},\"registerOracleProvider(address,(uint32,uint32,uint8))\":{\"notice\":\"Registers an oracle provider.\"},\"registerSettlementToken(address,uint256,uint256,uint256,uint256,uint24)\":{\"notice\":\"Registers a new settlement token.\"},\"registeredOracleProviders()\":{\"notice\":\"Gets the registered oracle providers.\"},\"registeredSettlementTokens()\":{\"notice\":\"Gets the list of registered settlement tokens.\"},\"removeLastInterestRateRecord(address)\":{\"notice\":\"Removes the last interest rate record for a settlement token.\"},\"setEarningDistributionThreshold(address,uint256)\":{\"notice\":\"Sets the earning distribution threshold for a settlement token.\"},\"setFlashLoanFeeRate(address,uint256)\":{\"notice\":\"Sets the flash loan fee rate for a settlement token.\"},\"setKeeperFeePayer(address)\":{\"notice\":\"Sets the keeper fee payer address.\"},\"setLiquidator(address)\":{\"notice\":\"Sets the liquidator address.\"},\"setMinimumMargin(address,uint256)\":{\"notice\":\"Sets the minimum margin for a settlement token.\"},\"setUniswapFeeTier(address,uint24)\":{\"notice\":\"Sets the Uniswap fee tier for a settlement token.\"},\"setVault(address)\":{\"notice\":\"Sets the vault address.\"},\"treasury()\":{\"notice\":\"Returns the address of the DAO treasury.\"},\"unregisterOracleProvider(address)\":{\"notice\":\"Unregisters an oracle provider.\"},\"updateDao(address)\":{\"notice\":\"Updates the DAO address.\"},\"updateLeverageLevel(address,uint8)\":{\"notice\":\"Updates the leverage level of an oracle provider in the registry.\"},\"updateTakeProfitBPSRange(address,uint32,uint32)\":{\"notice\":\"Updates the take-profit basis points range of an oracle provider.\"},\"updateTreasury(address)\":{\"notice\":\"Updates the DAO treasury address.\"},\"vault()\":{\"notice\":\"Returns the address of the vault.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/ChromaticMarketFactory.sol\":\"ChromaticMarketFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":30000},\"remappings\":[\":@chromatic-protocol/contracts/=contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\"]},\"sources\":{\"@equilibria/root/number/NumberMath.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\n\\n/**\\n * @title NumberMath\\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\\n */\\nlibrary NumberMath {\\n    error DivisionByZero();\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) revert DivisionByZero();\\n        return Math.ceilDiv(a, b);\\n    }\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the sign of an int256\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a int256 to find the sign of\\n     * @return Sign of the int256\\n     */\\n    function sign(int256 a) internal pure returns (int256) {\\n        if (a > 0) return 1;\\n        if (a < 0) return -1;\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3578ce6e74ee6589ba0468e2c539ef1eb51d6687b508e637620926eb8396b4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\nimport \\\"./PackedFixed18.sol\\\";\\n\\n/// @dev Fixed18 type\\ntype Fixed18 is int256;\\nusing Fixed18Lib for Fixed18 global;\\ntype Fixed18Storage is bytes32;\\nusing Fixed18StorageLib for Fixed18Storage global;\\n\\n/**\\n * @title Fixed18Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed18Lib {\\n    error Fixed18OverflowError(uint256 value);\\n    error Fixed18PackingOverflowError(int256 value);\\n    error Fixed18PackingUnderflowError(int256 value);\\n\\n    int256 private constant BASE = 1e18;\\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (Fixed18) {\\n        uint256 value = UFixed18.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\\n        return Fixed18.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates a packed signed fixed-decimal from an signed fixed-decimal\\n     * @param a signed fixed-decimal\\n     * @return New packed signed fixed-decimal\\n     */\\n    function pack(Fixed18 a) internal pure returns (PackedFixed18) {\\n        int256 value = Fixed18.unwrap(a);\\n        if (value > type(int128).max) revert Fixed18PackingOverflowError(value);\\n        if (value < type(int128).min) revert Fixed18PackingUnderflowError(value);\\n        return PackedFixed18.wrap(int128(value));\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed18 a) internal pure returns (bool) {\\n        return Fixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed18 a) internal pure returns (int256) {\\n        return Fixed18.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed18 a) internal pure returns (int256) {\\n        if (Fixed18.unwrap(a) > 0) return 1;\\n        if (Fixed18.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed18StorageLib {\\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed18Storage self, Fixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c09201756ee291d1a54dd3b04cf0af5bf5fdea47e8f090d5af3c217e926f5ee\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev Fixed6 type\\ntype Fixed6 is int256;\\nusing Fixed6Lib for Fixed6 global;\\ntype Fixed6Storage is bytes32;\\nusing Fixed6StorageLib for Fixed6Storage global;\\n\\n/**\\n * @title Fixed6Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed6Lib {\\n    error Fixed6OverflowError(uint256 value);\\n    error Fixed6PackingOverflowError(int256 value);\\n    error Fixed6PackingUnderflowError(int256 value);\\n\\n    int256 private constant BASE = 1e6;\\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (Fixed6) {\\n        uint256 value = UFixed6.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\\n        return Fixed6.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed6 a) internal pure returns (bool) {\\n        return Fixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed6 a) internal pure returns (int256) {\\n        return Fixed6.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed6 a) internal pure returns (int256) {\\n        if (Fixed6.unwrap(a) > 0) return 1;\\n        if (Fixed6.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed6StorageLib {\\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed6Storage self, Fixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x38397d2c63fadcf2787978cd4a4101ccacc4da7b062cd5fa99b36ab3846d7cb2\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/PackedFixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Fixed18.sol\\\";\\n\\n/// @dev PackedFixed18 type\\ntype PackedFixed18 is int128;\\nusing PackedFixed18Lib for PackedFixed18 global;\\n\\n/**\\n * @title PackedFixed18Lib\\n * @dev A packed version of the Fixed18 which takes up half the storage space (two PackedFixed18 can be packed\\n *      into a single slot). Only valid within the range -1.7014118e+20 <= x <= 1.7014118e+20.\\n * @notice Library for the packed signed fixed-decimal type.\\n */\\nlibrary PackedFixed18Lib {\\n    PackedFixed18 public constant MAX = PackedFixed18.wrap(type(int128).max);\\n    PackedFixed18 public constant MIN = PackedFixed18.wrap(type(int128).min);\\n\\n    /**\\n     * @notice Creates an unpacked signed fixed-decimal from a packed signed fixed-decimal\\n     * @param self packed signed fixed-decimal\\n     * @return New unpacked signed fixed-decimal\\n     */\\n    function unpack(PackedFixed18 self) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(int256(PackedFixed18.unwrap(self)));\\n    }\\n}\\n\",\"keccak256\":\"0xb52960cc8e3132e45d342bbbb1c6a96219022cd8557997933bd8250170268b64\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/PackedUFixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev PackedUFixed18 type\\ntype PackedUFixed18 is uint128;\\nusing PackedUFixed18Lib for PackedUFixed18 global;\\n\\n/**\\n * @title PackedUFixed18Lib\\n * @dev A packed version of the UFixed18 which takes up half the storage space (two PackedUFixed18 can be packed\\n *      into a single slot). Only valid within the range 0 <= x <= 3.4028237e+20.\\n * @notice Library for the packed unsigned fixed-decimal type.\\n */\\nlibrary PackedUFixed18Lib {\\n    PackedUFixed18 public constant MAX = PackedUFixed18.wrap(type(uint128).max);\\n\\n    /**\\n     * @notice Creates an unpacked unsigned fixed-decimal from a packed unsigned fixed-decimal\\n     * @param self packed unsigned fixed-decimal\\n     * @return New unpacked unsigned fixed-decimal\\n     */\\n    function unpack(PackedUFixed18 self) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(uint256(PackedUFixed18.unwrap(self)));\\n    }\\n}\\n\",\"keccak256\":\"0xb5c5cd32d6530b2fe75228b6be32ebcb7762f6d7988b85a6b85a289ce8256d51\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./PackedUFixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev UFixed18 type\\ntype UFixed18 is uint256;\\nusing UFixed18Lib for UFixed18 global;\\ntype UFixed18Storage is bytes32;\\nusing UFixed18StorageLib for UFixed18Storage global;\\n\\n/**\\n * @title UFixed18Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed18Lib {\\n    error UFixed18UnderflowError(int256 value);\\n    error UFixed18PackingOverflowError(uint256 value);\\n\\n    uint256 private constant BASE = 1e18;\\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (UFixed18) {\\n        int256 value = Fixed18.unwrap(a);\\n        if (value < 0) revert UFixed18UnderflowError(value);\\n        return UFixed18.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates a packed unsigned fixed-decimal from an unsigned fixed-decimal\\n     * @param a unsigned fixed-decimal\\n     * @return New packed unsigned fixed-decimal\\n     */\\n    function pack(UFixed18 a) internal pure returns (PackedUFixed18) {\\n        uint256 value = UFixed18.unwrap(a);\\n        if (value > type(uint128).max) revert UFixed18PackingOverflowError(value);\\n        return PackedUFixed18.wrap(uint128(value));\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed18 a) internal pure returns (bool) {\\n        return UFixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed18 a) internal pure returns (uint256) {\\n        return UFixed18.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed18StorageLib {\\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed18Storage self, UFixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcbcd3a035fc7129fc746d6dbebb3c9a9473172e3e7b7c01cf44774b71b33da6c\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev UFixed6 type\\ntype UFixed6 is uint256;\\nusing UFixed6Lib for UFixed6 global;\\ntype UFixed6Storage is bytes32;\\nusing UFixed6StorageLib for UFixed6Storage global;\\n\\n/**\\n * @title UFixed6Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed6Lib {\\n    error UFixed6UnderflowError(int256 value);\\n    error UFixed6PackingOverflowError(uint256 value);\\n\\n    uint256 private constant BASE = 1e6;\\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (UFixed6) {\\n        int256 value = Fixed6.unwrap(a);\\n        if (value < 0) revert UFixed6UnderflowError(value);\\n        return UFixed6.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed6 a) internal pure returns (bool) {\\n        return UFixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed6 a) internal pure returns (uint256) {\\n        return UFixed6.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed6StorageLib {\\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed6Storage self, UFixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf6407bf4286a410bdec2a39c1cbda92ef775f17ed24d8d174e8dbf45d9018bd6\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/interfaces/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC1155/IERC1155.sol\\\";\\n\",\"keccak256\":\"0x10a6688bc4154b1b76268dbaf497bd8b24f77525ecb9cf829bd3cccec98eefc2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\n\",\"keccak256\":\"0x8b4a492c14765d24f935516cb3437a1b39fbd65f20fc8828e7880fb1bdcfba86\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC1155/IERC1155Receiver.sol\\\";\\n\",\"keccak256\":\"0xdffd96e40500212217d1267d1fa5eb294fe72ce5419638d6801996e0485580b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\",\"keccak256\":\"0x687142c633b33037c3137b6bfeef848a44eb1ef83fb5fdb59a3affdf28a46516\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\",\"keccak256\":\"0x81149353c99ccf8ff18af7701bc3f38665c7a97e344cdc0d27f927f03d22af0e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcab667ddad478ff0d39c2053ca77fac778af8483c18ab07d810277b4216fd582\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xeb373f1fdc7b755c6a750123a9b9e3a8a02c1470042fd6505d875000a80bde0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155Supply is ERC1155 {\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /**\\n     * @dev Indicates whether any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return ERC1155Supply.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                _totalSupply[ids[i]] += amounts[i];\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                uint256 id = ids[i];\\n                uint256 amount = amounts[i];\\n                uint256 supply = _totalSupply[id];\\n                require(supply >= amount, \\\"ERC1155: burn amount exceeds totalSupply\\\");\\n                unchecked {\\n                    _totalSupply[id] = supply - amount;\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe3deb5f3b0c9d12944f62ab680f041bbf1910d9d3ac6b545b4b8e399643c538d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x5f3461639fe20794cfb4db4a6d8477388a15b2e70a018043084b7c4bedfa8136\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/DoubleEndedQueue.sol)\\npragma solidity ^0.8.4;\\n\\nimport \\\"../math/SafeCast.sol\\\";\\n\\n/**\\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\\n * the existing queue contents are left in storage.\\n *\\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\\n * used in storage, and not in memory.\\n * ```solidity\\n * DoubleEndedQueue.Bytes32Deque queue;\\n * ```\\n *\\n * _Available since v4.6._\\n */\\nlibrary DoubleEndedQueue {\\n    /**\\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n     */\\n    error Empty();\\n\\n    /**\\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n     */\\n    error OutOfBounds();\\n\\n    /**\\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\\n     *\\n     * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n     * lead to unexpected behavior.\\n     *\\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\\n     * data[end - 1].\\n     */\\n    struct Bytes32Deque {\\n        int128 _begin;\\n        int128 _end;\\n        mapping(int128 => bytes32) _data;\\n    }\\n\\n    /**\\n     * @dev Inserts an item at the end of the queue.\\n     */\\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\\n        int128 backIndex = deque._end;\\n        deque._data[backIndex] = value;\\n        unchecked {\\n            deque._end = backIndex + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes the item at the end of the queue and returns it.\\n     *\\n     * Reverts with `Empty` if the queue is empty.\\n     */\\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\\n        if (empty(deque)) revert Empty();\\n        int128 backIndex;\\n        unchecked {\\n            backIndex = deque._end - 1;\\n        }\\n        value = deque._data[backIndex];\\n        delete deque._data[backIndex];\\n        deque._end = backIndex;\\n    }\\n\\n    /**\\n     * @dev Inserts an item at the beginning of the queue.\\n     */\\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\\n        int128 frontIndex;\\n        unchecked {\\n            frontIndex = deque._begin - 1;\\n        }\\n        deque._data[frontIndex] = value;\\n        deque._begin = frontIndex;\\n    }\\n\\n    /**\\n     * @dev Removes the item at the beginning of the queue and returns it.\\n     *\\n     * Reverts with `Empty` if the queue is empty.\\n     */\\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\\n        if (empty(deque)) revert Empty();\\n        int128 frontIndex = deque._begin;\\n        value = deque._data[frontIndex];\\n        delete deque._data[frontIndex];\\n        unchecked {\\n            deque._begin = frontIndex + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the item at the beginning of the queue.\\n     *\\n     * Reverts with `Empty` if the queue is empty.\\n     */\\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\\n        if (empty(deque)) revert Empty();\\n        int128 frontIndex = deque._begin;\\n        return deque._data[frontIndex];\\n    }\\n\\n    /**\\n     * @dev Returns the item at the end of the queue.\\n     *\\n     * Reverts with `Empty` if the queue is empty.\\n     */\\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\\n        if (empty(deque)) revert Empty();\\n        int128 backIndex;\\n        unchecked {\\n            backIndex = deque._end - 1;\\n        }\\n        return deque._data[backIndex];\\n    }\\n\\n    /**\\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n     * `length(deque) - 1`.\\n     *\\n     * Reverts with `OutOfBounds` if the index is out of bounds.\\n     */\\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\\n        // int256(deque._begin) is a safe upcast\\n        int128 idx = SafeCast.toInt128(int256(deque._begin) + SafeCast.toInt256(index));\\n        if (idx >= deque._end) revert OutOfBounds();\\n        return deque._data[idx];\\n    }\\n\\n    /**\\n     * @dev Resets the queue back to being empty.\\n     *\\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\\n     * out on potential gas refunds.\\n     */\\n    function clear(Bytes32Deque storage deque) internal {\\n        deque._begin = 0;\\n        deque._end = 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of items in the queue.\\n     */\\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\\n        // We also assume there are at most int256.max items in the queue.\\n        unchecked {\\n            return uint256(int256(deque._end) - int256(deque._begin));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the queue is empty.\\n     */\\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\\n        return deque._end <= deque._begin;\\n    }\\n}\\n\",\"keccak256\":\"0xb5fbb623dec53bb9b6c1b738b4ab6540a04ac5dc2ac94d95fa3ebfd22898559c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x9f4357008a8f7d8c8bf5d48902e789637538d8c016be5766610901b4bba81514\",\"license\":\"MIT\"},\"contracts/core/CLBToken.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Base64} from \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\nimport {IERC1155MetadataURI} from \\\"@openzeppelin/contracts/interfaces/IERC1155MetadataURI.sol\\\";\\nimport {ERC1155Supply, ERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {CLBTokenLib} from \\\"@chromatic-protocol/contracts/core/libraries/CLBTokenLib.sol\\\";\\nimport {IChromaticMarket} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarket.sol\\\";\\nimport {ICLBToken} from \\\"@chromatic-protocol/contracts/core/interfaces/ICLBToken.sol\\\";\\nimport {BPS} from \\\"@chromatic-protocol/contracts/core/libraries/Constants.sol\\\";\\n\\n/**\\n * @title CLBToken\\n * @dev CLBToken is an ERC1155 token contract that represents Liquidity Bin tokens.\\n *      CLBToken allows minting and burning of tokens by the Chromatic Market contract.\\n */\\ncontract CLBToken is ERC1155Supply, ICLBToken {\\n    using Strings for uint256;\\n    using Strings for uint128;\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n\\n    IChromaticMarket public immutable market;\\n\\n    /**\\n     * @dev Throws an error indicating that the caller is not a registered market.\\n     */\\n    error OnlyAccessableByMarket();\\n\\n    /**\\n     * @dev Modifier to restrict access to the Chromatic Market contract.\\n     *      Only the market contract is allowed to call functions with this modifier.\\n     *      Reverts with an error if the caller is not the market contract.\\n     */\\n    modifier onlyMarket() {\\n        if (address(market) != (msg.sender)) revert OnlyAccessableByMarket();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the CLBToken contract.\\n     *      The constructor sets the market contract address as the caller.\\n     */\\n    constructor() ERC1155(\\\"\\\") {\\n        market = IChromaticMarket(msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     */\\n    function decimals() public view override returns (uint8) {\\n        return market.settlementToken().decimals();\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     */\\n    function totalSupply(\\n        uint256 id\\n    ) public view virtual override(ERC1155Supply, ICLBToken) returns (uint256) {\\n        return super.totalSupply(id);\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     */\\n    function totalSupplyBatch(\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        uint256[] memory supplies = new uint256[](ids.length);\\n        for (uint256 i; i < ids.length; ) {\\n            supplies[i] = super.totalSupply(ids[i]);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return supplies;\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     * @dev This function can only be called by the Chromatic Market contract.\\n     */\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external override onlyMarket {\\n        _mint(to, id, amount, data);\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     * @dev This function can only be called by the Chromatic Market contract.\\n     */\\n    function burn(address from, uint256 id, uint256 amount) external override onlyMarket {\\n        _burn(from, id, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     */\\n    function name(uint256 id) public view override returns (string memory) {\\n        return string(abi.encodePacked(\\\"CLB - \\\", description(id)));\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     */\\n    function description(uint256 id) public view override returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    _tokenSymbol(),\\n                    \\\" - \\\",\\n                    _indexName(),\\n                    \\\" \\\",\\n                    _formattedFeeRate(decodeId(id))\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc ICLBToken\\n     */\\n    function image(uint256 id) public view override returns (string memory) {\\n        int16 tradingFeeRate = decodeId(id);\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:image/svg+xml;base64,\\\",\\n                    Base64.encode(_svg(tradingFeeRate, _tokenSymbol(), _indexName()))\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155MetadataURI\\n     */\\n    function uri(\\n        uint256 id\\n    ) public view override(ERC1155, IERC1155MetadataURI) returns (string memory) {\\n        bytes memory metadata = abi.encodePacked(\\n            '{\\\"name\\\": \\\"',\\n            name(id),\\n            '\\\", \\\"description\\\": \\\"',\\n            description(id),\\n            '\\\", \\\"decimals\\\": \\\"',\\n            uint256(decimals()).toString(),\\n            '\\\", \\\"image\\\":\\\"',\\n            image(id),\\n            '\\\"',\\n            \\\"}\\\"\\n        );\\n\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(metadata)));\\n    }\\n\\n    /**\\n     * @dev Encodes a trading fee rate into a token ID.\\n     * @param tradingFeeRate The trading fee rate to encode.\\n     * @return id The encoded token ID.\\n     */\\n    function encodeId(int16 tradingFeeRate) internal pure returns (uint256 id) {\\n        id = CLBTokenLib.encodeId(tradingFeeRate);\\n    }\\n\\n    /**\\n     * @dev Decodes a token ID into a trading fee rate.\\n     * @param id The token ID to decode.\\n     * @return tradingFeeRate The decoded trading fee rate.\\n     */\\n    function decodeId(uint256 id) internal pure returns (int16 tradingFeeRate) {\\n        tradingFeeRate = CLBTokenLib.decodeId(id);\\n    }\\n\\n    /**\\n     * @dev Retrieves the symbol of the settlement token.\\n     * @return The symbol of the settlement token.\\n     */\\n    function _tokenSymbol() private view returns (string memory) {\\n        return market.settlementToken().symbol();\\n    }\\n\\n    /**\\n     * @dev Retrieves the name of the index.\\n     * @return The name of the index.\\n     */\\n    function _indexName() private view returns (string memory) {\\n        return market.oracleProvider().description();\\n    }\\n\\n    /**\\n     * @dev Formats a fee rate into a human-readable string.\\n     * @param feeRate The fee rate to format.\\n     * @return The formatted fee rate as a bytes array.\\n     */\\n    function _formattedFeeRate(int16 feeRate) private pure returns (bytes memory) {\\n        uint256 absFeeRate = uint16(feeRate < 0 ? -(feeRate) : feeRate);\\n\\n        uint256 pct = BPS / 100;\\n        uint256 integerPart = absFeeRate / pct;\\n        uint256 fractionalPart = absFeeRate % pct;\\n\\n        bytes memory fraction;\\n        if (fractionalPart != 0) {\\n            uint256 fractionalPart1 = fractionalPart / (pct / 10);\\n            uint256 fractionalPart2 = fractionalPart % (pct / 10);\\n\\n            fraction = bytes(\\\".\\\");\\n            if (fractionalPart2 == 0) {\\n                fraction = abi.encodePacked(fraction, fractionalPart1.toString());\\n            } else {\\n                fraction = abi.encodePacked(\\n                    fraction,\\n                    fractionalPart1.toString(),\\n                    fractionalPart2.toString()\\n                );\\n            }\\n        }\\n\\n        return abi.encodePacked(feeRate < 0 ? \\\"-\\\" : \\\"+\\\", integerPart.toString(), fraction, \\\"%\\\");\\n    }\\n\\n    uint256 private constant _W = 480;\\n    uint256 private constant _H = 480;\\n    string private constant _WS = \\\"480\\\";\\n    string private constant _HS = \\\"480\\\";\\n    uint256 private constant _BARS = 9;\\n\\n    function _svg(\\n        int16 feeRate,\\n        string memory symbol,\\n        string memory index\\n    ) private pure returns (bytes memory) {\\n        bytes memory formattedFeeRate = _formattedFeeRate(feeRate);\\n        string memory color = _color(feeRate);\\n        bool long = feeRate > 0;\\n\\n        bytes memory text = abi.encodePacked(\\n            '<text class=\\\"st13 st14\\\" font-size=\\\"64\\\" transform=\\\"translate(440 216.852)\\\" text-anchor=\\\"end\\\">',\\n            formattedFeeRate,\\n            \\\"</text>\\\"\\n            '<text class=\\\"st13 st16\\\" font-size=\\\"28\\\" transform=\\\"translate(440 64.036)\\\" text-anchor=\\\"end\\\">',\\n            symbol,\\n            \\\"</text>\\\"\\n            '<path d=\\\"M104.38 40 80.74 51.59V40L63.91 52.17v47.66L80.74 112v-11.59L104.38 112zm-43.34 0L50.87 52.17v47.66L61.04 112zm-16.42 0L40 52.17v47.66L44.62 112z\\\" class=\\\"st13\\\" />'\\n            '<text class=\\\"st13 st14 st18\\\" transform=\\\"translate(440 109.356)\\\" text-anchor=\\\"end\\\">',\\n            index,\\n            \\\" Market</text>\\\"\\n            '<path fill=\\\"none\\\" stroke=\\\"#fff\\\" stroke-miterlimit=\\\"10\\\" d=\\\"M440 140H40\\\" opacity=\\\".5\\\" />'\\n            '<text class=\\\"st13 st14 st18\\\" transform=\\\"translate(40 438.578)\\\">CLB</text>'\\n            '<text class=\\\"st13 st16\\\" font-size=\\\"22\\\" transform=\\\"translate(107.664 438.578)\\\">Chromatic Liquidity Bin Token</text>'\\n            '<text class=\\\"st13 st16\\\" font-size=\\\"16\\\" transform=\\\"translate(54.907 390.284)\\\">ERC-1155</text>'\\n            '<path fill=\\\"none\\\" stroke=\\\"#fff\\\" stroke-miterlimit=\\\"10\\\" d=\\\"M132.27 399.77h-84c-4.42 0-8-3.58-8-8v-14c0-4.42 3.58-8 8-8h84c4.42 0 8 3.58 8 8v14c0 4.42-3.58 8-8 8z\\\" />'\\n        );\\n\\n        return\\n            abi.encodePacked(\\n                '<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>'\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xml:space=\\\"preserve\\\" x=\\\"0\\\" y=\\\"0\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 ',\\n                _WS,\\n                \\\" \\\",\\n                _HS,\\n                '\\\">'\\n                \\\"<style>\\\"\\n                \\\"  .st13 {\\\"\\n                \\\"    fill: #fff\\\"\\n                \\\"  }\\\"\\n                \\\"  .st14 {\\\"\\n                '    font-family: \\\"NotoSans-Bold\\\";'\\n                \\\"  }\\\"\\n                \\\"  .st16 {\\\"\\n                '    font-family: \\\"NotoSans-Regular\\\";'\\n                \\\"  }\\\"\\n                \\\"  .st18 {\\\"\\n                \\\"    font-size: 32px\\\"\\n                \\\"  }\\\"\\n                \\\"</style>\\\",\\n                _background(long),\\n                _bars(long, color, _activeBar(feeRate)),\\n                text,\\n                \\\"</svg>\\\"\\n            );\\n    }\\n\\n    function _background(bool long) private pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                '<linearGradient id=\\\"bg\\\" x1=\\\"',\\n                long ? \\\"0\\\" : _WS,\\n                '\\\" x2=\\\"',\\n                long ? _WS : \\\"0\\\",\\n                '\\\" y1=\\\"',\\n                _HS,\\n                '\\\" y2=\\\"0\\\" gradientUnits=\\\"userSpaceOnUse\\\">',\\n                long\\n                    ? '<stop offset=\\\"0\\\" />'\\n                    '<stop offset=\\\".3\\\" stop-color=\\\"#010302\\\" />'\\n                    '<stop offset=\\\".5\\\" stop-color=\\\"#040b07\\\" />'\\n                    '<stop offset=\\\".6\\\" stop-color=\\\"#0a1910\\\" />'\\n                    '<stop offset=\\\".7\\\" stop-color=\\\"#132e1d\\\" />'\\n                    '<stop offset=\\\".8\\\" stop-color=\\\"#1d482e\\\" />'\\n                    '<stop offset=\\\".9\\\" stop-color=\\\"#2b6843\\\" />'\\n                    '<stop offset=\\\"1\\\" stop-color=\\\"#358153\\\" />'\\n                    : '<stop offset=\\\"0\\\" style=\\\"stop-color:#000\\\" />'\\n                    '<stop offset=\\\".3\\\" style=\\\"stop-color:#030101\\\" />'\\n                    '<stop offset=\\\".4\\\" style=\\\"stop-color:#0b0605\\\" />'\\n                    '<stop offset=\\\".6\\\" style=\\\"stop-color:#190f0b\\\" />'\\n                    '<stop offset=\\\".7\\\" style=\\\"stop-color:#2e1a13\\\" />'\\n                    '<stop offset=\\\".8\\\" style=\\\"stop-color:#482a1f\\\" />'\\n                    '<stop offset=\\\".9\\\" style=\\\"stop-color:#683c2c\\\" />'\\n                    '<stop offset=\\\"1\\\" style=\\\"stop-color:#8e523c\\\" />',\\n                \\\"</linearGradient>\\\"\\n                '<path fill=\\\"url(#bg)\\\" d=\\\"M0 0h',\\n                _WS,\\n                \\\"v\\\",\\n                _HS,\\n                'H0z\\\" />'\\n            );\\n    }\\n\\n    function _activeBar(int16 feeRate) private pure returns (uint256) {\\n        uint256 absFeeRate = uint16(feeRate < 0 ? -(feeRate) : feeRate);\\n\\n        if (absFeeRate >= BPS / 10) {\\n            return (absFeeRate / (BPS / 10 / 2)) - 2;\\n        } else if (absFeeRate >= BPS / 100) {\\n            return (absFeeRate / (BPS / 100)) - 1;\\n        } else if (absFeeRate >= BPS / 1000) {\\n            return (absFeeRate / (BPS / 1000)) - 1;\\n        } else if (absFeeRate >= BPS / 10000) {\\n            return (absFeeRate / (BPS / 10000)) - 1;\\n        }\\n        return 0;\\n    }\\n\\n    function _bars(\\n        bool long,\\n        string memory color,\\n        uint256 activeBar\\n    ) private pure returns (bytes memory bars) {\\n        for (uint256 i; i < _BARS; ) {\\n            bars = abi.encodePacked(bars, _bar(i, long, color, i == activeBar));\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function _bar(\\n        uint256 barIndex,\\n        bool long,\\n        string memory color,\\n        bool active\\n    ) private pure returns (bytes memory) {\\n        (uint256 pos, uint256 width, uint256 height, uint256 hDelta) = _barAttributes(\\n            barIndex,\\n            long\\n        );\\n\\n        string memory gX = _gradientX(barIndex, long);\\n        string memory gY = (_H - height).toString();\\n\\n        bytes memory stop = abi.encodePacked(\\n            '<stop offset=\\\"0\\\" stop-color=\\\"',\\n            color,\\n            '\\\" stop-opacity=\\\"0\\\"/>'\\n            '<stop offset=\\\"1\\\" stop-color=\\\"',\\n            color,\\n            '\\\"/>'\\n        );\\n        bytes memory path = _path(barIndex, long, pos, width, height, hDelta);\\n        bytes memory bar = abi.encodePacked(\\n            '<linearGradient id=\\\"bar',\\n            barIndex.toString(),\\n            '\\\" x1=\\\"',\\n            gX,\\n            '\\\" x2=\\\"',\\n            gX,\\n            '\\\" y1=\\\"',\\n            gY,\\n            '\\\" y2=\\\"',\\n            _HS,\\n            '\\\" gradientUnits=\\\"userSpaceOnUse\\\">',\\n            stop,\\n            \\\"</linearGradient>\\\",\\n            path\\n        );\\n\\n        if (active) {\\n            bytes memory edge = _edge(long, pos, width, height);\\n            return abi.encodePacked(bar, bar, bar, edge);\\n        }\\n        return bar;\\n    }\\n\\n    function _edge(\\n        bool long,\\n        uint256 pos,\\n        uint256 width,\\n        uint256 height\\n    ) private pure returns (bytes memory) {\\n        string memory _epos = (long ? pos + width : pos - width).toString();\\n\\n        bytes memory path = abi.encodePacked(\\n            '<path fill=\\\"url(#edge)\\\" d=\\\"M',\\n            _epos,\\n            \\\" \\\",\\n            _HS,\\n            \\\"h\\\",\\n            long ? \\\"-\\\" : \\\"\\\",\\n            \\\"2v-\\\",\\n            height.toString(),\\n            \\\"H\\\",\\n            _epos,\\n            'z\\\"/>'\\n        );\\n        return\\n            abi.encodePacked(\\n                '<linearGradient id=\\\"edge\\\" x1=\\\"',\\n                _epos,\\n                '\\\" x2=\\\"',\\n                _epos,\\n                '\\\" y1=\\\"',\\n                _HS,\\n                '\\\" y2=\\\"',\\n                (_H - height).toString(),\\n                '\\\" gradientUnits=\\\"userSpaceOnUse\\\">'\\n                '<stop offset=\\\"0\\\" stop-color=\\\"#fff\\\" stop-opacity=\\\"0\\\"/>'\\n                '<stop offset=\\\".5\\\" stop-color=\\\"#fff\\\" stop-opacity=\\\".5\\\"/>'\\n                '<stop offset=\\\"1\\\" stop-color=\\\"#fff\\\" stop-opacity=\\\"0\\\"/>'\\n                \\\"</linearGradient>\\\",\\n                path\\n            );\\n    }\\n\\n    function _path(\\n        uint256 barIndex,\\n        bool long,\\n        uint256 pos,\\n        uint256 width,\\n        uint256 height,\\n        uint256 hDelta\\n    ) private pure returns (bytes memory) {\\n        string memory _w = width.toString();\\n        bytes memory _h = abi.encodePacked(\\\"h\\\", long ? \\\"\\\" : \\\"-\\\", _w);\\n        bytes memory _l = abi.encodePacked(\\\"l\\\", long ? \\\"-\\\" : \\\"\\\", _w, \\\" \\\", hDelta.toString());\\n        return\\n            abi.encodePacked(\\n                '<path fill=\\\"url(#bar',\\n                barIndex.toString(),\\n                ')\\\" d=\\\"M',\\n                pos.toString(),\\n                \\\" \\\",\\n                _HS,\\n                _h,\\n                \\\"v-\\\",\\n                height.toString(),\\n                _l,\\n                'z\\\"/>'\\n            );\\n    }\\n\\n    function _barAttributes(\\n        uint256 barIndex,\\n        bool long\\n    ) private pure returns (uint256 pos, uint256 width, uint256 height, uint256 hDelta) {\\n        uint256[_BARS] memory widths = [uint256(44), 45, 48, 51, 53, 55, 58, 62, 64];\\n        uint256[_BARS] memory heights = [uint256(480), 415, 309, 240, 185, 144, 111, 86, 67];\\n        uint256[_BARS] memory hDeltas = [uint256(33), 27, 19, 14, 10, 8, 5, 4, 3];\\n\\n        width = widths[barIndex];\\n        height = heights[barIndex];\\n        hDelta = hDeltas[barIndex];\\n        pos = long ? 0 : _W;\\n        for (uint256 i; i < barIndex; ) {\\n            pos = long ? pos + widths[i] : pos - widths[i];\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function _gradientX(uint256 barIndex, bool long) private pure returns (string memory) {\\n        string[_BARS] memory longXs = [\\n            \\\"-1778\\\",\\n            \\\"-1733.4\\\",\\n            \\\"-1686.6\\\",\\n            \\\"-1637.4\\\",\\n            \\\"-1585.7\\\",\\n            \\\"-1531.5\\\",\\n            \\\"-1474.6\\\",\\n            \\\"-1414.8\\\",\\n            \\\"-1352\\\"\\n        ];\\n        string[_BARS] memory shortXs = [\\n            \\\"-12373.4\\\",\\n            \\\"-12328.8\\\",\\n            \\\"-12281.9\\\",\\n            \\\"-12232.8\\\",\\n            \\\"-12181.1\\\",\\n            \\\"-12126.9\\\",\\n            \\\"-12069.9\\\",\\n            \\\"-12010.1\\\",\\n            \\\"-11947.3\\\"\\n        ];\\n\\n        return long ? longXs[barIndex] : shortXs[barIndex];\\n    }\\n\\n    function _color(int16 feeRate) private pure returns (string memory) {\\n        bool long = feeRate > 0;\\n        uint256 absFeeRate = uint16(feeRate < 0 ? -(feeRate) : feeRate);\\n\\n        if (absFeeRate >= BPS / 10) {\\n            // feeRate >= 10%  or feeRate <= -10%\\n            return long ? \\\"#FFCE94\\\" : \\\"#A0DC50\\\";\\n        } else if (absFeeRate >= BPS / 100) {\\n            // 10% > feeRate >= 1% or -1% >= feeRate > -10%\\n            return long ? \\\"#FFAB5E\\\" : \\\"#82E664\\\";\\n        } else if (absFeeRate >= BPS / 1000) {\\n            // 1% > feeRate >= 0.1% or -0.1% >= feeRate > -1%\\n            return long ? \\\"#FF966E\\\" : \\\"#5ADC8C\\\";\\n        } else if (absFeeRate >= BPS / 10000) {\\n            // 0.1% > feeRate >= 0.01% or -0.01% >= feeRate > -0.1%\\n            return long ? \\\"#FE8264\\\" : \\\"#3CD2AA\\\";\\n        }\\n        // feeRate == 0%\\n        return \\\"#000000\\\";\\n    }\\n}\\n\",\"keccak256\":\"0xd5e2220ca0b9e0a892120aedc94f3ad4127f2e209ddd45eac730a4ec7797eb70\",\"license\":\"BUSL-1.1\"},\"contracts/core/ChromaticMarket.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport {IChromaticMarketFactory} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarketFactory.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {ICLBToken} from \\\"@chromatic-protocol/contracts/core/interfaces/ICLBToken.sol\\\";\\nimport {IChromaticLiquidator} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticLiquidator.sol\\\";\\nimport {IChromaticVault} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticVault.sol\\\";\\nimport {IKeeperFeePayer} from \\\"@chromatic-protocol/contracts/core/interfaces/IKeeperFeePayer.sol\\\";\\nimport {CLBTokenDeployerLib} from \\\"@chromatic-protocol/contracts/core/libraries/deployer/CLBTokenDeployer.sol\\\";\\nimport {MarketStorage, MarketStorageLib} from \\\"@chromatic-protocol/contracts/core/libraries/MarketStorage.sol\\\";\\nimport {Diamond} from \\\"@chromatic-protocol/contracts/core/base/Diamond.sol\\\";\\n\\n/**\\n * @title ChromaticMarket\\n * @dev A contract that represents a Chromatic market, combining trade and liquidity functionalities.\\n */\\ncontract ChromaticMarket is Diamond {\\n    constructor(address diamondCutFacet) Diamond(diamondCutFacet) {\\n        IChromaticMarketFactory factory = IChromaticMarketFactory(msg.sender);\\n\\n        (address _oracleProvider, address _settlementToken) = factory.parameters();\\n        MarketStorage storage ms = MarketStorageLib.marketStorage();\\n\\n        ms.factory = factory;\\n        ms.oracleProvider = IOracleProvider(_oracleProvider);\\n        ms.settlementToken = IERC20Metadata(_settlementToken);\\n        ms.clbToken = ICLBToken(CLBTokenDeployerLib.deploy());\\n        ms.liquidator = IChromaticLiquidator(factory.liquidator());\\n        ms.vault = IChromaticVault(factory.vault());\\n        ms.keeperFeePayer = IKeeperFeePayer(factory.keeperFeePayer());\\n\\n        ms.liquidityPool.initialize();\\n    }\\n}\\n\",\"keccak256\":\"0x167d48439bdf1bf94bc261864e3ead6d35bbe8a8b2328adad85adcd0ff935314\",\"license\":\"BUSL-1.1\"},\"contracts/core/ChromaticMarketFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IChromaticMarketFactory} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarketFactory.sol\\\";\\nimport {IInterestCalculator} from \\\"@chromatic-protocol/contracts/core/interfaces/IInterestCalculator.sol\\\";\\nimport {IChromaticVault} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticVault.sol\\\";\\nimport {IKeeperFeePayer} from \\\"@chromatic-protocol/contracts/core/interfaces/IKeeperFeePayer.sol\\\";\\nimport {IMarketDeployer} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/IMarketDeployer.sol\\\";\\nimport {IOracleProviderRegistry} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/IOracleProviderRegistry.sol\\\";\\nimport {ISettlementTokenRegistry} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/ISettlementTokenRegistry.sol\\\";\\nimport {IMarketState} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketState.sol\\\";\\nimport {OracleProviderRegistry, OracleProviderRegistryLib} from \\\"@chromatic-protocol/contracts/core/libraries/registry/OracleProviderRegistry.sol\\\";\\nimport {SettlementTokenRegistry, SettlementTokenRegistryLib} from \\\"@chromatic-protocol/contracts/core/libraries/registry/SettlementTokenRegistry.sol\\\";\\nimport {InterestRate} from \\\"@chromatic-protocol/contracts/core/libraries/InterestRate.sol\\\";\\nimport {MarketDeployer, MarketDeployerLib, Parameters} from \\\"@chromatic-protocol/contracts/core/libraries/deployer/MarketDeployer.sol\\\";\\n\\n/**\\n * @title ChromaticMarketFactory\\n * @dev Contract for managing the creation and registration of Chromatic markets.\\n */\\ncontract ChromaticMarketFactory is IChromaticMarketFactory {\\n    using OracleProviderRegistryLib for OracleProviderRegistry;\\n    using SettlementTokenRegistryLib for SettlementTokenRegistry;\\n    using MarketDeployerLib for MarketDeployer;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    address public override dao;\\n\\n    address public override liquidator;\\n    address public override vault;\\n    address public override keeperFeePayer;\\n    address public override treasury;\\n\\n    address private marketDiamondCutFacet;\\n    address private marketLoupeFacet;\\n    address private marketStateFacet;\\n    address private marketLiquidityFacet;\\n    address private marketTradeFacet;\\n    address private marketLiquidateFacet;\\n    address private marketSettleFacet;\\n\\n    OracleProviderRegistry private _oracleProviderRegistry;\\n    SettlementTokenRegistry private _settlementTokenRegistry;\\n\\n    MarketDeployer private _deployer;\\n    mapping(address => mapping(address => bool)) private _registered;\\n    mapping(address => address[]) private _marketsBySettlementToken;\\n    EnumerableSet.AddressSet private _markets;\\n\\n    /**\\n     * @dev Throws an error indicating that the caller is not the DAO.\\n     */\\n    error OnlyAccessableByDao();\\n\\n    /**\\n     * @dev Throws an error indicating that the chromatic liquidator address is already set.\\n     */\\n    error AlreadySetLiquidator();\\n\\n    /**\\n     * @dev Throws an error indicating that the chromatic vault address is already set.\\n     */\\n    error AlreadySetVault();\\n\\n    /**\\n     * @dev Throws an error indicating that the keeper fee payer address is already set.\\n     */\\n    error AlreadySetKeeperFeePayer();\\n\\n    /**\\n     * @dev Throws an error indicating that the oracle provider is not registered.\\n     */\\n    error NotRegisteredOracleProvider();\\n\\n    /**\\n     * @dev Throws an error indicating that the settlement token is not registered.\\n     */\\n    error NotRegisteredSettlementToken();\\n\\n    /**\\n     * @dev Throws an error indicating that a market already exists for the given oracle provider and settlement token.\\n     */\\n    error ExistMarket();\\n\\n    /**\\n     * @dev Modifier to restrict access to only the DAO address\\n     *      Throws an `OnlyAccessableByDao` error if the caller is not the DAO.\\n     */\\n    modifier onlyDao() {\\n        if (msg.sender != dao) revert OnlyAccessableByDao();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to ensure that the specified oracle provider is registered.\\n     *      Throws a `NotRegisteredOracleProvider` error if the oracle provider is not registered.\\n     *\\n     * @param oracleProvider The address of the oracle provider to check.\\n     *\\n     * Requirements:\\n     * - The `oracleProvider` address must be registered in the `_oracleProviderRegistry`.\\n     */\\n    modifier onlyRegisteredOracleProvider(address oracleProvider) {\\n        if (!_oracleProviderRegistry.isRegistered(oracleProvider))\\n            revert NotRegisteredOracleProvider();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the ChromaticMarketFactory contract.\\n     * @param _marketDiamondCutFacet The market diamond cut facet address.\\n     * @param _marketLoupeFacet The market loupe facet address.\\n     * @param _marketStateFacet The market state facet address.\\n     * @param _marketLiquidityFacet The market liquidity facet address.\\n     * @param _marketTradeFacet The market trade facet address.\\n     * @param _marketLiquidateFacet The market liquidate facet address.\\n     * @param _marketSettleFacet The market settle facet address.\\n     */\\n    constructor(\\n        address _marketDiamondCutFacet,\\n        address _marketLoupeFacet,\\n        address _marketStateFacet,\\n        address _marketLiquidityFacet,\\n        address _marketTradeFacet,\\n        address _marketLiquidateFacet,\\n        address _marketSettleFacet\\n    ) {\\n        dao = msg.sender;\\n        treasury = dao;\\n\\n        marketDiamondCutFacet = _marketDiamondCutFacet;\\n        marketLoupeFacet = _marketLoupeFacet;\\n        marketStateFacet = _marketStateFacet;\\n        marketLiquidityFacet = _marketLiquidityFacet;\\n        marketTradeFacet = _marketTradeFacet;\\n        marketLiquidateFacet = _marketLiquidateFacet;\\n        marketSettleFacet = _marketSettleFacet;\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function updateDao(address _dao) external override onlyDao {\\n        dao = _dao;\\n        emit UpdateDao(dao);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function updateTreasury(address _treasury) external override onlyDao {\\n        treasury = _treasury;\\n        emit UpdateTreasury(treasury);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     * @dev This function can only be called by the DAO address.\\n     *      Throws an `AlreadySetLiquidator` error if the liquidator address has already been set.\\n     */\\n    function setLiquidator(address _liquidator) external override onlyDao {\\n        if (liquidator != address(0)) revert AlreadySetLiquidator();\\n\\n        liquidator = _liquidator;\\n        emit SetLiquidator(liquidator);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     * @dev This function can only be called by the DAO address.\\n     *      Throws an `AlreadySetVault` error if the vault address has already been set.\\n     */\\n    function setVault(address _vault) external override onlyDao {\\n        if (vault != address(0)) revert AlreadySetVault();\\n\\n        vault = _vault;\\n        emit SetVault(vault);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     * @dev This function can only be called by the DAO address.\\n     *      Throws an `AlreadySetKeeperFeePayer` error if the keeper fee payer address has already been set.\\n     */\\n    function setKeeperFeePayer(address _keeperFeePayer) external override onlyDao {\\n        if (keeperFeePayer != address(0)) revert AlreadySetKeeperFeePayer();\\n\\n        keeperFeePayer = _keeperFeePayer;\\n        emit SetKeeperFeePayer(keeperFeePayer);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     */\\n    function getMarkets() external view override returns (address[] memory) {\\n        return _markets.values();\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     */\\n    function getMarketsBySettlmentToken(\\n        address settlementToken\\n    ) external view override returns (address[] memory) {\\n        return _marketsBySettlementToken[settlementToken];\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     */\\n    function getMarket(\\n        address oracleProvider,\\n        address settlementToken\\n    ) external view override returns (address) {\\n        if (!_registered[oracleProvider][settlementToken]) return address(0);\\n\\n        address[] memory markets = _marketsBySettlementToken[settlementToken];\\n        for (uint i; i < markets.length; ) {\\n            if (address(IMarketState(markets[i]).oracleProvider()) == oracleProvider) {\\n                return markets[i];\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return address(0);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     */\\n    function isRegisteredMarket(address market) external view override returns (bool) {\\n        return _markets.contains(market);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticMarketFactory\\n     * @dev This function creates a new market using the specified oracle provider and settlement token addresses.\\n     *      Throws a `NotRegisteredSettlementToken` error if the settlement token is not registered.\\n     *      Throws an `ExistMarket` error if the market already exists for the given oracle provider and settlement token.\\n     */\\n    function createMarket(\\n        address oracleProvider,\\n        address settlementToken\\n    ) external override onlyRegisteredOracleProvider(oracleProvider) {\\n        if (!_settlementTokenRegistry.isRegistered(settlementToken))\\n            revert NotRegisteredSettlementToken();\\n\\n        if (_registered[oracleProvider][settlementToken]) revert ExistMarket();\\n\\n        address market = _deployer.deploy(\\n            oracleProvider,\\n            settlementToken,\\n            marketDiamondCutFacet,\\n            marketLoupeFacet,\\n            marketStateFacet,\\n            marketLiquidityFacet,\\n            marketTradeFacet,\\n            marketLiquidateFacet,\\n            marketSettleFacet\\n        );\\n\\n        _registered[oracleProvider][settlementToken] = true;\\n        _marketsBySettlementToken[settlementToken].push(market);\\n        _markets.add(market);\\n\\n        IChromaticVault(vault).createMarketEarningDistributionTask(market);\\n\\n        emit MarketCreated(oracleProvider, settlementToken, market);\\n    }\\n\\n    /**\\n     * @inheritdoc IMarketDeployer\\n     */\\n    function parameters()\\n        external\\n        view\\n        override\\n        returns (address oracleProvider, address settlementToken)\\n    {\\n        Parameters memory params = _deployer.parameters;\\n        return (params.oracleProvider, params.settlementToken);\\n    }\\n\\n    // implement IOracleProviderRegistry\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function registerOracleProvider(\\n        address oracleProvider,\\n        OracleProviderProperties memory properties\\n    ) external override onlyDao {\\n        _oracleProviderRegistry.register(\\n            oracleProvider,\\n            properties.minTakeProfitBPS,\\n            properties.maxTakeProfitBPS,\\n            properties.leverageLevel\\n        );\\n        emit OracleProviderRegistered(oracleProvider, properties);\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function unregisterOracleProvider(address oracleProvider) external override onlyDao {\\n        _oracleProviderRegistry.unregister(oracleProvider);\\n        emit OracleProviderUnregistered(oracleProvider);\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     */\\n    function registeredOracleProviders() external view override returns (address[] memory) {\\n        return _oracleProviderRegistry.oracleProviders();\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     */\\n    function isRegisteredOracleProvider(\\n        address oracleProvider\\n    ) external view override returns (bool) {\\n        return _oracleProviderRegistry.isRegistered(oracleProvider);\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     */\\n    function getOracleProviderProperties(\\n        address oracleProvider\\n    )\\n        external\\n        view\\n        override\\n        onlyRegisteredOracleProvider(oracleProvider)\\n        returns (OracleProviderProperties memory)\\n    {\\n        (\\n            uint32 minTakeProfitBPS,\\n            uint32 maxTakeProfitBPS,\\n            uint8 leverageLevel\\n        ) = _oracleProviderRegistry.getOracleProviderProperties(oracleProvider);\\n\\n        return\\n            OracleProviderProperties({\\n                minTakeProfitBPS: minTakeProfitBPS,\\n                maxTakeProfitBPS: maxTakeProfitBPS,\\n                leverageLevel: leverageLevel\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     * @dev This function can only be called by the DAO and registered oracle providers.\\n     */\\n    function updateTakeProfitBPSRange(\\n        address oracleProvider,\\n        uint32 minTakeProfitBPS,\\n        uint32 maxTakeProfitBPS\\n    ) external override onlyDao onlyRegisteredOracleProvider(oracleProvider) {\\n        _oracleProviderRegistry.setTakeProfitBPSRange(\\n            oracleProvider,\\n            minTakeProfitBPS,\\n            maxTakeProfitBPS\\n        );\\n        emit UpdateTakeProfitBPSRange(oracleProvider, minTakeProfitBPS, maxTakeProfitBPS);\\n    }\\n\\n    /**\\n     * @inheritdoc IOracleProviderRegistry\\n     * @dev This function can only be called by the DAO and registered oracle providers.\\n     */\\n    function updateLeverageLevel(\\n        address oracleProvider,\\n        uint8 level\\n    ) external override onlyDao onlyRegisteredOracleProvider(oracleProvider) {\\n        require(level <= 1);\\n        _oracleProviderRegistry.setLeverageLevel(oracleProvider, level);\\n        emit UpdateLeverageLevel(oracleProvider, level);\\n    }\\n\\n    // implement ISettlementTokenRegistry\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function registerSettlementToken(\\n        address token,\\n        uint256 minimumMargin,\\n        uint256 interestRate,\\n        uint256 flashLoanFeeRate,\\n        uint256 earningDistributionThreshold,\\n        uint24 uniswapFeeTier\\n    ) external override onlyDao {\\n        _settlementTokenRegistry.register(\\n            token,\\n            minimumMargin,\\n            interestRate,\\n            flashLoanFeeRate,\\n            earningDistributionThreshold,\\n            uniswapFeeTier\\n        );\\n\\n        IKeeperFeePayer(keeperFeePayer).approveToRouter(token, true);\\n        IChromaticVault(vault).createMakerEarningDistributionTask(token);\\n\\n        emit SettlementTokenRegistered(\\n            token,\\n            minimumMargin,\\n            interestRate,\\n            flashLoanFeeRate,\\n            earningDistributionThreshold,\\n            uniswapFeeTier\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function registeredSettlementTokens() external view override returns (address[] memory) {\\n        return _settlementTokenRegistry.settlementTokens();\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function isRegisteredSettlementToken(address token) external view override returns (bool) {\\n        return _settlementTokenRegistry.isRegistered(token);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function getMinimumMargin(address token) external view returns (uint256) {\\n        return _settlementTokenRegistry.getMinimumMargin(token);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function setMinimumMargin(address token, uint256 minimumMargin) external onlyDao {\\n        _settlementTokenRegistry.setMinimumMargin(token, minimumMargin);\\n        emit SetMinimumMargin(token, minimumMargin);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function getFlashLoanFeeRate(address token) external view returns (uint256) {\\n        return _settlementTokenRegistry.getFlashLoanFeeRate(token);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function setFlashLoanFeeRate(address token, uint256 flashLoanFeeRate) external onlyDao {\\n        _settlementTokenRegistry.setFlashLoanFeeRate(token, flashLoanFeeRate);\\n        emit SetFlashLoanFeeRate(token, flashLoanFeeRate);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function getEarningDistributionThreshold(address token) external view returns (uint256) {\\n        return _settlementTokenRegistry.getEarningDistributionThreshold(token);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function setEarningDistributionThreshold(\\n        address token,\\n        uint256 earningDistributionThreshold\\n    ) external onlyDao {\\n        _settlementTokenRegistry.setEarningDistributionThreshold(\\n            token,\\n            earningDistributionThreshold\\n        );\\n        emit SetEarningDistributionThreshold(token, earningDistributionThreshold);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function getUniswapFeeTier(address token) external view returns (uint24) {\\n        return _settlementTokenRegistry.getUniswapFeeTier(token);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function setUniswapFeeTier(address token, uint24 uniswapFeeTier) external onlyDao {\\n        _settlementTokenRegistry.setUniswapFeeTier(token, uniswapFeeTier);\\n        emit SetUniswapFeeTier(token, uniswapFeeTier);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function appendInterestRateRecord(\\n        address token,\\n        uint256 annualRateBPS,\\n        uint256 beginTimestamp\\n    ) external override onlyDao {\\n        _settlementTokenRegistry.appendInterestRateRecord(token, annualRateBPS, beginTimestamp);\\n        emit InterestRateRecordAppended(token, annualRateBPS, beginTimestamp);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     * @dev This function can only be called by the DAO address.\\n     */\\n    function removeLastInterestRateRecord(address token) external override onlyDao {\\n        (bool removed, InterestRate.Record memory record) = _settlementTokenRegistry\\n            .removeLastInterestRateRecord(token);\\n\\n        if (removed) {\\n            emit LastInterestRateRecordRemoved(token, record.annualRateBPS, record.beginTimestamp);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function getInterestRateRecords(\\n        address token\\n    ) external view returns (InterestRate.Record[] memory) {\\n        return _settlementTokenRegistry.getInterestRateRecords(token);\\n    }\\n\\n    /**\\n     * @inheritdoc ISettlementTokenRegistry\\n     */\\n    function currentInterestRate(\\n        address token\\n    ) external view override returns (uint256 annualRateBPS) {\\n        return _settlementTokenRegistry.currentInterestRate(token);\\n    }\\n\\n    // implement IInterestCalculator\\n\\n    /**\\n     * @inheritdoc IInterestCalculator\\n     */\\n    function calculateInterest(\\n        address token,\\n        uint256 amount,\\n        uint256 from, // timestamp (inclusive)\\n        uint256 to // timestamp (exclusive)\\n    ) external view override returns (uint256) {\\n        return _settlementTokenRegistry.calculateInterest(token, amount, from, to);\\n    }\\n}\\n\",\"keccak256\":\"0x35799d8f2ba99521109b959d5c0527c702a754fa0dee5c14bc04b14c4410aa5d\",\"license\":\"BUSL-1.1\"},\"contracts/core/base/Diamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/******************************************************************************\\\\\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {IDiamondCut} from \\\"@chromatic-protocol/contracts/core/interfaces/IDiamondCut.sol\\\";\\nimport {DiamondStorage, DiamondStorageLib} from \\\"@chromatic-protocol/contracts/core/libraries/DiamondStorage.sol\\\";\\n\\nabstract contract Diamond {\\n    constructor(address _diamondCutFacet) payable {\\n        // Add the diamondCut external function from the diamondCutFacet\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondCutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        DiamondStorageLib.diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        DiamondStorage storage ds;\\n        bytes32 position = DiamondStorageLib.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x2b35e250b22cbaa2c57ad5171527d2b3ca2ef354d3b8d2d198b26f08f724ad90\",\"license\":\"MIT\"},\"contracts/core/interfaces/ICLBToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/interfaces/IERC1155.sol\\\";\\nimport {IERC1155MetadataURI} from \\\"@openzeppelin/contracts/interfaces/IERC1155MetadataURI.sol\\\";\\n\\n/**\\n * @title ICLBToken\\n * @dev Interface for CLBToken contract, which represents Liquidity Bin tokens.\\n */\\ninterface ICLBToken is IERC1155, IERC1155MetadataURI {\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     * @param id The token ID for which to retrieve the total supply.\\n     * @return The total supply of tokens for the given token ID.\\n     */\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev Total amounts of tokens in with the given ids.\\n     * @param ids The token IDs for which to retrieve the total supply.\\n     * @return The total supples of tokens for the given token IDs.\\n     */\\n    function totalSupplyBatch(uint256[] memory ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Mints new tokens and assigns them to the specified address.\\n     * @param to The address to which the minted tokens will be assigned.\\n     * @param id The token ID to mint.\\n     * @param amount The amount of tokens to mint.\\n     * @param data Additional data to pass during the minting process.\\n     */\\n    function mint(address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Burns tokens from a specified address.\\n     * @param from The address from which to burn tokens.\\n     * @param id The token ID to burn.\\n     * @param amount The amount of tokens to burn.\\n     */\\n    function burn(address from, uint256 id, uint256 amount) external;\\n\\n    /**\\n     * @dev Retrieves the number of decimals used for token amounts.\\n     * @return The number of decimals used for token amounts.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Retrieves the name of a token.\\n     * @param id The token ID for which to retrieve the name.\\n     * @return The name of the token.\\n     */\\n    function name(uint256 id) external view returns (string memory);\\n\\n    /**\\n     * @dev Retrieves the description of a token.\\n     * @param id The token ID for which to retrieve the description.\\n     * @return The description of the token.\\n     */\\n    function description(uint256 id) external view returns (string memory);\\n\\n    /**\\n     * @dev Retrieves the image URI of a token.\\n     * @param id The token ID for which to retrieve the image URI.\\n     * @return The image URI of the token.\\n     */\\n    function image(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x104e532ccc23403fdf1b340c292d208c3837f9abd29eda787eec5b6ac1438488\",\"license\":\"MIT\"},\"contracts/core/interfaces/IChromaticLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IChromaticLiquidator\\n * @dev Interface for the Chromatic Liquidator contract.\\n */\\ninterface IChromaticLiquidator {\\n    /**\\n     * @notice Emitted when the liquidation task interval is updated.\\n     * @param interval The new liquidation task interval.\\n     */\\n    event UpdateLiquidationInterval(uint256 indexed interval);\\n\\n    /**\\n     * @notice Emitted when the claim task interval is updated.\\n     * @param interval The new claim task interval.\\n     */\\n    event UpdateClaimInterval(uint256 indexed interval);\\n\\n    /**\\n     * @notice Updates the liquidation task interval.\\n     * @param interval The new liquidation task interval.\\n     */\\n    function updateLiquidationInterval(uint256 interval) external;\\n\\n    /**\\n     * @notice Updates the claim task interval.\\n     * @param interval The new claim task interval.\\n     */\\n    function updateClaimInterval(uint256 interval) external;\\n\\n    /**\\n     * @notice Creates a liquidation task for a given position.\\n     * @param positionId The ID of the position to be liquidated.\\n     */\\n    function createLiquidationTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Cancels a liquidation task for a given position.\\n     * @param positionId The ID of the position for which to cancel the liquidation task.\\n     */\\n    function cancelLiquidationTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Resolves the liquidation of a position.\\n     * @dev This function is called by the Gelato automation system.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be liquidated.\\n     * @return canExec Whether the liquidation can be executed.\\n     * @return execPayload The encoded function call to execute the liquidation.\\n     */\\n    function resolveLiquidation(\\n        address market,\\n        uint256 positionId\\n    ) external view returns (bool canExec, bytes memory execPayload);\\n\\n    /**\\n     * @notice Liquidates a position in a market.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be liquidated.\\n     */\\n    function liquidate(address market, uint256 positionId) external;\\n\\n    /**\\n     * @notice Creates a claim position task for a given position.\\n     * @param positionId The ID of the position to be claimed.\\n     */\\n    function createClaimPositionTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Cancels a claim position task for a given position.\\n     * @param positionId The ID of the position for which to cancel the claim position task.\\n     */\\n    function cancelClaimPositionTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Resolves the claim of a position.\\n     * @dev This function is called by the Gelato automation system.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be claimed.\\n     * @return canExec Whether the claim can be executed.\\n     * @return execPayload The encoded function call to execute the claim.\\n     */\\n    function resolveClaimPosition(\\n        address market,\\n        uint256 positionId\\n    ) external view returns (bool canExec, bytes memory execPayload);\\n\\n    /**\\n     * @notice Claims a position in a market.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be claimed.\\n     */\\n    function claimPosition(address market, uint256 positionId) external;\\n}\\n\",\"keccak256\":\"0xb7f91172d5cb87f1f68fc790b8ce9e8f89f46d30c5a2fc024484680abe709008\",\"license\":\"MIT\"},\"contracts/core/interfaces/IChromaticMarket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IMarketTrade} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketTrade.sol\\\";\\nimport {IMarketLiquidity} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidity.sol\\\";\\nimport {IMarketState} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketState.sol\\\";\\nimport {IMarketLiquidate} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidate.sol\\\";\\nimport {IMarketSettle} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketSettle.sol\\\";\\n\\n/**\\n * @title IChromaticMarket\\n * @dev Interface for the Chromatic Market contract, which combines trade and liquidity functionalities.\\n */\\ninterface IChromaticMarket is\\n    IMarketTrade,\\n    IMarketLiquidity,\\n    IMarketState,\\n    IMarketLiquidate,\\n    IMarketSettle\\n{\\n\\n}\\n\",\"keccak256\":\"0x563dc93019c1e49de9a8fdeb33330493c26ead090dfcaa8fdf66e43bdeadcfa5\",\"license\":\"MIT\"},\"contracts/core/interfaces/IChromaticMarketFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IInterestCalculator} from \\\"@chromatic-protocol/contracts/core/interfaces/IInterestCalculator.sol\\\";\\nimport {IMarketDeployer} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/IMarketDeployer.sol\\\";\\nimport {ISettlementTokenRegistry} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/ISettlementTokenRegistry.sol\\\";\\nimport {IOracleProviderRegistry} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/IOracleProviderRegistry.sol\\\";\\n\\n/**\\n * @title IChromaticMarketFactory\\n * @dev Interface for the Chromatic Market Factory contract.\\n */\\ninterface IChromaticMarketFactory is\\n    IMarketDeployer,\\n    IOracleProviderRegistry,\\n    ISettlementTokenRegistry,\\n    IInterestCalculator\\n{\\n    /**\\n     * @notice Emitted when the DAO address is updated.\\n     * @param dao The new DAO address.\\n     */\\n    event UpdateDao(address indexed dao);\\n\\n    /**\\n     * @notice Emitted when the DAO treasury address is updated.\\n     * @param treasury The new DAO treasury address.\\n     */\\n    event UpdateTreasury(address indexed treasury);\\n\\n    /**\\n     * @notice Emitted when the liquidator address is set.\\n     * @param liquidator The liquidator address.\\n     */\\n    event SetLiquidator(address indexed liquidator);\\n\\n    /**\\n     * @notice Emitted when the vault address is set.\\n     * @param vault The vault address.\\n     */\\n    event SetVault(address indexed vault);\\n\\n    /**\\n     * @notice Emitted when the keeper fee payer address is set.\\n     * @param keeperFeePayer The keeper fee payer address.\\n     */\\n    event SetKeeperFeePayer(address indexed keeperFeePayer);\\n\\n    /**\\n     * @notice Emitted when a market is created.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param settlementToken The address of the settlement token.\\n     * @param market The address of the created market.\\n     */\\n    event MarketCreated(\\n        address indexed oracleProvider,\\n        address indexed settlementToken,\\n        address indexed market\\n    );\\n\\n    /**\\n     * @notice Returns the address of the DAO.\\n     * @return The address of the DAO.\\n     */\\n    function dao() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the DAO treasury.\\n     * @return The address of the DAO treasury.\\n     */\\n    function treasury() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the liquidator.\\n     * @return The address of the liquidator.\\n     */\\n    function liquidator() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the vault.\\n     * @return The address of the vault.\\n     */\\n    function vault() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the keeper fee payer.\\n     * @return The address of the keeper fee payer.\\n     */\\n    function keeperFeePayer() external view returns (address);\\n\\n    /**\\n     * @notice Updates the DAO address.\\n     * @param dao The new DAO address.\\n     */\\n    function updateDao(address dao) external;\\n\\n    /**\\n     * @notice Updates the DAO treasury address.\\n     * @param treasury The new DAO treasury address.\\n     */\\n    function updateTreasury(address treasury) external;\\n\\n    /**\\n     * @notice Sets the liquidator address.\\n     * @param liquidator The liquidator address.\\n     */\\n    function setLiquidator(address liquidator) external;\\n\\n    /**\\n     * @notice Sets the vault address.\\n     * @param vault The vault address.\\n     */\\n    function setVault(address vault) external;\\n\\n    /**\\n     * @notice Sets the keeper fee payer address.\\n     * @param keeperFeePayer The keeper fee payer address.\\n     */\\n    function setKeeperFeePayer(address keeperFeePayer) external;\\n\\n    /**\\n     * @notice Returns an array of all market addresses.\\n     * @return markets An array of all market addresses.\\n     */\\n    function getMarkets() external view returns (address[] memory markets);\\n\\n    /**\\n     * @notice Returns an array of market addresses associated with a settlement token.\\n     * @param settlementToken The address of the settlement token.\\n     * @return An array of market addresses.\\n     */\\n    function getMarketsBySettlmentToken(\\n        address settlementToken\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the address of a market associated with an oracle provider and settlement token.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param settlementToken The address of the settlement token.\\n     * @return The address of the market.\\n     */\\n    function getMarket(\\n        address oracleProvider,\\n        address settlementToken\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Creates a new market associated with an oracle provider and settlement token.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param settlementToken The address of the settlement token.\\n     */\\n    function createMarket(address oracleProvider, address settlementToken) external;\\n\\n    /**\\n     * @notice Checks if a market is registered.\\n     * @param market The address of the market.\\n     * @return True if the market is registered, false otherwise.\\n     */\\n    function isRegisteredMarket(address market) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8e303344e60930080fb08304bc34c43547e19aa2b381cd0e6cadbd7471fffc78\",\"license\":\"MIT\"},\"contracts/core/interfaces/IChromaticVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {ILendingPool} from \\\"@chromatic-protocol/contracts/core/interfaces/vault/ILendingPool.sol\\\";\\nimport {IVault} from \\\"@chromatic-protocol/contracts/core/interfaces/vault/IVault.sol\\\";\\n\\n/**\\n * @title IChromaticVault\\n * @notice Interface for the Chromatic Vault contract.\\n */\\ninterface IChromaticVault is IVault, ILendingPool {\\n    /**\\n     * @dev Emitted when market earning is accumulated.\\n     * @param market The address of the market.\\n     * @param earning The amount of earning accumulated.\\n     */\\n    event MarketEarningAccumulated(address indexed market, uint256 earning);\\n\\n    /**\\n     * @dev Emitted when maker earning is distributed.\\n     * @param token The address of the settlement token.\\n     * @param earning The amount of earning distributed.\\n     * @param usedKeeperFee The amount of keeper fee used.\\n     */\\n    event MakerEarningDistributed(\\n        address indexed token,\\n        uint256 indexed earning,\\n        uint256 indexed usedKeeperFee\\n    );\\n\\n    /**\\n     * @dev Emitted when market earning is distributed.\\n     * @param market The address of the market.\\n     * @param earning The amount of earning distributed.\\n     * @param usedKeeperFee The amount of keeper fee used.\\n     * @param marketBalance The balance of the market.\\n     */\\n    event MarketEarningDistributed(\\n        address indexed market,\\n        uint256 indexed earning,\\n        uint256 indexed usedKeeperFee,\\n        uint256 marketBalance\\n    );\\n\\n    /**\\n     * @notice Creates a maker earning distribution task for a token.\\n     * @param token The address of the settlement token.\\n     */\\n    function createMakerEarningDistributionTask(address token) external;\\n\\n    /**\\n     * @notice Cancels a maker earning distribution task for a token.\\n     * @param token The address of the settlement token.\\n     */\\n    function cancelMakerEarningDistributionTask(address token) external;\\n\\n    /**\\n     * @notice Creates a market earning distribution task for a market.\\n     * @param market The address of the market.\\n     */\\n    function createMarketEarningDistributionTask(address market) external;\\n\\n    /**\\n     * @notice Cancels a market earning distribution task for a market.\\n     * @param market The address of the market.\\n     */\\n    function cancelMarketEarningDistributionTask(address market) external;\\n}\\n\",\"keccak256\":\"0x6a1e0a240cd3ae3ed40cdc96f1430e5f57054d775db58d24f0760137245e7c44\",\"license\":\"MIT\"},\"contracts/core/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xa0f1bb72ac934dd8f4dfdd288d819c93f7b40a93d32a9939bf29ecf5cd428a0e\",\"license\":\"MIT\"},\"contracts/core/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x471352e8427771f52cb4aa9ef14894a2984f1e4ff82d3bde2c8d778aa23b9eca\",\"license\":\"MIT\"},\"contracts/core/interfaces/IInterestCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IInterestCalculator\\n * @dev Interface for an interest calculator contract.\\n */\\ninterface IInterestCalculator {\\n    /**\\n     * @notice Calculates the interest accrued for a given token and amount within a specified time range.\\n     * @param token The address of the token.\\n     * @param amount The amount of the token.\\n     * @param from The starting timestamp (inclusive) of the time range.\\n     * @param to The ending timestamp (exclusive) of the time range.\\n     * @return The accrued interest for the specified token and amount within the given time range.\\n     */\\n    function calculateInterest(\\n        address token,\\n        uint256 amount,\\n        uint256 from, // timestamp (inclusive)\\n        uint256 to // timestamp (exclusive)\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xf70b44ce6eb1422abed056169dc5db83ddbb2ee34d7751192f00e6cb3dc1ccbe\",\"license\":\"MIT\"},\"contracts/core/interfaces/IKeeperFeePayer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IKeeperFeePayer\\n * @dev Interface for a contract that pays keeper fees.\\n */\\ninterface IKeeperFeePayer {\\n    event SetRouter(address indexed);\\n\\n    /**\\n     * @notice Approves or revokes approval to the Uniswap router for a given token.\\n     * @param token The address of the token.\\n     * @param approve A boolean indicating whether to approve or revoke approval.\\n     */\\n    function approveToRouter(address token, bool approve) external;\\n\\n    /**\\n     * @notice Pays the keeper fee using Uniswap swaps.\\n     * @param tokenIn The address of the token being swapped.\\n     * @param amountOut The desired amount of output tokens.\\n     * @param keeperAddress The address of the keeper to receive the fee.\\n     * @return amountIn The actual amount of input tokens used for the swap.\\n     */\\n    function payKeeperFee(\\n        address tokenIn,\\n        uint256 amountOut,\\n        address keeperAddress\\n    ) external returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0xffaab8adb0713fa436e217be2aa016cf79b55ec2868db06656b150217151a66e\",\"license\":\"MIT\"},\"contracts/core/interfaces/factory/IMarketDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title An interface for a contract that is capable of deploying Chromatic markets\\n * @notice A contract that constructs a market must implement this to pass arguments to the market\\n * @dev This is used to avoid having constructor arguments in the market contract, which results in the init code hash\\n * of the market being constant allowing the CREATE2 address of the market to be cheaply computed on-chain\\n */\\ninterface IMarketDeployer {\\n    /**\\n     * @notice Get the parameters to be used in constructing the market, set transiently during market creation.\\n     * @dev Called by the market constructor to fetch the parameters of the market\\n     * Returns underlyingAsset The underlying asset of the market\\n     * Returns settlementToken The settlement token of the market\\n     * Returns vPoolCapacity Capacity of virtual future pool\\n     * Returns vPoolA Amplification coefficient of virtual future pool, precise value\\n     */\\n    function parameters() external view returns (address oracleProvider, address settlementToken);\\n}\\n\",\"keccak256\":\"0x6ce7c90b2b1a8ff9b721644a33ab4585d84fdacf789af3ea6169f49dc033fd77\",\"license\":\"MIT\"},\"contracts/core/interfaces/factory/IOracleProviderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IOracleProviderRegistry\\n * @dev Interface for the Oracle Provider Registry contract.\\n */\\ninterface IOracleProviderRegistry {\\n    struct OracleProviderProperties {\\n        uint32 minTakeProfitBPS;\\n        uint32 maxTakeProfitBPS;\\n        uint8 leverageLevel;\\n    }\\n\\n    /**\\n     * @dev Emitted when a new oracle provider is registered.\\n     * @param oracleProvider The address of the registered oracle provider.\\n     * @param properties The properties of the registered oracle provider.\\n     */\\n    event OracleProviderRegistered(\\n        address indexed oracleProvider,\\n        OracleProviderProperties properties\\n    );\\n\\n    /**\\n     * @dev Emitted when an oracle provider is unregistered.\\n     * @param oracleProvider The address of the unregistered oracle provider.\\n     */\\n    event OracleProviderUnregistered(address indexed oracleProvider);\\n\\n    /**\\n     * @dev Emitted when the take-profit basis points range of an oracle provider is updated.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param minTakeProfitBPS The new minimum take-profit basis points.\\n     * @param maxTakeProfitBPS The new maximum take-profit basis points.\\n     */\\n    event UpdateTakeProfitBPSRange(\\n        address indexed oracleProvider,\\n        uint32 indexed minTakeProfitBPS,\\n        uint32 indexed maxTakeProfitBPS\\n    );\\n\\n    /**\\n     * @dev Emitted when the level of an oracle provider is set.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param level The new level set for the oracle provider.\\n     */\\n    event UpdateLeverageLevel(address indexed oracleProvider, uint8 indexed level);\\n\\n    /**\\n     * @notice Registers an oracle provider.\\n     * @param oracleProvider The address of the oracle provider to register.\\n     * @param properties The properties of the oracle provider.\\n     */\\n    function registerOracleProvider(\\n        address oracleProvider,\\n        OracleProviderProperties memory properties\\n    ) external;\\n\\n    /**\\n     * @notice Unregisters an oracle provider.\\n     * @param oracleProvider The address of the oracle provider to unregister.\\n     */\\n    function unregisterOracleProvider(address oracleProvider) external;\\n\\n    /**\\n     * @notice Gets the registered oracle providers.\\n     * @return An array of registered oracle provider addresses.\\n     */\\n    function registeredOracleProviders() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Checks if an oracle provider is registered.\\n     * @param oracleProvider The address of the oracle provider to check.\\n     * @return A boolean indicating if the oracle provider is registered.\\n     */\\n    function isRegisteredOracleProvider(address oracleProvider) external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the properties of an oracle provider.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @return The properties of the oracle provider.\\n     */\\n    function getOracleProviderProperties(\\n        address oracleProvider\\n    ) external view returns (OracleProviderProperties memory);\\n\\n    /**\\n     * @notice Updates the take-profit basis points range of an oracle provider.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param minTakeProfitBPS The new minimum take-profit basis points.\\n     * @param maxTakeProfitBPS The new maximum take-profit basis points.\\n     */\\n    function updateTakeProfitBPSRange(\\n        address oracleProvider,\\n        uint32 minTakeProfitBPS,\\n        uint32 maxTakeProfitBPS\\n    ) external;\\n\\n    /**\\n     * @notice Updates the leverage level of an oracle provider in the registry.\\n     * @dev The level must be either 0 or 1, and the max leverage must be x10 for level 0 or x20 for level 1.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param level The new leverage level to be set for the oracle provider.\\n     */\\n    function updateLeverageLevel(address oracleProvider, uint8 level) external;\\n}\\n\",\"keccak256\":\"0x637b1a9c01a8352b8e3e57e6015d33df7ec41825a65a24b07c4cf4d1d1b6fe9c\",\"license\":\"MIT\"},\"contracts/core/interfaces/factory/ISettlementTokenRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {InterestRate} from \\\"@chromatic-protocol/contracts/core/libraries/InterestRate.sol\\\";\\n\\n/**\\n * @title ISettlementTokenRegistry\\n * @dev Interface for the Settlement Token Registry contract.\\n */\\ninterface ISettlementTokenRegistry {\\n    /**\\n     * @dev Emitted when a new settlement token is registered.\\n     * @param token The address of the registered settlement token.\\n     * @param minimumMargin The minimum margin for the markets using this settlement token.\\n     * @param interestRate The interest rate for the settlement token.\\n     * @param flashLoanFeeRate The flash loan fee rate for the settlement token.\\n     * @param earningDistributionThreshold The earning distribution threshold for the settlement token.\\n     * @param uniswapFeeTier The Uniswap fee tier for the settlement token.\\n     */\\n    event SettlementTokenRegistered(\\n        address indexed token,\\n        uint256 indexed minimumMargin,\\n        uint256 indexed interestRate,\\n        uint256 flashLoanFeeRate,\\n        uint256 earningDistributionThreshold,\\n        uint24 uniswapFeeTier\\n    );\\n\\n    /**\\n     * @dev Emitted when the minimum margin for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param minimumMargin The new minimum margin for the settlement token.\\n     */\\n    event SetMinimumMargin(address indexed token, uint256 indexed minimumMargin);\\n\\n    /**\\n     * @dev Emitted when the flash loan fee rate for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param flashLoanFeeRate The new flash loan fee rate for the settlement token.\\n     */\\n    event SetFlashLoanFeeRate(address indexed token, uint256 indexed flashLoanFeeRate);\\n\\n    /**\\n     * @dev Emitted when the earning distribution threshold for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param earningDistributionThreshold The new earning distribution threshold for the settlement token.\\n     */\\n    event SetEarningDistributionThreshold(\\n        address indexed token,\\n        uint256 indexed earningDistributionThreshold\\n    );\\n\\n    /**\\n     * @dev Emitted when the Uniswap fee tier for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param uniswapFeeTier The new Uniswap fee tier for the settlement token.\\n     */\\n    event SetUniswapFeeTier(address indexed token, uint24 indexed uniswapFeeTier);\\n\\n    /**\\n     * @dev Emitted when an interest rate record is appended for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points (BPS).\\n     * @param beginTimestamp The timestamp when the interest rate record begins.\\n     */\\n    event InterestRateRecordAppended(\\n        address indexed token,\\n        uint256 indexed annualRateBPS,\\n        uint256 indexed beginTimestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the last interest rate record is removed for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points (BPS).\\n     * @param beginTimestamp The timestamp when the interest rate record begins.\\n     */\\n    event LastInterestRateRecordRemoved(\\n        address indexed token,\\n        uint256 indexed annualRateBPS,\\n        uint256 indexed beginTimestamp\\n    );\\n\\n    /**\\n     * @notice Registers a new settlement token.\\n     * @param token The address of the settlement token to register.\\n     * @param minimumMargin The minimum margin for the settlement token.\\n     * @param interestRate The interest rate for the settlement token.\\n     * @param flashLoanFeeRate The flash loan fee rate for the settlement token.\\n     * @param earningDistributionThreshold The earning distribution threshold for the settlement token.\\n     * @param uniswapFeeTier The Uniswap fee tier for the settlement token.\\n     */\\n    function registerSettlementToken(\\n        address token,\\n        uint256 minimumMargin,\\n        uint256 interestRate,\\n        uint256 flashLoanFeeRate,\\n        uint256 earningDistributionThreshold,\\n        uint24 uniswapFeeTier\\n    ) external;\\n\\n    /**\\n     * @notice Gets the list of registered settlement tokens.\\n     * @return An array of addresses representing the registered settlement tokens.\\n     */\\n    function registeredSettlementTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Checks if a settlement token is registered.\\n     * @param token The address of the settlement token to check.\\n     * @return True if the settlement token is registered, false otherwise.\\n     */\\n    function isRegisteredSettlementToken(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Gets the minimum margin for a settlement token.\\n     * @dev The minimumMargin is used as the minimum value for the taker margin of a position\\n     *      or as the minimum value for the maker margin of each bin.\\n     * @param token The address of the settlement token.\\n     * @return The minimum margin for the settlement token.\\n     */\\n    function getMinimumMargin(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the minimum margin for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param minimumMargin The new minimum margin for the settlement token.\\n     */\\n    function setMinimumMargin(address token, uint256 minimumMargin) external;\\n\\n    /**\\n     * @notice Gets the flash loan fee rate for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The flash loan fee rate for the settlement token.\\n     */\\n    function getFlashLoanFeeRate(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the flash loan fee rate for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param flashLoanFeeRate The new flash loan fee rate for the settlement token.\\n     */\\n    function setFlashLoanFeeRate(address token, uint256 flashLoanFeeRate) external;\\n\\n    /**\\n     * @notice Gets the earning distribution threshold for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The earning distribution threshold for the settlement token.\\n     */\\n    function getEarningDistributionThreshold(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the earning distribution threshold for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param earningDistributionThreshold The new earning distribution threshold for the settlement token.\\n     */\\n    function setEarningDistributionThreshold(\\n        address token,\\n        uint256 earningDistributionThreshold\\n    ) external;\\n\\n    /**\\n     * @notice Gets the Uniswap fee tier for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The Uniswap fee tier for the settlement token.\\n     */\\n    function getUniswapFeeTier(address token) external view returns (uint24);\\n\\n    /**\\n     * @notice Sets the Uniswap fee tier for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param uniswapFeeTier The new Uniswap fee tier for the settlement token.\\n     */\\n    function setUniswapFeeTier(address token, uint24 uniswapFeeTier) external;\\n\\n    /**\\n     * @notice Appends an interest rate record for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points (BPS).\\n     * @param beginTimestamp The timestamp when the interest rate record begins.\\n     */\\n    function appendInterestRateRecord(\\n        address token,\\n        uint256 annualRateBPS,\\n        uint256 beginTimestamp\\n    ) external;\\n\\n    /**\\n     * @notice Removes the last interest rate record for a settlement token.\\n     * @param token The address of the settlement token.\\n     */\\n    function removeLastInterestRateRecord(address token) external;\\n\\n    /**\\n     * @notice Gets the current interest rate for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The current interest rate for the settlement token.\\n     */\\n    function currentInterestRate(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets all the interest rate records for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return An array of interest rate records for the settlement token.\\n     */\\n    function getInterestRateRecords(\\n        address token\\n    ) external view returns (InterestRate.Record[] memory);\\n}\\n\",\"keccak256\":\"0xd6f2e609c42fed3def6cde7e2d14623e1252356ab0ce79db7fc491c302c491b2\",\"license\":\"MIT\"},\"contracts/core/interfaces/market/IMarketLiquidate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Position} from \\\"@chromatic-protocol/contracts/core/libraries/Position.sol\\\";\\n\\n/**\\n * @title IMarketLiquidate\\n * @dev Interface for liquidating and claiming positions in a market.\\n */\\ninterface IMarketLiquidate {\\n    /**\\n     * @dev Emitted when a position is claimed by keeper.\\n     * @param account The address of the account claiming the position.\\n     * @param pnl The profit or loss of the claimed position.\\n     * @param interest The interest paid for the claimed position.\\n     * @param usedKeeperFee The amount of keeper fee used for the liquidation.\\n     * @param position The claimed position.\\n     */\\n    event ClaimPositionByKeeper(\\n        address indexed account,\\n        int256 indexed pnl,\\n        uint256 indexed interest,\\n        uint256 usedKeeperFee,\\n        Position position\\n    );\\n\\n    /**\\n     * @dev Emitted when a position is liquidated.\\n     * @param account The address of the account being liquidated.\\n     * @param pnl The profit or loss of the claimed position.\\n     * @param interest The interest paid for the claimed position.\\n     * @param usedKeeperFee The amount of keeper fee used for the liquidation.\\n     * @param position The liquidated position.\\n     */\\n    event Liquidate(\\n        address indexed account,\\n        int256 indexed pnl,\\n        uint256 indexed interest,\\n        uint256 usedKeeperFee,\\n        Position position\\n    );\\n\\n    /**\\n     * @dev Checks if a position is eligible for liquidation.\\n     * @param positionId The ID of the position to check.\\n     * @return A boolean indicating if the position is eligible for liquidation.\\n     */\\n    function checkLiquidation(uint256 positionId) external view returns (bool);\\n\\n    /**\\n     * @dev Liquidates a position.\\n     * @param positionId The ID of the position to liquidate.\\n     * @param keeper The address of the keeper performing the liquidation.\\n     * @param keeperFee The native token amount of the keeper's fee.\\n     */\\n    function liquidate(uint256 positionId, address keeper, uint256 keeperFee) external;\\n\\n    /**\\n     * @dev Checks if a position is eligible for claim.\\n     * @param positionId The ID of the position to check.\\n     * @return A boolean indicating if the position is eligible for claim.\\n     */\\n    function checkClaimPosition(uint256 positionId) external view returns (bool);\\n\\n    /**\\n     * @dev Claims a closed position on behalf of a keeper.\\n     * @param positionId The ID of the position to claim.\\n     * @param keeper The address of the keeper claiming the position.\\n     * @param keeperFee The native token amount of the keeper's fee.\\n     */\\n    function claimPosition(uint256 positionId, address keeper, uint256 keeperFee) external;\\n}\\n\",\"keccak256\":\"0x4b14cfba4efebc696bbd43e4995f1f531800d9fe5c3189e01c1335eb8e1acf39\",\"license\":\"MIT\"},\"contracts/core/interfaces/market/IMarketLiquidity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {LpReceipt} from \\\"@chromatic-protocol/contracts/core/libraries/LpReceipt.sol\\\";\\n\\n/**\\n * @title IMarketLiquidity\\n * @dev The interface for liquidity operations in a market.\\n */\\ninterface IMarketLiquidity {\\n    /**\\n     * @dev A struct representing claimable liquidity information.\\n     */\\n    struct ClaimableLiquidity {\\n        /// @dev The amount of settlement tokens requested for minting.\\n        uint256 mintingTokenAmountRequested;\\n        /// @dev The actual amount of CLB tokens minted.\\n        uint256 mintingCLBTokenAmount;\\n        /// @dev The amount of CLB tokens requested for burning.\\n        uint256 burningCLBTokenAmountRequested;\\n        /// @dev The actual amount of CLB tokens burned.\\n        uint256 burningCLBTokenAmount;\\n        /// @dev The amount of settlement tokens equal in value to the burned CLB tokens.\\n        uint256 burningTokenAmount;\\n    }\\n\\n    struct LiquidityBinStatus {\\n        uint256 liquidity;\\n        uint256 freeLiquidity;\\n        uint256 binValue;\\n        int16 tradingFeeRate;\\n    }\\n\\n    /**\\n     * @dev Emitted when liquidity is added to the market.\\n     * @param receipt The liquidity receipt.\\n     */\\n    event AddLiquidity(LpReceipt receipt);\\n\\n    /**\\n     * @dev Emitted when liquidity is added to the market.\\n     * @param receipts An array of LP receipts.\\n     */\\n    event AddLiquidityBatch(LpReceipt[] receipts);\\n\\n    /**\\n     * @dev Emitted when liquidity is claimed from the market.\\n     * @param clbTokenAmount The amount of CLB tokens claimed.\\n     * @param receipt The liquidity receipt.\\n     */\\n    event ClaimLiquidity(LpReceipt receipt, uint256 indexed clbTokenAmount);\\n\\n    /**\\n     * @dev Emitted when liquidity is claimed from the market.\\n     * @param receipts An array of LP receipts.\\n     * @param clbTokenAmounts The amount list of CLB tokens claimed.\\n     */\\n    event ClaimLiquidityBatch(LpReceipt[] receipts, uint256[] clbTokenAmounts);\\n\\n    /**\\n     * @dev Emitted when liquidity is removed from the market.\\n     * @param receipt The liquidity receipt.\\n     */\\n    event RemoveLiquidity(LpReceipt receipt);\\n\\n    /**\\n     * @dev Emitted when liquidity is removed from the market.\\n     * @param receipts An array of LP receipts.\\n     */\\n    event RemoveLiquidityBatch(LpReceipt[] receipts);\\n\\n    /**\\n     * @dev Emitted when liquidity is withdrawn from the market.\\n     * @param receipt The liquidity receipt.\\n     * @param amount The amount of liquidity withdrawn.\\n     * @param burnedCLBTokenAmount The amount of burned CLB tokens.\\n     */\\n    event WithdrawLiquidity(\\n        LpReceipt receipt,\\n        uint256 indexed amount,\\n        uint256 indexed burnedCLBTokenAmount\\n    );\\n\\n    /**\\n     * @dev Emitted when liquidity is withdrawn from the market.\\n     * @param receipts An array of LP receipts.\\n     * @param amounts The amount list of liquidity withdrawn.\\n     * @param burnedCLBTokenAmounts The amount list of burned CLB tokens.\\n     */\\n    event WithdrawLiquidityBatch(\\n        LpReceipt[] receipts,\\n        uint256[] amounts,\\n        uint256[] burnedCLBTokenAmounts\\n    );\\n\\n    /**\\n     * @dev Adds liquidity to the market.\\n     * @param recipient The address to receive the liquidity tokens.\\n     * @param tradingFeeRate The trading fee rate for the liquidity.\\n     * @param data Additional data for the liquidity callback.\\n     * @return The liquidity receipt.\\n     */\\n    function addLiquidity(\\n        address recipient,\\n        int16 tradingFeeRate,\\n        bytes calldata data\\n    ) external returns (LpReceipt memory);\\n\\n    /**\\n     * @notice Adds liquidity to multiple liquidity bins of the market in a batch.\\n     * @param recipient The address of the recipient for each liquidity bin.\\n     * @param tradingFeeRates An array of fee rates for each liquidity bin.\\n     * @param amounts An array of amounts to add as liquidity for each bin.\\n     * @param data Additional data for the liquidity callback.\\n     * @return An array of LP receipts.\\n     */\\n    function addLiquidityBatch(\\n        address recipient,\\n        int16[] calldata tradingFeeRates,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (LpReceipt[] memory);\\n\\n    /**\\n     * @dev Claims liquidity from a liquidity receipt.\\n     * @param receiptId The ID of the liquidity receipt.\\n     * @param data Additional data for the liquidity callback.\\n     */\\n    function claimLiquidity(uint256 receiptId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Claims liquidity from a liquidity receipt.\\n     * @param receiptIds The array of the liquidity receipt IDs.\\n     * @param data Additional data for the liquidity callback.\\n     */\\n    function claimLiquidityBatch(uint256[] calldata receiptIds, bytes calldata data) external;\\n\\n    /**\\n     * @dev Removes liquidity from the market.\\n     * @param recipient The address to receive the removed liquidity.\\n     * @param tradingFeeRate The trading fee rate for the liquidity.\\n     * @param data Additional data for the liquidity callback.\\n     * @return The liquidity receipt.\\n     */\\n    function removeLiquidity(\\n        address recipient,\\n        int16 tradingFeeRate,\\n        bytes calldata data\\n    ) external returns (LpReceipt memory);\\n\\n    /**\\n     * @dev Removes liquidity from the market.\\n     * @param recipient The address to receive the removed liquidity.\\n     * @param tradingFeeRates An array of fee rates for each liquidity bin.\\n     * @param clbTokenAmounts An array of clb token amounts to remove as liquidity for each bin.\\n     * @param data Additional data for the liquidity callback.\\n     * @return The liquidity receipt.\\n     */\\n    function removeLiquidityBatch(\\n        address recipient,\\n        int16[] calldata tradingFeeRates,\\n        uint256[] calldata clbTokenAmounts,\\n        bytes calldata data\\n    ) external returns (LpReceipt[] memory);\\n\\n    /**\\n     * @dev Withdraws liquidity from a liquidity receipt.\\n     * @param receiptId The ID of the liquidity receipt.\\n     * @param data Additional data for the liquidity callback.\\n     */\\n    function withdrawLiquidity(uint256 receiptId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Withdraws liquidity from a liquidity receipt.\\n     * @param receiptIds The array of the liquidity receipt IDs.\\n     * @param data Additional data for the liquidity callback.\\n     */\\n    function withdrawLiquidityBatch(uint256[] calldata receiptIds, bytes calldata data) external;\\n\\n    /**\\n     * @dev Retrieves the total liquidity amount for a specific trading fee rate in the liquidity pool.\\n     * @param tradingFeeRate The trading fee rate for which to retrieve the liquidity amount.\\n     * @return amount The total liquidity amount for the specified trading fee rate.\\n     */\\n    function getBinLiquidity(int16 tradingFeeRate) external view returns (uint256 amount);\\n\\n    /**\\n     * @dev Retrieves the available (free) liquidity amount for a specific trading fee rate in the liquidity pool.\\n     * @param tradingFeeRate The trading fee rate for which to retrieve the available liquidity amount.\\n     * @return amount The available (free) liquidity amount for the specified trading fee rate.\\n     */\\n    function getBinFreeLiquidity(int16 tradingFeeRate) external view returns (uint256 amount);\\n\\n    /**\\n     * @dev Retrieves the values of a specific trading fee rate's bins in the liquidity pool.\\n     *      The value of a bin represents the total valuation of the liquidity in the bin.\\n     * @param tradingFeeRates The list of trading fee rate for which to retrieve the bin value.\\n     * @return values The value list of the bins for the specified trading fee rates.\\n     */\\n    function getBinValues(\\n        int16[] memory tradingFeeRates\\n    ) external view returns (uint256[] memory values);\\n\\n    /**\\n     * @dev Distributes earning to the liquidity bins.\\n     * @param earning The amount of earning to distribute.\\n     * @param marketBalance The balance of the market.\\n     */\\n    function distributeEarningToBins(uint256 earning, uint256 marketBalance) external;\\n\\n    /**\\n     * @dev Retrieves the liquidity receipt with the given receipt ID.\\n     *      It throws NotExistLpReceipt if the specified receipt ID does not exist.\\n     * @param receiptId The ID of the liquidity receipt to retrieve.\\n     * @return receipt The liquidity receipt with the specified ID.\\n     */\\n    function getLpReceipt(uint256 receiptId) external view returns (LpReceipt memory);\\n\\n    /**\\n     * @dev Retrieves the claimable liquidity information for a specific trading fee rate and oracle version from the associated LiquidityPool.\\n     * @param tradingFeeRate The trading fee rate for which to retrieve the claimable liquidity.\\n     * @param oracleVersion The oracle version for which to retrieve the claimable liquidity.\\n     * @return claimableLiquidity An instance of ClaimableLiquidity representing the claimable liquidity information.\\n     */\\n    function claimableLiquidity(\\n        int16 tradingFeeRate,\\n        uint256 oracleVersion\\n    ) external view returns (ClaimableLiquidity memory);\\n\\n    /**\\n     * @dev Retrieves the liquidity bin statuses for the caller's liquidity pool.\\n     * @return statuses An array of LiquidityBinStatus representing the liquidity bin statuses.\\n     */\\n    function liquidityBinStatuses() external view returns (LiquidityBinStatus[] memory);\\n}\\n\",\"keccak256\":\"0x76e5f17d69db81b0b3310df206b00130963b4b769ec33d90cd89af2cb25b8ccd\",\"license\":\"MIT\"},\"contracts/core/interfaces/market/IMarketSettle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IMarketSettle\\n * @dev Interface for market settlement.\\n */\\ninterface IMarketSettle {\\n    /**\\n     * @notice Executes the settlement process for the Chromatic market.\\n     * @dev This function is called to settle the market.\\n     */\\n    function settle() external;\\n}\\n\",\"keccak256\":\"0x200787d993cd29dd3d2f4de7a0430201d076580e8af8a6fae99fa268d437071f\",\"license\":\"MIT\"},\"contracts/core/interfaces/market/IMarketState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {IChromaticMarketFactory} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarketFactory.sol\\\";\\nimport {IChromaticLiquidator} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticLiquidator.sol\\\";\\nimport {IChromaticVault} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticVault.sol\\\";\\nimport {ICLBToken} from \\\"@chromatic-protocol/contracts/core/interfaces/ICLBToken.sol\\\";\\nimport {IKeeperFeePayer} from \\\"@chromatic-protocol/contracts/core/interfaces/IKeeperFeePayer.sol\\\";\\n\\n/**\\n * @title IMarketState\\n * @dev Interface for accessing the state of a market contract.\\n */\\ninterface IMarketState {\\n    /**\\n     * @notice Emitted when the protocol fee is changed by the market\\n     * @param feeProtocolOld The previous value of the protocol fee\\n     * @param feeProtocolNew The updated value of the protocol fee\\n     */\\n    event SetFeeProtocol(uint8 feeProtocolOld, uint8 feeProtocolNew);\\n\\n    /**\\n     * @dev Returns the factory contract for the market.\\n     * @return The factory contract.\\n     */\\n    function factory() external view returns (IChromaticMarketFactory);\\n\\n    /**\\n     * @dev Returns the settlement token of the market.\\n     * @return The settlement token.\\n     */\\n    function settlementToken() external view returns (IERC20Metadata);\\n\\n    /**\\n     * @dev Returns the oracle provider contract for the market.\\n     * @return The oracle provider contract.\\n     */\\n    function oracleProvider() external view returns (IOracleProvider);\\n\\n    /**\\n     * @dev Returns the CLB token contract for the market.\\n     * @return The CLB token contract.\\n     */\\n    function clbToken() external view returns (ICLBToken);\\n\\n    /**\\n     * @dev Returns the liquidator contract for the market.\\n     * @return The liquidator contract.\\n     */\\n    function liquidator() external view returns (IChromaticLiquidator);\\n\\n    /**\\n     * @dev Returns the vault contract for the market.\\n     * @return The vault contract.\\n     */\\n    function vault() external view returns (IChromaticVault);\\n\\n    /**\\n     * @dev Returns the keeper fee payer contract for the market.\\n     * @return The keeper fee payer contract.\\n     */\\n    function keeperFeePayer() external view returns (IKeeperFeePayer);\\n\\n    /**\\n     * @notice Returns the denominator of the protocol's % share of the fees\\n     * @return The protocol fee for the market\\n     */\\n    function feeProtocol() external view returns (uint8);\\n\\n    /**\\n     * @notice Set the denominator of the protocol's % share of the fees\\n     * @param feeProtocol new protocol fee for the market\\n     */\\n    function setFeeProtocol(uint8 feeProtocol) external;\\n}\\n\",\"keccak256\":\"0x1f906d4435de4d79bbfe2904e9c4a5e95af9bc576d7302b21e333840f9d91d20\",\"license\":\"MIT\"},\"contracts/core/interfaces/market/IMarketTrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Position} from \\\"@chromatic-protocol/contracts/core/libraries/Position.sol\\\";\\n\\n/**\\n * @title IMarketTrade\\n * @dev Interface for trading positions in a market.\\n */\\ninterface IMarketTrade {\\n    /**\\n     * @dev Emitted when a position is opened.\\n     * @param account The address of the account opening the position.\\n     * @param position The opened position.\\n     */\\n    event OpenPosition(address indexed account, Position position);\\n\\n    /**\\n     * @dev Emitted when a position is closed.\\n     * @param account The address of the account closing the position.\\n     * @param position The closed position.\\n     */\\n    event ClosePosition(address indexed account, Position position);\\n\\n    /**\\n     * @dev Emitted when a position is claimed.\\n     * @param account The address of the account claiming the position.\\n     * @param pnl The profit or loss of the claimed position.\\n     * @param interest The interest paid for the claimed position.\\n     * @param position The claimed position.\\n     */\\n    event ClaimPosition(\\n        address indexed account,\\n        int256 indexed pnl,\\n        uint256 indexed interest,\\n        Position position\\n    );\\n\\n    /**\\n     * @dev Emitted when protocol fees are transferred.\\n     * @param positionId The ID of the position for which the fees are transferred.\\n     * @param amount The amount of fees transferred.\\n     */\\n    event TransferProtocolFee(uint256 indexed positionId, uint256 indexed amount);\\n\\n    /**\\n     * @dev Opens a new position in the market.\\n     * @param qty The quantity of the position.\\n     * @param leverage The leverage of the position in basis points.\\n     * @param takerMargin The margin amount provided by the taker.\\n     * @param makerMargin The margin amount provided by the maker.\\n     * @param maxAllowableTradingFee The maximum allowable trading fee for the position.\\n     * @param data Additional data for the position callback.\\n     * @return The opened position.\\n     */\\n    function openPosition(\\n        int224 qty,\\n        uint32 leverage, // BPS\\n        uint256 takerMargin,\\n        uint256 makerMargin,\\n        uint256 maxAllowableTradingFee,\\n        bytes calldata data\\n    ) external returns (Position memory);\\n\\n    /**\\n     * @dev Closes a position in the market.\\n     * @param positionId The ID of the position to close.\\n     */\\n    function closePosition(uint256 positionId) external;\\n\\n    /**\\n     * @dev Claims a closed position in the market.\\n     * @param positionId The ID of the position to claim.\\n     * @param recipient The address of the recipient of the claimed position.\\n     * @param data Additional data for the claim callback.\\n     */\\n    function claimPosition(\\n        uint256 positionId,\\n        address recipient, // EOA or account contract\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Retrieves multiple positions by their IDs.\\n     * @param positionIds The IDs of the positions to retrieve.\\n     * @return positions An array of retrieved positions.\\n     */\\n    function getPositions(\\n        uint256[] calldata positionIds\\n    ) external view returns (Position[] memory positions);\\n}\\n\",\"keccak256\":\"0xb71c9dc0e5c37e4ede48ed1cf74fad05ee31334dacf0dbdc582513bc94592491\",\"license\":\"MIT\"},\"contracts/core/interfaces/vault/ILendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title ILendingPool\\n * @dev Interface for a lending pool contract.\\n */\\ninterface ILendingPool {\\n    /**\\n     * @notice Emitted when a flash loan is executed.\\n     * @param sender The address initiating the flash loan.\\n     * @param recipient The address receiving the flash loan.\\n     * @param amount The amount of the flash loan.\\n     * @param paid The amount paid back after the flash loan.\\n     * @param paidToTakerPool The amount paid to the taker pool after the flash loan.\\n     * @param paidToMakerPool The amount paid to the maker pool after the flash loan.\\n     */\\n    event FlashLoan(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 indexed amount,\\n        uint256 paid,\\n        uint256 paidToTakerPool,\\n        uint256 paidToMakerPool\\n    );\\n\\n    /**\\n     * @notice Executes a flash loan.\\n     * @param token The address of the token for the flash loan.\\n     * @param amount The amount of the flash loan.\\n     * @param recipient The address to receive the flash loan.\\n     * @param data Additional data for the flash loan.\\n     */\\n    function flashLoan(\\n        address token,\\n        uint256 amount,\\n        address recipient,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice Retrieves the pending share of earnings for a specific bin (subset) of funds in a market.\\n     * @param market The address of the market.\\n     * @param settlementToken The settlement token address.\\n     * @param binBalance The balance of funds in the bin.\\n     * @return The pending share of earnings for the specified bin.\\n     */\\n    function getPendingBinShare(\\n        address market,\\n        address settlementToken,\\n        uint256 binBalance\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x6ff7f0f07254c591dda3c052cc6d02b89e4bcd4e9efe79f3f483ad067cfb9906\",\"license\":\"MIT\"},\"contracts/core/interfaces/vault/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IVault\\n * @dev Interface for the Vault contract, responsible for managing positions and liquidity.\\n */\\ninterface IVault {\\n    /**\\n     * @notice Emitted when a position is opened.\\n     * @param market The address of the market.\\n     * @param positionId The ID of the opened position.\\n     * @param takerMargin The margin amount provided by the taker for the position.\\n     * @param tradingFee The trading fee associated with the position.\\n     * @param protocolFee The protocol fee associated with the position.\\n     */\\n    event OnOpenPosition(\\n        address indexed market,\\n        uint256 indexed positionId,\\n        uint256 indexed takerMargin,\\n        uint256 tradingFee,\\n        uint256 protocolFee\\n    );\\n\\n    /**\\n     * @notice Emitted when a position is claimed.\\n     * @param market The address of the market.\\n     * @param positionId The ID of the claimed position.\\n     * @param recipient The address of the recipient of the settlement amount.\\n     * @param takerMargin The margin amount provided by the taker for the position.\\n     * @param settlementAmount The settlement amount received by the recipient.\\n     */\\n    event OnClaimPosition(\\n        address indexed market,\\n        uint256 indexed positionId,\\n        address indexed recipient,\\n        uint256 takerMargin,\\n        uint256 settlementAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when liquidity is added to the vault.\\n     * @param market The address of the market.\\n     * @param amount The amount of liquidity added.\\n     */\\n    event OnAddLiquidity(address indexed market, uint256 indexed amount);\\n\\n    /**\\n     * @notice Emitted when pending liquidity is settled.\\n     * @param market The address of the market.\\n     * @param pendingDeposit The amount of pending deposit being settled.\\n     * @param pendingWithdrawal The amount of pending withdrawal being settled.\\n     */\\n    event OnSettlePendingLiquidity(\\n        address indexed market,\\n        uint256 indexed pendingDeposit,\\n        uint256 indexed pendingWithdrawal\\n    );\\n\\n    /**\\n     * @notice Emitted when liquidity is withdrawn from the vault.\\n     * @param market The address of the market.\\n     * @param amount The amount of liquidity withdrawn.\\n     * @param recipient The address of the recipient of the withdrawn liquidity.\\n     */\\n    event OnWithdrawLiquidity(\\n        address indexed market,\\n        uint256 indexed amount,\\n        address indexed recipient\\n    );\\n\\n    /**\\n     * @notice Emitted when the keeper fee is transferred.\\n     * @param fee The amount of the transferred keeper fee as native token.\\n     * @param amount The amount of settlement token to be used for paying keeper fee.\\n     */\\n    event TransferKeeperFee(uint256 indexed fee, uint256 indexed amount);\\n\\n    /**\\n     * @notice Emitted when the keeper fee is transferred for a specific market.\\n     * @param market The address of the market.\\n     * @param fee The amount of the transferred keeper fee as native token.\\n     * @param amount The amount of settlement token to be used for paying keeper fee.\\n     */\\n    event TransferKeeperFee(address indexed market, uint256 indexed fee, uint256 indexed amount);\\n\\n    /**\\n     * @notice Emitted when the protocol fee is transferred for a specific position.\\n     * @param market The address of the market.\\n     * @param positionId The ID of the position.\\n     * @param amount The amount of the transferred fee.\\n     */\\n    event TransferProtocolFee(\\n        address indexed market,\\n        uint256 indexed positionId,\\n        uint256 indexed amount\\n    );\\n\\n    /**\\n     * @notice Called when a position is opened by a market contract.\\n     * @param settlementToken The settlement token address.\\n     * @param positionId The ID of the opened position.\\n     * @param takerMargin The margin amount provided by the taker for the position.\\n     * @param tradingFee The trading fee associated with the position.\\n     * @param protocolFee The protocol fee associated with the position.\\n     */\\n    function onOpenPosition(\\n        address settlementToken,\\n        uint256 positionId,\\n        uint256 takerMargin,\\n        uint256 tradingFee,\\n        uint256 protocolFee\\n    ) external;\\n\\n    /**\\n     * @notice Called when a position is claimed by a market contract.\\n     * @param settlementToken The settlement token address.\\n     * @param positionId The ID of the claimed position.\\n     * @param recipient The address that will receive the settlement amount.\\n     * @param takerMargin The margin amount provided by the taker for the position.\\n     * @param settlementAmount The amount to be settled for the position.\\n     */\\n    function onClaimPosition(\\n        address settlementToken,\\n        uint256 positionId,\\n        address recipient,\\n        uint256 takerMargin,\\n        uint256 settlementAmount\\n    ) external;\\n\\n    /**\\n     * @notice Called when liquidity is added to the vault by a market contract.\\n     * @param settlementToken The settlement token address.\\n     * @param amount The amount of liquidity being added.\\n     */\\n    function onAddLiquidity(address settlementToken, uint256 amount) external;\\n\\n    /**\\n     * @notice Called when pending liquidity is settled in the vault by a market contract.\\n     * @param settlementToken The settlement token address.\\n     * @param pendingDeposit The amount of pending deposits being settled.\\n     * @param pendingWithdrawal The amount of pending withdrawals being settled.\\n     */\\n    function onSettlePendingLiquidity(\\n        address settlementToken,\\n        uint256 pendingDeposit,\\n        uint256 pendingWithdrawal\\n    ) external;\\n\\n    /**\\n     * @notice Called when liquidity is withdrawn from the vault by a market contract.\\n     * @param settlementToken The settlement token address.\\n     * @param recipient The address that will receive the withdrawn liquidity.\\n     * @param amount The amount of liquidity to be withdrawn.\\n     */\\n    function onWithdrawLiquidity(\\n        address settlementToken,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Transfers the keeper fee from the market to the specified keeper.\\n     * @param settlementToken The settlement token address.\\n     * @param keeper The address of the keeper to receive the fee.\\n     * @param fee The amount of the fee to transfer as native token.\\n     * @param margin The margin amount used for the fee payment.\\n     * @return usedFee The actual settlement token amount of fee used for the transfer.\\n     */\\n    function transferKeeperFee(\\n        address settlementToken,\\n        address keeper,\\n        uint256 fee,\\n        uint256 margin\\n    ) external returns (uint256 usedFee);\\n}\\n\",\"keccak256\":\"0x3a3d8c5034d3a473347b2fe53a7973deeab827a88f6e83fc0ab2b0a85e45e429\",\"license\":\"MIT\"},\"contracts/core/libraries/BinMargin.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title BinMargin\\n * @dev The BinMargin struct represents the margin information for an LP bin.\\n */\\nstruct BinMargin {\\n    /// @dev The trading fee rate associated with the LP bin\\n    uint16 tradingFeeRate;\\n    /// @dev The maker margin amount specified for the LP bin\\n    uint256 amount;\\n}\\n\\nusing BinMarginLib for BinMargin global;\\n\\n/**\\n * @title BinMarginLib\\n * @dev The BinMarginLib library provides functions to operate on BinMargin structs.\\n */\\nlibrary BinMarginLib {\\n    using Math for uint256;\\n\\n    uint256 constant TRADING_FEE_RATE_PRECISION = 10000;\\n\\n    /**\\n     * @notice Calculates the trading fee based on the margin amount and the trading fee rate.\\n     * @param self The BinMargin struct\\n     * @param _feeProtocol The protocol fee for the market\\n     * @return The trading fee amount\\n     */\\n    function tradingFee(BinMargin memory self, uint8 _feeProtocol) internal pure returns (uint256) {\\n        uint256 _tradingFee = self.amount.mulDiv(self.tradingFeeRate, TRADING_FEE_RATE_PRECISION);\\n        return _tradingFee - _protocolFee(_tradingFee, _feeProtocol);\\n    }\\n\\n    /**\\n     * @notice Calculates the protocol fee based on the margin amount and the trading fee rate.\\n     * @param self The BinMargin struct\\n     * @param _feeProtocol The protocol fee for the market\\n     * @return The protocol fee amount\\n     */\\n    function protocolFee(\\n        BinMargin memory self,\\n        uint8 _feeProtocol\\n    ) internal pure returns (uint256) {\\n        return\\n            _protocolFee(\\n                self.amount.mulDiv(self.tradingFeeRate, TRADING_FEE_RATE_PRECISION),\\n                _feeProtocol\\n            );\\n    }\\n\\n    function _protocolFee(uint256 _tradingFee, uint8 _feeProtocol) private pure returns (uint256) {\\n        return _feeProtocol != 0 ? _tradingFee / _feeProtocol : 0;\\n    }\\n}\\n\",\"keccak256\":\"0x6e94a113a8f1710743587c3620b163112ff9949761ec495407c3a03989a41b1c\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/CLBTokenLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {FEE_RATES_LENGTH} from \\\"@chromatic-protocol/contracts/core/libraries/Constants.sol\\\";\\n\\n/**\\n * @title CLBTokenLib\\n * @notice Provides utility functions for working with CLB tokens.\\n */\\nlibrary CLBTokenLib {\\n    using SignedMath for int256;\\n    using SafeCast for uint256;\\n\\n    uint256 private constant DIRECTION_PRECISION = 10 ** 10;\\n    uint16 private constant MIN_FEE_RATE = 1;\\n\\n    /**\\n     * @notice Encode the CLB token ID of ERC1155 token type\\n     * @dev If `tradingFeeRate` is negative, it adds `DIRECTION_PRECISION` to the absolute fee rate.\\n     *      Otherwise it returns the fee rate directly.\\n     * @return id The ID of ERC1155 token\\n     */\\n    function encodeId(int16 tradingFeeRate) internal pure returns (uint256) {\\n        bool long = tradingFeeRate > 0;\\n        return _encodeId(uint16(long ? tradingFeeRate : -tradingFeeRate), long);\\n    }\\n\\n    /**\\n     * @notice Decode the trading fee rate from the CLB token ID of ERC1155 token type\\n     * @dev If `id` is greater than or equal to `DIRECTION_PRECISION`,\\n     *      then it substracts `DIRECTION_PRECISION` from `id`\\n     *      and returns the negation of the substracted value.\\n     *      Otherwise it returns `id` directly.\\n     * @return tradingFeeRate The trading fee rate\\n     */\\n    function decodeId(uint256 id) internal pure returns (int16 tradingFeeRate) {\\n        if (id >= DIRECTION_PRECISION) {\\n            tradingFeeRate = -int16((id - DIRECTION_PRECISION).toUint16());\\n        } else {\\n            tradingFeeRate = int16(id.toUint16());\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the array of supported trading fee rates.\\n     * @dev This function returns the array of supported trading fee rates,\\n     *      ranging from the minimum fee rate to the maximum fee rate with step increments.\\n     * @return tradingFeeRates The array of supported trading fee rates.\\n     */\\n    function tradingFeeRates() internal pure returns (uint16[FEE_RATES_LENGTH] memory) {\\n        // prettier-ignore\\n        return [\\n            MIN_FEE_RATE, 2, 3, 4, 5, 6, 7, 8, 9, // 0.01% ~ 0.09%, step 0.01%\\n            10, 20, 30, 40, 50, 60, 70, 80, 90, // 0.1% ~ 0.9%, step 0.1%\\n            100, 200, 300, 400, 500, 600, 700, 800, 900, // 1% ~ 9%, step 1%\\n            1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000 // 10% ~ 50%, step 5%\\n        ];\\n    }\\n\\n    function tokenIds() internal pure returns (uint256[] memory) {\\n        uint16[FEE_RATES_LENGTH] memory feeRates = tradingFeeRates();\\n\\n        uint256[] memory ids = new uint256[](FEE_RATES_LENGTH * 2);\\n        for (uint256 i; i < FEE_RATES_LENGTH; ) {\\n            ids[i] = _encodeId(feeRates[i], true);\\n            ids[i + FEE_RATES_LENGTH] = _encodeId(feeRates[i], false);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return ids;\\n    }\\n\\n    function _encodeId(uint16 tradingFeeRate, bool long) private pure returns (uint256 id) {\\n        id = long ? tradingFeeRate : tradingFeeRate + DIRECTION_PRECISION;\\n    }\\n}\\n\",\"keccak256\":\"0xbd995bde42a6162c1281d42e52a2def3bf74abbc97e12850d0577e405219ddca\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nuint256 constant BPS = 10000;\\nuint256 constant FEE_RATES_LENGTH = 36;\\n\",\"keccak256\":\"0x7090514076115048f25329d3a18a07456d07e1630c7e3ad13df01cb9f89e59de\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/DiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/******************************************************************************\\\\\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"@chromatic-protocol/contracts/core/interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nstruct DiamondStorage {\\n    // maps function selectors to the facets that execute the functions.\\n    // and maps the selectors to their position in the selectorSlots array.\\n    // func selector => address facet, selector position\\n    mapping(bytes4 => bytes32) facets;\\n    // array of slots of function selectors.\\n    // each slot holds 8 function selectors.\\n    mapping(uint256 => bytes32) selectorSlots;\\n    // The number of function selectors in selectorSlots\\n    uint16 selectorCount;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 => bool) supportedInterfaces;\\n}\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary DiamondStorageLib {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"protocol.chromatic.diamond.storage\\\");\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"DiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"DiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"DiamondCut: Can't add function that already exists\\\"\\n                );\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot =\\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"DiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(\\n                    oldFacetAddress != address(this),\\n                    \\\"DiamondCut: Can't replace immutable function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"DiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != address(0),\\n                    \\\"DiamondCut: Can't replace function that doesn't exist\\\"\\n                );\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(\\n                _newFacetAddress == address(0),\\n                \\\"DiamondCut: Remove facet address must be address(0)\\\"\\n            );\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"DiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"DiamondCut: Can't remove immutable function\\\"\\n                    );\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"DiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"DiamondCut: _init address has no code\\\");\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xef3a375a73c25c2b21063fbd8b18ce9e12b8bbd326ac98bda97cf07e9051d2fa\",\"license\":\"MIT\"},\"contracts/core/libraries/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title Errors\\n * @dev This library provides a set of error codes as string constants for handling exceptions and revert messages in the library.\\n */\\nlibrary Errors {\\n    /**\\n     * @dev Error code indicating that there is not enough free liquidity available in liquidity pool when open a new poisition.\\n     */\\n    string constant NOT_ENOUGH_FREE_LIQUIDITY = \\\"NEFL\\\";\\n\\n    /**\\n     * @dev Error code indicating that the specified amount is too small when add liquidity to each bin.\\n     */\\n    string constant TOO_SMALL_AMOUNT = \\\"TSA\\\";\\n\\n    /**\\n     * @dev Error code indicating that the provided oracle version is invalid or unsupported.\\n     */\\n    string constant INVALID_ORACLE_VERSION = \\\"IOV\\\";\\n\\n    /**\\n     * @dev Error code indicating that the specified value exceeds the allowed margin range when claim a position.\\n     */\\n    string constant EXCEED_MARGIN_RANGE = \\\"IOV\\\";\\n\\n    /**\\n     * @dev Error code indicating that the provided trading fee rate is not supported.\\n     */\\n    string constant UNSUPPORTED_TRADING_FEE_RATE = \\\"UTFR\\\";\\n\\n    /**\\n     * @dev Error code indicating that the oracle provider is already registered.\\n     */\\n    string constant ALREADY_REGISTERED_ORACLE_PROVIDER = \\\"ARO\\\";\\n\\n    /**\\n     * @dev Error code indicating that the settlement token is already registered.\\n     */\\n    string constant ALREADY_REGISTERED_TOKEN = \\\"ART\\\";\\n\\n    /**\\n     * @dev Error code indicating that the settlement token is not registered.\\n     */\\n    string constant UNREGISTERED_TOKEN = \\\"URT\\\";\\n\\n    /**\\n     * @dev Error code indicating that the interest rate has not been initialized.\\n     */\\n    string constant INTEREST_RATE_NOT_INITIALIZED = \\\"IRNI\\\";\\n\\n    /**\\n     * @dev Error code indicating that the provided interest rate exceeds the maximum allowed rate.\\n     */\\n    string constant INTEREST_RATE_OVERFLOW = \\\"IROF\\\";\\n\\n    /**\\n     * @dev Error code indicating that the provided timestamp for an interest rate is in the past.\\n     */\\n    string constant INTEREST_RATE_PAST_TIMESTAMP = \\\"IRPT\\\";\\n\\n    /**\\n     * @dev Error code indicating that the provided interest rate record cannot be appended to the existing array.\\n     */\\n    string constant INTEREST_RATE_NOT_APPENDABLE = \\\"IRNA\\\";\\n\\n    /**\\n     * @dev Error code indicating that an interest rate has already been applied and cannot be modified further.\\n     */\\n    string constant INTEREST_RATE_ALREADY_APPLIED = \\\"IRAA\\\";\\n\\n    /**\\n     * @dev Error code indicating that the position is unsettled.\\n     */\\n    string constant UNSETTLED_POSITION = \\\"USP\\\";\\n\\n    /**\\n     * @dev Error code indicating that the position quantity is invalid.\\n     */\\n    string constant INVALID_POSITION_QTY = \\\"IPQ\\\";\\n}\\n\",\"keccak256\":\"0x8274060a801595b98ed19b8fd68c37e4f49e78807842a32fe6b67166aff19494\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/InterestRate.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {BPS} from \\\"@chromatic-protocol/contracts/core/libraries/Constants.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title InterestRate\\n * @notice Provides functions for managing interest rates.\\n * @dev The library allows for the initialization, appending, and removal of interest rate records,\\n *      as well as calculating interest based on these records.\\n */\\nlibrary InterestRate {\\n    using Math for uint256;\\n\\n    /// @dev Record type\\n    struct Record {\\n        /// @dev Annual interest rate in BPS\\n        uint256 annualRateBPS;\\n        /// @dev Timestamp when the interest rate becomes effective\\n        uint256 beginTimestamp;\\n    }\\n\\n    uint256 private constant MAX_RATE_BPS = BPS; // max interest rate is 100%\\n    uint256 private constant YEAR = 365 * 24 * 3600;\\n\\n    /**\\n     * @dev Ensure that the interest rate records have been initialized before certain functions can be called.\\n     *      It checks whether the length of the Record array is greater than 0.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_NOT_INITIALIZED` if the array is empty (it indicates that the interest rate has not been initialized).\\n     */\\n    modifier initialized(Record[] storage self) {\\n        require(self.length != 0, Errors.INTEREST_RATE_NOT_INITIALIZED);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize the interest rate records.\\n     * @param self The stored record array\\n     * @param initialInterestRate The initial interest rate\\n     */\\n    function initialize(Record[] storage self, uint256 initialInterestRate) internal {\\n        self.push(Record({annualRateBPS: initialInterestRate, beginTimestamp: 0}));\\n    }\\n\\n    /**\\n     * @notice Add a new interest rate record to the array.\\n     * @dev Annual rate is not greater than the maximum rate and that the begin timestamp is in the future,\\n     *      and the new record's begin timestamp is greater than the previous record's timestamp.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_NOT_INITIALIZED` if the array is empty.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_OVERFLOW` if the rate exceed the maximum allowed rate (100%).\\n     *      Throws an error with the code `Errors.INTEREST_RATE_PAST_TIMESTAMP` if the timestamp is in the past, ensuring that the interest rate period has not already started.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_NOT_APPENDABLE` if the timestamp is greater than the last recorded timestamp, ensuring that the new record is appended in chronological order.\\n     * @param self The stored record array\\n     * @param annualRateBPS The annual interest rate in BPS\\n     * @param beginTimestamp Begin timestamp of this record\\n     */\\n    function appendRecord(\\n        Record[] storage self,\\n        uint256 annualRateBPS,\\n        uint256 beginTimestamp\\n    ) internal initialized(self) {\\n        require(annualRateBPS <= MAX_RATE_BPS, Errors.INTEREST_RATE_OVERFLOW);\\n        require(beginTimestamp > block.timestamp, Errors.INTEREST_RATE_PAST_TIMESTAMP);\\n\\n        Record memory lastRecord = self[self.length - 1];\\n        require(beginTimestamp > lastRecord.beginTimestamp, Errors.INTEREST_RATE_NOT_APPENDABLE);\\n\\n        self.push(Record({annualRateBPS: annualRateBPS, beginTimestamp: beginTimestamp}));\\n    }\\n\\n    /**\\n     * @notice Remove the last interest rate record from the array.\\n     * @dev The current time must be less than the begin timestamp of the last record.\\n     *      If the array has only one record, it returns false along with an empty record.\\n     *      Otherwise, it removes the last record from the array and returns true along with the removed record.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_NOT_INITIALIZED` if the array is empty.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_ALREADY_APPLIED` if the `beginTimestamp` of the last record is not in the future.\\n     * @param self The stored record array\\n     * @return removed Whether the last record is removed\\n     * @return record The removed record\\n     */\\n    function removeLastRecord(\\n        Record[] storage self\\n    ) internal initialized(self) returns (bool removed, Record memory record) {\\n        if (self.length <= 1) {\\n            // empty\\n            return (false, Record(0, 0));\\n        }\\n\\n        Record memory lastRecord = self[self.length - 1];\\n        require(block.timestamp < lastRecord.beginTimestamp, Errors.INTEREST_RATE_ALREADY_APPLIED);\\n\\n        self.pop();\\n\\n        return (true, lastRecord);\\n    }\\n\\n    /**\\n     * @notice Find the interest rate record that applies to a given timestamp.\\n     * @dev It iterates through the array from the end to the beginning\\n     *      and returns the first record with a begin timestamp less than or equal to the provided timestamp.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_NOT_INITIALIZED` if the array is empty.\\n     * @param self The stored record array\\n     * @param timestamp Given timestamp\\n     * @return interestRate The record which is found\\n     * @return index The index of record\\n     */\\n    function findRecordAt(\\n        Record[] storage self,\\n        uint256 timestamp\\n    ) internal view initialized(self) returns (Record memory interestRate, uint256 index) {\\n        for (uint256 i = self.length; i != 0; ) {\\n            unchecked {\\n                index = i - 1;\\n            }\\n            interestRate = self[index];\\n\\n            if (interestRate.beginTimestamp <= timestamp) {\\n                return (interestRate, index);\\n            }\\n\\n            unchecked {\\n                i--;\\n            }\\n        }\\n\\n        return (self[0], 0); // empty result (this line is not reachable)\\n    }\\n\\n    /**\\n     * @notice Calculate the interest\\n     * @dev Throws an error with the code `Errors.INTEREST_RATE_NOT_INITIALIZED` if the array is empty.\\n     * @param self The stored record array\\n     * @param amount Token amount\\n     * @param from Begin timestamp (inclusive)\\n     * @param to End timestamp (exclusive)\\n     */\\n    function calculateInterest(\\n        Record[] storage self,\\n        uint256 amount,\\n        uint256 from, // timestamp (inclusive)\\n        uint256 to // timestamp (exclusive)\\n    ) internal view initialized(self) returns (uint256) {\\n        if (from >= to) {\\n            return 0;\\n        }\\n\\n        uint256 interest = 0;\\n\\n        uint256 endTimestamp = type(uint256).max;\\n        for (uint256 idx = self.length; idx != 0; ) {\\n            Record memory record = self[idx - 1];\\n            if (endTimestamp <= from) {\\n                break;\\n            }\\n\\n            interest += _interest(\\n                amount,\\n                record.annualRateBPS,\\n                Math.min(to, endTimestamp) - Math.max(from, record.beginTimestamp)\\n            );\\n            endTimestamp = record.beginTimestamp;\\n\\n            unchecked {\\n                idx--;\\n            }\\n        }\\n        return interest;\\n    }\\n\\n    function _interest(\\n        uint256 amount,\\n        uint256 rateBPS, // annual rate\\n        uint256 period // in seconds\\n    ) private pure returns (uint256) {\\n        return amount.mulDiv(rateBPS * period, BPS * YEAR, Math.Rounding.Up);\\n    }\\n}\\n\",\"keccak256\":\"0xc17cef28ffbb3dbd05ad124d2aa691935db552b8374c7ef7d036df4e1c91e4b8\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/LpContext.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {IInterestCalculator} from \\\"@chromatic-protocol/contracts/core/interfaces/IInterestCalculator.sol\\\";\\nimport {IChromaticMarket} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarket.sol\\\";\\nimport {IChromaticVault} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticVault.sol\\\";\\nimport {ICLBToken} from \\\"@chromatic-protocol/contracts/core/interfaces/ICLBToken.sol\\\";\\n\\n/**\\n * @title LpContext\\n * @notice Represents the context information required for LP bin operations.\\n */\\nstruct LpContext {\\n    /// @dev The Oracle Provider contract used for price feed\\n    IOracleProvider oracleProvider;\\n    /// @dev The Interest Calculator contract used for interest calculations\\n    IInterestCalculator interestCalculator;\\n    /// @dev The Chromatic Vault contract responsible for managing liquidity and margin\\n    IChromaticVault vault;\\n    /// @dev The CLB token contract that represents LP ownership in the pool\\n    ICLBToken clbToken;\\n    /// @dev The address of market contract\\n    address market;\\n    /// @dev The address of the settlement token used in the market\\n    address settlementToken;\\n    /// @dev The precision of the settlement token used in the market\\n    uint256 tokenPrecision;\\n    /// @dev Cached instance of the current oracle version\\n    IOracleProvider.OracleVersion _currentVersionCache;\\n}\\n\\nusing LpContextLib for LpContext global;\\n\\n/**\\n * @title LpContextLib\\n * @notice Provides functions that operate on the `LpContext` struct\\n */\\nlibrary LpContextLib {\\n    /**\\n     * @notice Syncs the oracle version used by the market.\\n     * @param self The memory instance of `LpContext` struct\\n     */\\n    function syncOracleVersion(LpContext memory self) internal {\\n        self._currentVersionCache = self.oracleProvider.sync();\\n    }\\n\\n    /**\\n     * @notice Retrieves the current oracle version used by the market\\n     * @dev If the `_currentVersionCache` has been initialized, then returns it.\\n     *      If not, it calls the `currentVersion` function on the `oracleProvider of the market\\n     *      to fetch the current version and stores it in the cache,\\n     *      and then returns the current version.\\n     * @param self The memory instance of `LpContext` struct\\n     * @return OracleVersion The current oracle version\\n     */\\n    function currentOracleVersion(\\n        LpContext memory self\\n    ) internal view returns (IOracleProvider.OracleVersion memory) {\\n        if (self._currentVersionCache.version == 0) {\\n            self._currentVersionCache = self.oracleProvider.currentVersion();\\n        }\\n\\n        return self._currentVersionCache;\\n    }\\n\\n    /**\\n     * @notice Retrieves the oracle version at a specific version number\\n     * @dev If the `_currentVersionCache` matches the requested version, then returns it.\\n     *      Otherwise, it calls the `atVersion` function on the `oracleProvider` of the market\\n     *      to fetch the desired version.\\n     * @param self The memory instance of `LpContext` struct\\n     * @param version The requested version number\\n     * @return OracleVersion The oracle version at the requested version number\\n     */\\n    function oracleVersionAt(\\n        LpContext memory self,\\n        uint256 version\\n    ) internal view returns (IOracleProvider.OracleVersion memory) {\\n        if (self._currentVersionCache.version == version) {\\n            return self._currentVersionCache;\\n        }\\n        return self.oracleProvider.atVersion(version);\\n    }\\n\\n    /**\\n     * @notice Calculates the interest accrued for a given amount of settlement tokens\\n               within a specified time range.\\n     * @dev This function internally calls the `calculateInterest` function on the `interestCalculator` contract.\\n     * @param self The memory instance of the `LpContext` struct.\\n     * @param amount The amount of settlement tokens for which the interest needs to be calculated.\\n     * @param from The starting timestamp of the time range (inclusive).\\n     * @param to The ending timestamp of the time range (exclusive).\\n     * @return The accrued interest as a `uint256` value.\\n     */\\n    function calculateInterest(\\n        LpContext memory self,\\n        uint256 amount,\\n        uint256 from,\\n        uint256 to\\n    ) internal view returns (uint256) {\\n        return\\n            amount == 0 || from >= to\\n                ? 0\\n                : self.interestCalculator.calculateInterest(self.settlementToken, amount, from, to);\\n    }\\n\\n    /**\\n     * @notice Checks if an oracle version is in the past.\\n     * @param self The memory instance of the `LpContext` struct.\\n     * @param oracleVersion The oracle version to check.\\n     * @return A boolean value indicating whether the oracle version is in the past.\\n     */\\n    function isPastVersion(\\n        LpContext memory self,\\n        uint256 oracleVersion\\n    ) internal view returns (bool) {\\n        return oracleVersion != 0 && oracleVersion < self.currentOracleVersion().version;\\n    }\\n}\\n\",\"keccak256\":\"0x76a5e8a766b77fa27332250e2445b19d14713c6b9152797c073546929174200d\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/LpReceipt.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {CLBTokenLib} from \\\"@chromatic-protocol/contracts/core/libraries/CLBTokenLib.sol\\\";\\n\\n/**\\n * @dev The LpAction enum represents the types of LP actions that can be performed.\\n */\\nenum LpAction {\\n    ADD_LIQUIDITY,\\n    REMOVE_LIQUIDITY\\n}\\n\\n/**\\n * @title LpReceipt\\n * @notice The LpReceipt struct represents a receipt of an LP action performed.\\n */\\nstruct LpReceipt {\\n    /// @dev An identifier for the receipt\\n    uint256 id;\\n    /// @dev The oracle version associated with the action\\n    uint256 oracleVersion;\\n    /// @dev The amount involved in the action,\\n    ///      when the action is `ADD_LIQUIDITY`, this value represents the amount of settlement tokens\\n    ///      when the action is `REMOVE_LIQUIDITY`, this value represents the amount of CLB tokens\\n    uint256 amount;\\n    /// @dev The address of the recipient of the action\\n    address recipient;\\n    /// @dev An enumeration representing the type of LP action performed (ADD_LIQUIDITY or REMOVE_LIQUIDITY)\\n    LpAction action;\\n    /// @dev The trading fee rate associated with the LP action\\n    int16 tradingFeeRate;\\n}\\n\\nusing LpReceiptLib for LpReceipt global;\\n\\n/**\\n * @title LpReceiptLib\\n * @notice Provides functions that operate on the `LpReceipt` struct\\n */\\nlibrary LpReceiptLib {\\n    /**\\n     * @notice Computes the ID of the CLBToken contract based on the trading fee rate.\\n     * @param self The LpReceipt struct.\\n     * @return The ID of the CLBToken contract.\\n     */\\n    function clbTokenId(LpReceipt memory self) internal pure returns (uint256) {\\n        return CLBTokenLib.encodeId(self.tradingFeeRate);\\n    }\\n}\\n\",\"keccak256\":\"0x6273940c66b4be24987066a01490934163fda0f25b1b6bc4631472207a09e5e6\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/MarketStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport {IChromaticMarketFactory} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarketFactory.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {ICLBToken} from \\\"@chromatic-protocol/contracts/core/interfaces/ICLBToken.sol\\\";\\nimport {IChromaticLiquidator} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticLiquidator.sol\\\";\\nimport {IChromaticVault} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticVault.sol\\\";\\nimport {IKeeperFeePayer} from \\\"@chromatic-protocol/contracts/core/interfaces/IKeeperFeePayer.sol\\\";\\nimport {LiquidityPool} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/LiquidityPool.sol\\\";\\nimport {LpReceipt} from \\\"@chromatic-protocol/contracts/core/libraries/LpReceipt.sol\\\";\\nimport {Position} from \\\"@chromatic-protocol/contracts/core/libraries/Position.sol\\\";\\nimport {BinMargin} from \\\"@chromatic-protocol/contracts/core/libraries/BinMargin.sol\\\";\\n\\nstruct MarketStorage {\\n    IChromaticMarketFactory factory;\\n    IOracleProvider oracleProvider;\\n    IERC20Metadata settlementToken;\\n    ICLBToken clbToken;\\n    IChromaticLiquidator liquidator;\\n    IChromaticVault vault;\\n    IKeeperFeePayer keeperFeePayer;\\n    LiquidityPool liquidityPool;\\n    uint8 feeProtocol;\\n}\\n\\nstruct LpReceiptStorage {\\n    uint256 lpReceiptId;\\n    mapping(uint256 => LpReceipt) lpReceipts;\\n}\\n\\nstruct PositionStorage {\\n    uint256 positionId;\\n    mapping(uint256 => Position) positions;\\n}\\n\\nlibrary MarketStorageLib {\\n    bytes32 constant MARKET_STORAGE_POSITION = keccak256(\\\"protocol.chromatic.market.storage\\\");\\n\\n    function marketStorage() internal pure returns (MarketStorage storage ms) {\\n        bytes32 position = MARKET_STORAGE_POSITION;\\n        assembly {\\n            ms.slot := position\\n        }\\n    }\\n}\\n\\nusing LpReceiptStorageLib for LpReceiptStorage global;\\n\\nlibrary LpReceiptStorageLib {\\n    bytes32 constant LP_RECEIPT_STORAGE_POSITION =\\n        keccak256(\\\"protocol.chromatic.lpreceipt.storage\\\");\\n\\n    function lpReceiptStorage() internal pure returns (LpReceiptStorage storage ls) {\\n        bytes32 position = LP_RECEIPT_STORAGE_POSITION;\\n        assembly {\\n            ls.slot := position\\n        }\\n    }\\n\\n    function nextId(LpReceiptStorage storage self) internal returns (uint256 id) {\\n        id = ++self.lpReceiptId;\\n    }\\n\\n    function setReceipt(LpReceiptStorage storage self, LpReceipt memory receipt) internal {\\n        self.lpReceipts[receipt.id] = receipt;\\n    }\\n\\n    function getReceipt(\\n        LpReceiptStorage storage self,\\n        uint256 receiptId\\n    ) internal view returns (LpReceipt memory receipt) {\\n        receipt = self.lpReceipts[receiptId];\\n    }\\n\\n    function deleteReceipt(LpReceiptStorage storage self, uint256 receiptId) internal {\\n        delete self.lpReceipts[receiptId];\\n    }\\n\\n    function deleteReceipts(LpReceiptStorage storage self, uint256[] memory receiptIds) internal {\\n        for (uint256 i; i < receiptIds.length; ) {\\n            delete self.lpReceipts[receiptIds[i]];\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\nusing PositionStorageLib for PositionStorage global;\\n\\nlibrary PositionStorageLib {\\n    bytes32 constant POSITION_STORAGE_POSITION = keccak256(\\\"protocol.chromatic.position.storage\\\");\\n\\n    function positionStorage() internal pure returns (PositionStorage storage ls) {\\n        bytes32 position = POSITION_STORAGE_POSITION;\\n        assembly {\\n            ls.slot := position\\n        }\\n    }\\n\\n    function nextId(PositionStorage storage self) internal returns (uint256 id) {\\n        id = ++self.positionId;\\n    }\\n\\n    function setPosition(PositionStorage storage self, Position memory position) internal {\\n        Position storage _p = self.positions[position.id];\\n\\n        _p.id = position.id;\\n        _p.openVersion = position.openVersion;\\n        _p.closeVersion = position.closeVersion;\\n        _p.qty = position.qty;\\n        _p.openTimestamp = position.openTimestamp;\\n        _p.closeTimestamp = position.closeTimestamp;\\n        _p.leverage = position.leverage;\\n        _p.takerMargin = position.takerMargin;\\n        _p.owner = position.owner;\\n        _p._feeProtocol = position._feeProtocol;\\n        // can not convert memory array to storage array\\n        delete _p._binMargins;\\n        for (uint i; i < position._binMargins.length; ) {\\n            BinMargin memory binMargin = position._binMargins[i];\\n            if (binMargin.amount != 0) {\\n                _p._binMargins.push(position._binMargins[i]);\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function getPosition(\\n        PositionStorage storage self,\\n        uint256 positionId\\n    ) internal view returns (Position memory position) {\\n        position = self.positions[positionId];\\n    }\\n\\n    function getStoragePosition(\\n        PositionStorage storage self,\\n        uint256 positionId\\n    ) internal view returns (Position storage position) {\\n        position = self.positions[positionId];\\n    }\\n\\n    function deletePosition(PositionStorage storage self, uint256 positionId) internal {\\n        delete self.positions[positionId];\\n    }\\n}\\n\",\"keccak256\":\"0x4364dc27f7031baaf379249fb5ea5fac1be68610796aba4b009293bda9081229\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/Position.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {UFixed18} from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {PositionUtil, QTY_LEVERAGE_PRECISION} from \\\"@chromatic-protocol/contracts/core/libraries/PositionUtil.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {BinMargin} from \\\"@chromatic-protocol/contracts/core/libraries/BinMargin.sol\\\";\\n\\n/**\\n * @title Position\\n * @dev The Position struct represents a trading position.\\n */\\nstruct Position {\\n    /// @dev The position identifier\\n    uint256 id;\\n    /// @dev The version of the oracle when the position was opened\\n    uint256 openVersion;\\n    /// @dev The version of the oracle when the position was closed\\n    uint256 closeVersion;\\n    /// @dev The quantity of the position\\n    int224 qty;\\n    /// @dev The leverage applied to the position\\n    uint32 leverage;\\n    /// @dev The timestamp when the position was opened\\n    uint256 openTimestamp;\\n    /// @dev The timestamp when the position was closed\\n    uint256 closeTimestamp;\\n    /// @dev The amount of collateral that a trader must provide\\n    uint256 takerMargin;\\n    /// @dev The owner of the position, usually it is the account address of trader\\n    address owner;\\n    /// @dev The bin margins for the position, it represents the amount of collateral for each bin\\n    BinMargin[] _binMargins;\\n    /// @dev The protocol fee for the market\\n    uint8 _feeProtocol;\\n}\\n\\nusing PositionLib for Position global;\\n\\n/**\\n * @title PositionLib\\n * @notice Provides functions that operate on the `Position` struct\\n */\\nlibrary PositionLib {\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n\\n    /**\\n     * @notice Calculates the settle version for the position's entry\\n     * @param self The memory instance of the `Position` struct\\n     * @return utin256 The settle version for the position's entry\\n     */\\n    function entryVersion(Position memory self) internal pure returns (uint256) {\\n        return PositionUtil.settleVersion(self.openVersion);\\n    }\\n\\n    /**\\n     * @notice Calculates the settle version for the position's exit\\n     * @param self The memory instance of the `Position` struct\\n     * @return utin256 The settle version for the position's exit\\n     */\\n    function exitVersion(Position memory self) internal pure returns (uint256) {\\n        return PositionUtil.settleVersion(self.closeVersion);\\n    }\\n\\n    /**\\n     * @notice Calculates the leveraged quantity of the position\\n     *         based on the position's quantity and leverage\\n     * @param self The memory instance of the `Position` struct\\n     * @param ctx The context object for this transaction\\n     * @return uint256 The leveraged quantity\\n     */\\n    function leveragedQty(\\n        Position memory self,\\n        LpContext memory ctx\\n    ) internal pure returns (int256) {\\n        int256 qty = self.qty;\\n        int256 leveraged = qty\\n            .abs()\\n            .mulDiv(self.leverage * ctx.tokenPrecision, QTY_LEVERAGE_PRECISION)\\n            .toInt256();\\n        return qty < 0 ? -leveraged : leveraged;\\n    }\\n\\n    /**\\n     * @notice Calculates the entry price of the position based on the position's open oracle version\\n     * @dev It fetches oracle price from `IOracleProvider`\\n     *      at the settle version calculated based on the position's open oracle version\\n     * @param self The memory instance of the `Position` struct\\n     * @param ctx The context object for this transaction\\n     * @return UFixed18 The entry price\\n     */\\n    function entryPrice(\\n        Position memory self,\\n        LpContext memory ctx\\n    ) internal view returns (UFixed18) {\\n        return PositionUtil.settlePrice(ctx.oracleProvider, self.openVersion);\\n    }\\n\\n    /**\\n     * @notice Calculates the exit price of the position based on the position's close oracle version\\n     * @dev It fetches oracle price from `IOracleProvider`\\n     *      at the settle version calculated based on the position's close oracle version\\n     * @param self The memory instance of the `Position` struct\\n     * @param ctx The context object for this transaction\\n     * @return UFixed18 The exit price\\n     */\\n    function exitPrice(\\n        Position memory self,\\n        LpContext memory ctx\\n    ) internal view returns (UFixed18) {\\n        return PositionUtil.settlePrice(ctx.oracleProvider, self.closeVersion);\\n    }\\n\\n    /**\\n     * @notice Calculates the profit or loss of the position\\n     *         based on the close oracle version and the leveraged quantity\\n     * @param self The memory instance of the `Position` struct\\n     * @param ctx The context object for this transaction\\n     * @return int256 The profit or loss\\n     */\\n    function pnl(Position memory self, LpContext memory ctx) internal view returns (int256) {\\n        return\\n            self.closeVersion > self.openVersion\\n                ? PositionUtil.pnl(\\n                    self.leveragedQty(ctx),\\n                    self.entryPrice(ctx),\\n                    self.exitPrice(ctx)\\n                )\\n                : int256(0);\\n    }\\n\\n    /**\\n     * @notice Calculates the total margin required for the makers of the position\\n     * @dev The maker margin is calculated by summing up the amounts of all bin margins\\n     *      in the `_binMargins` array\\n     * @param self The memory instance of the `Position` struct\\n     * @return margin The maker margin\\n     */\\n    function makerMargin(Position memory self) internal pure returns (uint256 margin) {\\n        for (uint256 i; i < self._binMargins.length; ) {\\n            margin += self._binMargins[i].amount;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the total trading fee for the position\\n     * @dev The trading fee is calculated by summing up the trading fees of all bin margins\\n     *      in the `_binMargins` array\\n     * @param self The memory instance of the `Position` struct\\n     * @return fee The trading fee\\n     */\\n    function tradingFee(Position memory self) internal pure returns (uint256 fee) {\\n        for (uint256 i; i < self._binMargins.length; ) {\\n            fee += self._binMargins[i].tradingFee(self._feeProtocol);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the total protocol fee for a position.\\n     * @param self The Position struct representing the position.\\n     * @return fee The total protocol fee amount.\\n     */\\n    function protocolFee(Position memory self) internal pure returns (uint256 fee) {\\n        for (uint256 i; i < self._binMargins.length; ) {\\n            fee += self._binMargins[i].protocolFee(self._feeProtocol);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns an array of BinMargin instances\\n     *         representing the bin margins for the position\\n     * @param self The memory instance of the `Position` struct\\n     * @return margins The bin margins for the position\\n     */\\n    function binMargins(Position memory self) internal pure returns (BinMargin[] memory margins) {\\n        margins = self._binMargins;\\n    }\\n\\n    /**\\n     * @notice Sets the `_binMargins` array for the position\\n     * @param self The memory instance of the `Position` struct\\n     * @param margins The bin margins for the position\\n     */\\n    function setBinMargins(Position memory self, BinMargin[] memory margins) internal pure {\\n        self._binMargins = margins;\\n    }\\n}\\n\",\"keccak256\":\"0x4411c1063d08579754a456aff1549ce527c8032d9f0c6e508a2486f0268e0891\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/PositionUtil.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {Fixed18} from \\\"@equilibria/root/number/types/Fixed18.sol\\\";\\nimport {UFixed18, UFixed18Lib} from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\nuint256 constant QTY_DECIMALS = 4;\\nuint256 constant LEVERAGE_DECIMALS = 2;\\nuint256 constant QTY_PRECISION = 10 ** QTY_DECIMALS;\\nuint256 constant LEVERAGE_PRECISION = 10 ** LEVERAGE_DECIMALS;\\nuint256 constant QTY_LEVERAGE_PRECISION = QTY_PRECISION * LEVERAGE_PRECISION;\\n\\n/**\\n * @title PositionUtil\\n * @notice Provides utility functions for managing positions\\n */\\nlibrary PositionUtil {\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n\\n    /**\\n     * @notice Returns next oracle version to settle\\n     * @dev It adds 1 to the `oracleVersion`\\n     *      and ensures that the `oracleVersion` is greater than 0 using a require statement.\\n     *      Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if the `oracleVersion` is not valid.\\n     * @param oracleVersion Input oracle version\\n     * @return uint256 Next oracle version to settle\\n     */\\n    function settleVersion(uint256 oracleVersion) internal pure returns (uint256) {\\n        require(oracleVersion != 0, Errors.INVALID_ORACLE_VERSION);\\n        return oracleVersion + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates the price of the position based on the `oracleVersion` to settle\\n     * @dev It calls another overloaded `settlePrice` function\\n     *      with an additional `OracleVersion` parameter,\\n     *      passing the `currentVersion` obtained from the `provider`\\n     * @param provider The oracle provider\\n     * @param oracleVersion The oracle version of position\\n     * @return UFixed18 The calculated price to settle\\n     */\\n    function settlePrice(\\n        IOracleProvider provider,\\n        uint256 oracleVersion\\n    ) internal view returns (UFixed18) {\\n        return settlePrice(provider, oracleVersion, provider.currentVersion());\\n    }\\n\\n    /**\\n     * @notice Calculates the price of the position based on the `oracleVersion` to settle\\n     * @dev It calculates the price by considering the `settleVersion`\\n     *      and the `currentVersion` obtained from the `IOracleProvider`.\\n     *      It ensures that the settle version is not greater than the current version;\\n     *      otherwise, it triggers an error with the message `Errors.UNSETTLED_POSITION`.\\n     *      It retrieves the corresponding `OracleVersion` using `atVersion` from the `IOracleProvider`,\\n     *      and then calls `oraclePrice` to obtain the price.\\n     * @param provider The oracle provider\\n     * @param oracleVersion The oracle version of position\\n     * @param currentVersion The current oracle version\\n     * @return UFixed18 The calculated entry price to settle\\n     */\\n    function settlePrice(\\n        IOracleProvider provider,\\n        uint256 oracleVersion,\\n        IOracleProvider.OracleVersion memory currentVersion\\n    ) internal view returns (UFixed18) {\\n        uint256 _settleVersion = settleVersion(oracleVersion);\\n        require(_settleVersion <= currentVersion.version, Errors.UNSETTLED_POSITION);\\n\\n        IOracleProvider.OracleVersion memory _oracleVersion = _settleVersion ==\\n            currentVersion.version\\n            ? currentVersion\\n            : provider.atVersion(_settleVersion);\\n        return oraclePrice(_oracleVersion);\\n    }\\n\\n    /**\\n     * @notice Extracts the price value from an `OracleVersion` struct\\n     * @dev If the price is less than 0, it returns 0\\n     * @param oracleVersion The memory instance of `OracleVersion` struct\\n     * @return UFixed18 The price value of `oracleVersion`\\n     */\\n    function oraclePrice(\\n        IOracleProvider.OracleVersion memory oracleVersion\\n    ) internal pure returns (UFixed18) {\\n        return\\n            oracleVersion.price.sign() < 0\\n                ? UFixed18Lib.ZERO\\n                : UFixed18Lib.from(oracleVersion.price);\\n    }\\n\\n    /**\\n     * @notice Calculates the profit or loss (PnL) for a position\\n     *         based on the leveraged quantity, entry price, and exit price\\n     * @dev It first calculates the price difference (`delta`) between the exit price and the entry price.\\n     *      If the leveraged quantity is negative, indicating short position,\\n     *      it adjusts the `delta` to reflect a negative change.\\n     *      The function then calculates the absolute PnL\\n     *      by multiplying the absolute value of the leveraged quantity\\n     *      with the absolute value of the `delta`, divided by the entry price.\\n     *      Finally, if `delta` is negative, indicating a loss,\\n     *      the absolute PnL is negated to represent a negative value.\\n     * @param leveragedQty The leveraged quantity of the position\\n     * @param _entryPrice The entry price of the position\\n     * @param _exitPrice The exit price of the position\\n     * @return int256 The profit or loss\\n     */\\n    function pnl(\\n        int256 leveragedQty, // as token precision\\n        UFixed18 _entryPrice,\\n        UFixed18 _exitPrice\\n    ) internal pure returns (int256) {\\n        int256 delta = _exitPrice.gt(_entryPrice)\\n            ? UFixed18.unwrap(_exitPrice.sub(_entryPrice)).toInt256()\\n            : -UFixed18.unwrap(_entryPrice.sub(_exitPrice)).toInt256();\\n        if (leveragedQty < 0) delta *= -1;\\n\\n        int256 absPnl = leveragedQty\\n            .abs()\\n            .mulDiv(delta.abs(), UFixed18.unwrap(_entryPrice))\\n            .toInt256();\\n\\n        return delta < 0 ? -absPnl : absPnl;\\n    }\\n\\n    /**\\n     * @notice Verifies the validity of a position quantity added to the bin\\n     * @dev It ensures that the sign of the current quantity of the bin's position\\n     *      and the added quantity are same or zero.\\n     *      If the condition is not met, it triggers an error with the message `Errors.INVALID_POSITION_QTY`.\\n     * @param currentQty The current quantity of the bin's pending position\\n     * @param addedQty The position quantity added\\n     */\\n    function checkAddPositionQty(int256 currentQty, int256 addedQty) internal pure {\\n        require(\\n            !((currentQty > 0 && addedQty <= 0) || (currentQty < 0 && addedQty >= 0)),\\n            Errors.INVALID_POSITION_QTY\\n        );\\n    }\\n\\n    /**\\n     * @notice Verifies the validity of a position quantity removed from the bin\\n     * @dev It ensures that the sign of the current quantity of the bin's position\\n     *      and the removed quantity are same or zero,\\n     *      and the absolute removed quantity is not greater than the absolute current quantity.\\n     *      If the condition is not met, it triggers an error with the message `Errors.INVALID_POSITION_QTY`.\\n     * @param currentQty The current quantity of the bin's position\\n     * @param removeQty The position quantity removed\\n     */\\n    function checkRemovePositionQty(int256 currentQty, int256 removeQty) internal pure {\\n        require(\\n            !((currentQty == 0) ||\\n                (removeQty == 0) ||\\n                (currentQty > 0 && removeQty > currentQty) ||\\n                (currentQty < 0 && removeQty < currentQty)),\\n            Errors.INVALID_POSITION_QTY\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculates the transaction amount based on the leveraged quantity and price\\n     * @param leveragedQty The leveraged quantity of the position\\n     * @param price The price of the position\\n     * @return uint256 The transaction amount\\n     */\\n    function transactionAmount(\\n        int256 leveragedQty,\\n        UFixed18 price\\n    ) internal pure returns (uint256) {\\n        return leveragedQty.abs().mulDiv(UFixed18.unwrap(price), UFixed18.unwrap(UFixed18Lib.ONE));\\n    }\\n}\\n\",\"keccak256\":\"0x4b3cc90da5a99b48d4e6a045b197d51a07415d9a8f5ee95350ed6ce1830fb942\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/deployer/CLBTokenDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {CLBToken} from \\\"@chromatic-protocol/contracts/core/CLBToken.sol\\\";\\n\\n/**\\n * @title CLBTokenDeployerLib\\n * @notice Library for deploying CLB tokens\\n */\\nlibrary CLBTokenDeployerLib {\\n    /**\\n     * @notice Deploys a new CLB token\\n     * @return clbToken The address of the deployed CLB token\\n     */\\n    function deploy() external returns (address clbToken) {\\n        clbToken = address(new CLBToken());\\n    }\\n}\\n\",\"keccak256\":\"0xca5f3d8d390dffc4732594bdbd169ae783847c71673770c664b07073d70d4118\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/deployer/MarketDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/interfaces/IERC1155Receiver.sol\\\";\\nimport {IDiamondCut} from \\\"@chromatic-protocol/contracts/core/interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"@chromatic-protocol/contracts/core/interfaces/IDiamondLoupe.sol\\\";\\nimport {IMarketState} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketState.sol\\\";\\nimport {IMarketLiquidity} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidity.sol\\\";\\nimport {IMarketTrade} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketTrade.sol\\\";\\nimport {IMarketLiquidate} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidate.sol\\\";\\nimport {IMarketSettle} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketSettle.sol\\\";\\nimport {ChromaticMarket} from \\\"@chromatic-protocol/contracts/core/ChromaticMarket.sol\\\";\\n\\n/**\\n * @title MarketDeployer\\n * @notice Storage struct for deploying a ChromaticMarket contract\\n */\\nstruct MarketDeployer {\\n    Parameters parameters;\\n}\\n\\n/**\\n * @title Parameters\\n * @notice Struct for storing deployment parameters\\n */\\nstruct Parameters {\\n    address oracleProvider;\\n    address settlementToken;\\n}\\n\\n/**\\n * @title MarketDeployerLib\\n * @notice Library for deploying a ChromaticMarket contract\\n */\\nlibrary MarketDeployerLib {\\n    /**\\n     * @notice Deploys a ChromaticMarket contract\\n     * @param self The MarketDeployer storage\\n     * @param oracleProvider The address of the oracle provider\\n     * @param settlementToken The address of the settlement token\\n     * @param marketDiamondCutFacet The market diamond cut facet address.\\n     * @param marketLoupeFacet The market loupe facet address.\\n     * @param marketStateFacet The market state facet address.\\n     * @param marketLiquidityFacet The market liquidity facet address.\\n     * @param marketTradeFacet The market trade facet address.\\n     * @param marketLiquidateFacet The market liquidate facet address.\\n     * @param marketSettleFacet The market settle facet address.\\n     * @return market The address of the deployed ChromaticMarket contract\\n     */\\n    function deploy(\\n        MarketDeployer storage self,\\n        address oracleProvider,\\n        address settlementToken,\\n        address marketDiamondCutFacet,\\n        address marketLoupeFacet,\\n        address marketStateFacet,\\n        address marketLiquidityFacet,\\n        address marketTradeFacet,\\n        address marketLiquidateFacet,\\n        address marketSettleFacet\\n    ) external returns (address market) {\\n        self.parameters = Parameters({\\n            oracleProvider: oracleProvider,\\n            settlementToken: settlementToken\\n        });\\n        market = address(\\n            new ChromaticMarket{salt: keccak256(abi.encode(oracleProvider, settlementToken))}(\\n                marketDiamondCutFacet\\n            )\\n        );\\n        delete self.parameters;\\n\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](6);\\n        cut[0] = _marketLoupeFacetCut(marketLoupeFacet);\\n        cut[1] = _marketStateFacetCut(marketStateFacet);\\n        cut[2] = _marketLiquidityFacetCut(marketLiquidityFacet);\\n        cut[3] = _marketTradeFacetCut(marketTradeFacet);\\n        cut[4] = _marketLiquidateFacetCut(marketLiquidateFacet);\\n        cut[5] = _marketSettleFacetCut(marketSettleFacet);\\n        IDiamondCut(market).diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    function _marketLoupeFacetCut(\\n        address marketLoupeFacet\\n    ) private pure returns (IDiamondCut.FacetCut memory cut) {\\n        bytes4[] memory functionSelectors = new bytes4[](4);\\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\\n\\n        cut = IDiamondCut.FacetCut({\\n            facetAddress: marketLoupeFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n    }\\n\\n    function _marketStateFacetCut(\\n        address marketStateFacet\\n    ) private pure returns (IDiamondCut.FacetCut memory cut) {\\n        bytes4[] memory functionSelectors = new bytes4[](9);\\n        functionSelectors[0] = IMarketState.factory.selector;\\n        functionSelectors[1] = IMarketState.settlementToken.selector;\\n        functionSelectors[2] = IMarketState.oracleProvider.selector;\\n        functionSelectors[3] = IMarketState.clbToken.selector;\\n        functionSelectors[4] = IMarketState.liquidator.selector;\\n        functionSelectors[5] = IMarketState.vault.selector;\\n        functionSelectors[6] = IMarketState.keeperFeePayer.selector;\\n        functionSelectors[7] = IMarketState.feeProtocol.selector;\\n        functionSelectors[8] = IMarketState.setFeeProtocol.selector;\\n\\n        cut = IDiamondCut.FacetCut({\\n            facetAddress: marketStateFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n    }\\n\\n    function _marketLiquidityFacetCut(\\n        address marketLiquidityFacet\\n    ) private pure returns (IDiamondCut.FacetCut memory cut) {\\n        bytes4[] memory functionSelectors = new bytes4[](18);\\n        functionSelectors[0] = IMarketLiquidity.addLiquidity.selector;\\n        functionSelectors[1] = IMarketLiquidity.addLiquidityBatch.selector;\\n        functionSelectors[2] = IMarketLiquidity.claimLiquidity.selector;\\n        functionSelectors[3] = IMarketLiquidity.claimLiquidityBatch.selector;\\n        functionSelectors[4] = IMarketLiquidity.removeLiquidity.selector;\\n        functionSelectors[5] = IMarketLiquidity.removeLiquidityBatch.selector;\\n        functionSelectors[6] = IMarketLiquidity.withdrawLiquidity.selector;\\n        functionSelectors[7] = IMarketLiquidity.withdrawLiquidityBatch.selector;\\n        functionSelectors[8] = IMarketLiquidity.getBinLiquidity.selector;\\n        functionSelectors[9] = IMarketLiquidity.getBinFreeLiquidity.selector;\\n        functionSelectors[10] = IMarketLiquidity.getBinValues.selector;\\n        functionSelectors[11] = IMarketLiquidity.distributeEarningToBins.selector;\\n        functionSelectors[12] = IMarketLiquidity.getLpReceipt.selector;\\n        functionSelectors[13] = IMarketLiquidity.claimableLiquidity.selector;\\n        functionSelectors[14] = IMarketLiquidity.liquidityBinStatuses.selector;\\n        functionSelectors[15] = IERC1155Receiver.onERC1155Received.selector;\\n        functionSelectors[16] = IERC1155Receiver.onERC1155BatchReceived.selector;\\n        functionSelectors[17] = IERC165.supportsInterface.selector;\\n\\n        cut = IDiamondCut.FacetCut({\\n            facetAddress: marketLiquidityFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n    }\\n\\n    function _marketTradeFacetCut(\\n        address marketTradeFacet\\n    ) private pure returns (IDiamondCut.FacetCut memory cut) {\\n        bytes4[] memory functionSelectors = new bytes4[](4);\\n        functionSelectors[0] = IMarketTrade.openPosition.selector;\\n        functionSelectors[1] = IMarketTrade.closePosition.selector;\\n        functionSelectors[2] = IMarketTrade.claimPosition.selector;\\n        functionSelectors[3] = IMarketTrade.getPositions.selector;\\n\\n        cut = IDiamondCut.FacetCut({\\n            facetAddress: marketTradeFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n    }\\n\\n    function _marketLiquidateFacetCut(\\n        address marketLiquidateFacet\\n    ) private pure returns (IDiamondCut.FacetCut memory cut) {\\n        bytes4[] memory functionSelectors = new bytes4[](4);\\n        functionSelectors[0] = IMarketLiquidate.checkLiquidation.selector;\\n        functionSelectors[1] = IMarketLiquidate.liquidate.selector;\\n        functionSelectors[2] = IMarketLiquidate.checkClaimPosition.selector;\\n        functionSelectors[3] = IMarketLiquidate.claimPosition.selector;\\n\\n        cut = IDiamondCut.FacetCut({\\n            facetAddress: marketLiquidateFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n    }\\n\\n    function _marketSettleFacetCut(\\n        address marketSettleFacet\\n    ) private pure returns (IDiamondCut.FacetCut memory cut) {\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IMarketSettle.settle.selector;\\n\\n        cut = IDiamondCut.FacetCut({\\n            facetAddress: marketSettleFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x7152a00e38b8dcb3f6b4ee664bdfe229e8709b6b5040c7c47105e56f3642b0b7\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/AccruedInterest.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\n\\n/**\\n * @title AccruedInterest\\n * @notice Structure for tracking accumulated interest\\n */\\nstruct AccruedInterest {\\n    /// @dev The timestamp at which the interest was last accumulated.\\n    uint256 accumulatedAt;\\n    /// @dev The total amount of interest accumulated.\\n    uint256 accumulatedAmount;\\n}\\n\\n/**\\n * @title AccruedInterestLib\\n * @notice Tracks the accumulated interest for a given token amount and period of time\\n */\\nlibrary AccruedInterestLib {\\n    /**\\n     * @notice Accumulates interest for a given token amount and period of time\\n     * @param self The AccruedInterest storage\\n     * @param ctx The LpContext instance for interest calculation\\n     * @param tokenAmount The amount of tokens to calculate interest for\\n     * @param until The timestamp until which interest should be accumulated\\n     */\\n    function accumulate(\\n        AccruedInterest storage self,\\n        LpContext memory ctx,\\n        uint256 tokenAmount,\\n        uint256 until\\n    ) internal {\\n        uint256 accumulatedAt = self.accumulatedAt;\\n        // check if the interest is already accumulated for the given period of time.\\n        if (until <= accumulatedAt) return;\\n\\n        if (tokenAmount != 0) {\\n            // calculate the interest for the given period of time and accumulate it\\n            self.accumulatedAmount += ctx.calculateInterest(tokenAmount, accumulatedAt, until);\\n        }\\n        // update the timestamp at which the interest was last accumulated.\\n        self.accumulatedAt = until;\\n    }\\n\\n    /**\\n     * @notice Deducts interest from the accumulated interest.\\n     * @param self The AccruedInterest storage.\\n     * @param amount The amount of interest to deduct.\\n     */\\n    function deduct(AccruedInterest storage self, uint256 amount) internal {\\n        uint256 accumulatedAmount = self.accumulatedAmount;\\n        // check if the amount is greater than the accumulated interest.\\n        if (amount >= accumulatedAmount) {\\n            self.accumulatedAmount = 0;\\n        } else {\\n            self.accumulatedAmount = accumulatedAmount - amount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the accumulated interest for a given token amount and period of time\\n     * @param self The AccruedInterest storage\\n     * @param ctx The LpContext instance for interest calculation\\n     * @param tokenAmount The amount of tokens to calculate interest for\\n     * @param until The timestamp until which interest should be accumulated\\n     * @return The accumulated interest amount\\n     */\\n    function calculateInterest(\\n        AccruedInterest storage self,\\n        LpContext memory ctx,\\n        uint256 tokenAmount,\\n        uint256 until\\n    ) internal view returns (uint256) {\\n        if (tokenAmount == 0) return 0;\\n\\n        uint256 accumulatedAt = self.accumulatedAt;\\n        uint256 accumulatedAmount = self.accumulatedAmount;\\n        if (until <= accumulatedAt) return accumulatedAmount;\\n\\n        return accumulatedAmount + ctx.calculateInterest(tokenAmount, accumulatedAt, until);\\n    }\\n}\\n\",\"keccak256\":\"0xc980b38a1d354aed67fb0cbb3b1b07d7740c74fc4223b7181226daa0d982b174\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/BinClosedPosition.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {AccruedInterest, AccruedInterestLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/AccruedInterest.sol\\\";\\nimport {BinClosingPosition, BinClosingPositionLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/BinClosingPosition.sol\\\";\\nimport {PositionParam} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/PositionParam.sol\\\";\\nimport {PositionUtil} from \\\"@chromatic-protocol/contracts/core/libraries/PositionUtil.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\n\\n/**\\n * @title BinClosedPosition\\n * @notice Represents a closed position within an LiquidityBin.\\n */\\nstruct BinClosedPosition {\\n    uint256 _totalMakerMargin;\\n    uint256 _totalTakerMargin;\\n    BinClosingPosition _closing;\\n    EnumerableSet.UintSet _waitingVersions;\\n    mapping(uint256 => _ClaimWaitingPosition) _waitingPositions;\\n    AccruedInterest _accruedInterest;\\n}\\n\\n/**\\n * @title _ClaimWaitingPosition\\n * @notice Represents the accumulated values of the waiting positions to be claimed\\n *      for a specific version within BinClosedPosition.\\n */\\nstruct _ClaimWaitingPosition {\\n    int256 totalLeveragedQty;\\n    uint256 totalEntryAmount;\\n    uint256 totalMakerMargin;\\n    uint256 totalTakerMargin;\\n}\\n\\n/**\\n * @title BinClosedPositionLib\\n * @notice A library that provides functions to manage the closed position within an LiquidityBin.\\n */\\nlibrary BinClosedPositionLib {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using AccruedInterestLib for AccruedInterest;\\n    using BinClosingPositionLib for BinClosingPosition;\\n\\n    /**\\n     * @notice Settles the closing position within the BinClosedPosition.\\n     * @dev If the closeVersion is not set or is equal to the current oracle version, no action is taken.\\n     *      Otherwise, the waiting position is stored and the accrued interest is accumulated.\\n     * @param self The BinClosedPosition storage.\\n     * @param ctx The LpContext memory.\\n     */\\n    function settleClosingPosition(BinClosedPosition storage self, LpContext memory ctx) internal {\\n        uint256 closeVersion = self._closing.closeVersion;\\n        if (!ctx.isPastVersion(closeVersion)) return;\\n\\n        _ClaimWaitingPosition memory waitingPosition = _ClaimWaitingPosition({\\n            totalLeveragedQty: self._closing.totalLeveragedQty,\\n            totalEntryAmount: self._closing.totalEntryAmount,\\n            totalMakerMargin: self._closing.totalMakerMargin,\\n            totalTakerMargin: self._closing.totalTakerMargin\\n        });\\n\\n        // accumulate interest before update `_totalMakerMargin`\\n        self._accruedInterest.accumulate(ctx, self._totalMakerMargin, block.timestamp);\\n\\n        self._totalMakerMargin += waitingPosition.totalMakerMargin;\\n        self._totalTakerMargin += waitingPosition.totalTakerMargin;\\n        self._waitingVersions.add(closeVersion);\\n        self._waitingPositions[closeVersion] = waitingPosition;\\n\\n        self._closing.settleAccruedInterest(ctx);\\n        self._accruedInterest.accumulatedAmount += self._closing.accruedInterest.accumulatedAmount;\\n\\n        delete self._closing;\\n    }\\n\\n    /**\\n     * @notice Closes the position within the BinClosedPosition.\\n     * @dev Delegates the onClosePosition function call to the underlying BinClosingPosition.\\n     * @param self The BinClosedPosition storage.\\n     * @param ctx The LpContext memory.\\n     * @param param The PositionParam memory.\\n     */\\n    function onClosePosition(\\n        BinClosedPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        self._closing.onClosePosition(ctx, param);\\n    }\\n\\n    /**\\n     * @notice Claims the position within the BinClosedPosition.\\n     * @dev If the closeVersion is equal to the BinClosingPosition's closeVersion, the claim is made directly.\\n     *      Otherwise, the claim is made from the waiting position, and if exhausted, the waiting position is removed.\\n     *      The accrued interest is accumulated and deducted accordingly.\\n     * @param self The BinClosedPosition storage.\\n     * @param ctx The LpContext memory.\\n     * @param param The PositionParam memory.\\n     */\\n    function onClaimPosition(\\n        BinClosedPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        uint256 closeVersion = param.closeVersion;\\n\\n        if (closeVersion == self._closing.closeVersion) {\\n            self._closing.onClaimPosition(ctx, param);\\n        } else {\\n            bool exhausted = _onClaimPosition(self._waitingPositions[closeVersion], ctx, param);\\n\\n            // accumulate interest before update `_totalMakerMargin`\\n            self._accruedInterest.accumulate(ctx, self._totalMakerMargin, block.timestamp);\\n\\n            self._totalMakerMargin -= param.makerMargin;\\n            self._totalTakerMargin -= param.takerMargin;\\n            self._accruedInterest.deduct(param.calculateInterest(ctx, block.timestamp));\\n\\n            if (exhausted) {\\n                self._waitingVersions.remove(closeVersion);\\n                delete self._waitingPositions[closeVersion];\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Claims the position from the waiting position within the BinClosedPosition.\\n     *      Updates the waiting position and returns whether the waiting position is exhausted.\\n     * @param waitingPosition The waiting position storage.\\n     * @param ctx The LpContext memory.\\n     * @param param The PositionParam memory.\\n     * @return exhausted Whether the waiting position is exhausted.\\n     */\\n    function _onClaimPosition(\\n        _ClaimWaitingPosition storage waitingPosition,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) private returns (bool exhausted) {\\n        int256 totalLeveragedQty = waitingPosition.totalLeveragedQty;\\n        int256 leveragedQty = param.leveragedQty;\\n        PositionUtil.checkRemovePositionQty(totalLeveragedQty, leveragedQty);\\n        if (totalLeveragedQty == leveragedQty) return true;\\n\\n        waitingPosition.totalLeveragedQty = totalLeveragedQty - leveragedQty;\\n        waitingPosition.totalEntryAmount -= param.entryAmount(ctx);\\n        waitingPosition.totalMakerMargin -= param.makerMargin;\\n        waitingPosition.totalTakerMargin -= param.takerMargin;\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Returns the total maker margin for a liquidity bin closed position.\\n     * @param self The BinClosedPosition storage struct.\\n     * @return uint256 The total maker margin.\\n     */\\n    function totalMakerMargin(BinClosedPosition storage self) internal view returns (uint256) {\\n        return self._totalMakerMargin + self._closing.totalMakerMargin;\\n    }\\n\\n    /**\\n     * @notice Returns the total taker margin for a liquidity bin closed position.\\n     * @param self The BinClosedPosition storage struct.\\n     * @return uint256 The total taker margin.\\n     */\\n    function totalTakerMargin(BinClosedPosition storage self) internal view returns (uint256) {\\n        return self._totalTakerMargin + self._closing.totalTakerMargin;\\n    }\\n\\n    /**\\n     * @dev Calculates the current interest for a liquidity bin closed position.\\n     * @param self The BinClosedPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     * @return uint256 The current interest.\\n     */\\n    function currentInterest(\\n        BinClosedPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (uint256) {\\n        return _currentInterest(self, ctx) + self._closing.currentInterest(ctx);\\n    }\\n\\n    /**\\n     * @dev Calculates the current interest for a liquidity bin closed position without closing position.\\n     * @param self The BinClosedPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     * @return uint256 The current interest.\\n     */\\n    function _currentInterest(\\n        BinClosedPosition storage self,\\n        LpContext memory ctx\\n    ) private view returns (uint256) {\\n        return\\n            self._accruedInterest.calculateInterest(ctx, self._totalMakerMargin, block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0x4c3d4252a71aeee14cdf0093ff839ec23a26a03f7e8fd4c0b5397fcb19a999cb\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/BinClosingPosition.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {AccruedInterest, AccruedInterestLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/AccruedInterest.sol\\\";\\nimport {PositionParam} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/PositionParam.sol\\\";\\nimport {PositionUtil} from \\\"@chromatic-protocol/contracts/core/libraries/PositionUtil.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title BinClosingPosition\\n * @dev Represents the closing position within an LiquidityBin.\\n */\\nstruct BinClosingPosition {\\n    /// @dev The oracle version when the position was closed.\\n    uint256 closeVersion;\\n    /// @dev The total leveraged quantity of the closing position.\\n    int256 totalLeveragedQty;\\n    /// @dev The total entry amount of the closing position.\\n    uint256 totalEntryAmount;\\n    /// @dev The total maker margin of the closing position.\\n    uint256 totalMakerMargin;\\n    /// @dev The total taker margin of the closing position.\\n    uint256 totalTakerMargin;\\n    /// @dev The accumulated interest of the closing position.\\n    AccruedInterest accruedInterest;\\n}\\n\\n/**\\n * @title BinClosingPositionLib\\n * @notice A library that provides functions to manage the closing position within an LiquidityBin.\\n */\\nlibrary BinClosingPositionLib {\\n    using AccruedInterestLib for AccruedInterest;\\n\\n    /**\\n     * @notice Settles the accumulated interest of the closing position.\\n     * @param self The BinClosingPosition storage.\\n     * @param ctx The LpContext.\\n     */\\n    function settleAccruedInterest(BinClosingPosition storage self, LpContext memory ctx) internal {\\n        self.accruedInterest.accumulate(ctx, self.totalMakerMargin, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Handles the closing of a position.\\n     * @dev Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if the `closeVersion` is not valid.\\n     * @param self The BinClosingPosition storage.\\n     * @param ctx The LpContext.\\n     * @param param The position parameters.\\n     */\\n    function onClosePosition(\\n        BinClosingPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        uint256 closeVersion = self.closeVersion;\\n        require(\\n            closeVersion == 0 || closeVersion == param.closeVersion,\\n            Errors.INVALID_ORACLE_VERSION\\n        );\\n\\n        int256 totalLeveragedQty = self.totalLeveragedQty;\\n        int256 leveragedQty = param.leveragedQty;\\n        PositionUtil.checkAddPositionQty(totalLeveragedQty, leveragedQty);\\n\\n        // accumulate interest before update `totalMakerMargin`\\n        settleAccruedInterest(self, ctx);\\n\\n        self.closeVersion = param.closeVersion;\\n        self.totalLeveragedQty = totalLeveragedQty + leveragedQty;\\n        self.totalEntryAmount += param.entryAmount(ctx);\\n        self.totalMakerMargin += param.makerMargin;\\n        self.totalTakerMargin += param.takerMargin;\\n        self.accruedInterest.accumulatedAmount += param.calculateInterest(ctx, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Handles the claiming of a position.\\n     * @dev Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if the `closeVersion` is not valid.\\n     * @param self The BinPendingPosition storage.\\n     * @param ctx The LpContext.\\n     * @param param The position parameters.\\n     */\\n    function onClaimPosition(\\n        BinClosingPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        require(self.closeVersion == param.closeVersion, Errors.INVALID_ORACLE_VERSION);\\n\\n        int256 totalLeveragedQty = self.totalLeveragedQty;\\n        int256 leveragedQty = param.leveragedQty;\\n        PositionUtil.checkRemovePositionQty(totalLeveragedQty, leveragedQty);\\n\\n        // accumulate interest before update `totalMakerMargin`\\n        settleAccruedInterest(self, ctx);\\n\\n        self.totalLeveragedQty = totalLeveragedQty - leveragedQty;\\n        self.totalEntryAmount -= param.entryAmount(ctx);\\n        self.totalMakerMargin -= param.makerMargin;\\n        self.totalTakerMargin -= param.takerMargin;\\n        self.accruedInterest.deduct(param.calculateInterest(ctx, block.timestamp));\\n    }\\n\\n    /**\\n     * @notice Calculates the current accrued interest of the closing position.\\n     * @param self The BinClosingPosition storage.\\n     * @param ctx The LpContext.\\n     * @return uint256 The current accrued interest.\\n     */\\n    function currentInterest(\\n        BinClosingPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (uint256) {\\n        return self.accruedInterest.calculateInterest(ctx, self.totalMakerMargin, block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0x0dc51747c3d812ac20d8e3a54bc41ec1b50e8b9f24c37616a7375bfe7e06c84b\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/BinLiquidity.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {DoubleEndedQueue} from \\\"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {ICLBToken} from \\\"@chromatic-protocol/contracts/core/interfaces/ICLBToken.sol\\\";\\nimport {IMarketLiquidity} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidity.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title BinLiquidity\\n * @notice Represents the liquidity information within an LiquidityBin.\\n */\\nstruct BinLiquidity {\\n    uint256 total;\\n    _PendingLiquidity _pending;\\n    mapping(uint256 => _ClaimMinting) _claimMintings;\\n    mapping(uint256 => _ClaimBurning) _claimBurnings;\\n    DoubleEndedQueue.Bytes32Deque _burningVersions;\\n}\\n\\n/**\\n * @title _PendingLiquidity\\n * @notice Represents the pending liquidity details within BinLiquidity.\\n */\\nstruct _PendingLiquidity {\\n    uint256 oracleVersion;\\n    uint256 tokenAmount;\\n    uint256 clbTokenAmount;\\n}\\n\\n/**\\n * @title _ClaimMinting\\n * @notice Represents the accumulated values of minting claims\\n *         for a specific oracle version within BinLiquidity.\\n */\\nstruct _ClaimMinting {\\n    uint256 tokenAmountRequested;\\n    uint256 clbTokenAmount;\\n}\\n\\n/**\\n * @title _ClaimBurning\\n * @notice Represents the accumulated values of burning claims\\n *         for a specific oracle version within BinLiquidity.\\n */\\nstruct _ClaimBurning {\\n    uint256 clbTokenAmountRequested;\\n    uint256 clbTokenAmount;\\n    uint256 tokenAmount;\\n}\\n\\n/**\\n * @title BinLiquidityLib\\n * @notice A library that provides functions to manage the liquidity within an LiquidityBin.\\n */\\nlibrary BinLiquidityLib {\\n    using Math for uint256;\\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\\n\\n    /// @dev Minimum amount constant to prevent division by zero.\\n    uint256 private constant MIN_AMOUNT = 1000;\\n\\n    /**\\n     * @notice Settles the pending liquidity within the BinLiquidity.\\n     * @dev This function settles pending liquidity in the BinLiquidity storage by performing the following steps:\\n     *      1. Settles pending liquidity\\n     *          - If the pending oracle version is not set or is greater than or equal to the current oracle version,\\n     *            no action is taken.\\n     *          - Otherwise, the pending liquidity and burning CLB tokens are settled by following steps:\\n     *              a. If there is a pending deposit,\\n     *                 it calculates the minting amount of CLB tokens\\n     *                 based on the pending deposit, bin value, and CLB token total supply.\\n     *                 It updates the total liquidity and adds the pending deposit to the claim mintings.\\n     *              b. If there is a pending CLB token burning,\\n     *                 it adds the oracle version to the burning versions list\\n     *                 and initializes the claim burning details.\\n     *      2. Settles bunding CLB tokens\\n     *          a. It trims all completed burning versions from the burning versions list.\\n     *          b. For each burning version in the list,\\n     *             it calculates the pending CLB token amount and the pending withdrawal amount\\n     *             based on the bin value and CLB token total supply.\\n     *             - If there is sufficient free liquidity, it calculates the burning amount of CLB tokens.\\n     *             - If there is insufficient free liquidity, it calculates the burning amount\\n     *               based on the available free liquidity and updates the pending withdrawal accordingly.\\n     *          c. It updates the burning amount and pending withdrawal,\\n     *             and reduces the free liquidity accordingly.\\n     *          d. Finally, it updates the total liquidity by subtracting the pending withdrawal.\\n     *      And the CLB tokens are minted or burned accordingly.\\n     *      The pending deposit and withdrawal amounts are passed to the vault for further processing.\\n     * @param self The BinLiquidity storage.\\n     * @param ctx The LpContext memory.\\n     * @param binValue The current value of the bin.\\n     * @param freeLiquidity The amount of free liquidity available in the bin.\\n     * @param clbTokenId The ID of the CLB token.\\n     */\\n    function settlePendingLiquidity(\\n        BinLiquidity storage self,\\n        LpContext memory ctx,\\n        uint256 binValue,\\n        uint256 freeLiquidity,\\n        uint256 clbTokenId\\n    ) internal {\\n        ICLBToken clbToken = ctx.clbToken;\\n        uint256 totalSupply = clbToken.totalSupply(clbTokenId);\\n\\n        (uint256 pendingDeposit, uint256 mintingAmount) = _settlePending(\\n            self,\\n            ctx,\\n            binValue,\\n            totalSupply\\n        );\\n        (uint256 burningAmount, uint256 pendingWithdrawal) = _settleBurning(\\n            self,\\n            freeLiquidity + pendingDeposit,\\n            binValue,\\n            totalSupply\\n        );\\n\\n        if (mintingAmount > burningAmount) {\\n            clbToken.mint(ctx.market, clbTokenId, mintingAmount - burningAmount, bytes(\\\"\\\"));\\n        } else if (mintingAmount < burningAmount) {\\n            clbToken.burn(ctx.market, clbTokenId, burningAmount - mintingAmount);\\n        }\\n\\n        if (pendingDeposit != 0 || pendingWithdrawal != 0) {\\n            ctx.vault.onSettlePendingLiquidity(\\n                ctx.settlementToken,\\n                pendingDeposit,\\n                pendingWithdrawal\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds liquidity to the BinLiquidity.\\n     * @dev Sets the pending liquidity with the specified amount and oracle version.\\n     *      Throws an error with the code `Errors.TOO_SMALL_AMOUNT` if the amount is too small.\\n     *      Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if there is already pending liquidity with a different oracle version, it reverts with an error.\\n     * @param self The BinLiquidity storage.\\n     * @param amount The amount of tokens to add for liquidity.\\n     * @param oracleVersion The oracle version associated with the liquidity.\\n     */\\n    function onAddLiquidity(\\n        BinLiquidity storage self,\\n        uint256 amount,\\n        uint256 oracleVersion\\n    ) internal {\\n        require(amount > MIN_AMOUNT, Errors.TOO_SMALL_AMOUNT);\\n\\n        uint256 pendingOracleVersion = self._pending.oracleVersion;\\n        require(\\n            pendingOracleVersion == 0 || pendingOracleVersion == oracleVersion,\\n            Errors.INVALID_ORACLE_VERSION\\n        );\\n\\n        self._pending.oracleVersion = oracleVersion;\\n        self._pending.tokenAmount += amount;\\n    }\\n\\n    /**\\n     * @notice Claims liquidity from the BinLiquidity by minting CLB tokens.\\n     * @dev Retrieves the minting details for the specified oracle version\\n     *      and calculates the CLB token amount to be claimed.\\n     *      Updates the claim minting details and returns the CLB token amount to be claimed.\\n     *      If there are no more tokens remaining for the claim, it is removed from the mapping.\\n     * @param self The BinLiquidity storage.\\n     * @param amount The amount of tokens to claim.\\n     * @param oracleVersion The oracle version associated with the claim.\\n     * @return clbTokenAmount The amount of CLB tokens to be claimed.\\n     */\\n    function onClaimLiquidity(\\n        BinLiquidity storage self,\\n        uint256 amount,\\n        uint256 oracleVersion\\n    ) internal returns (uint256 clbTokenAmount) {\\n        _ClaimMinting memory _cm = self._claimMintings[oracleVersion];\\n        clbTokenAmount = amount.mulDiv(_cm.clbTokenAmount, _cm.tokenAmountRequested);\\n\\n        _cm.clbTokenAmount -= clbTokenAmount;\\n        _cm.tokenAmountRequested -= amount;\\n        if (_cm.tokenAmountRequested == 0) {\\n            delete self._claimMintings[oracleVersion];\\n        } else {\\n            self._claimMintings[oracleVersion] = _cm;\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes liquidity from the BinLiquidity by setting pending CLB token amount.\\n     * @dev Sets the pending liquidity with the specified CLB token amount and oracle version.\\n     *      Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if there is already pending liquidity with a different oracle version, it reverts with an error.\\n     * @param self The BinLiquidity storage.\\n     * @param clbTokenAmount The amount of CLB tokens to remove liquidity.\\n     * @param oracleVersion The oracle version associated with the liquidity.\\n     */\\n    function onRemoveLiquidity(\\n        BinLiquidity storage self,\\n        uint256 clbTokenAmount,\\n        uint256 oracleVersion\\n    ) internal {\\n        uint256 pendingOracleVersion = self._pending.oracleVersion;\\n        require(\\n            pendingOracleVersion == 0 || pendingOracleVersion == oracleVersion,\\n            Errors.INVALID_ORACLE_VERSION\\n        );\\n\\n        self._pending.oracleVersion = oracleVersion;\\n        self._pending.clbTokenAmount += clbTokenAmount;\\n    }\\n\\n    /**\\n     * @notice Withdraws liquidity from the BinLiquidity by burning CLB tokens and withdrawing tokens.\\n     * @dev Retrieves the burning details for the specified oracle version\\n     *      and calculates the CLB token amount and token amount to burn and withdraw, respectively.\\n     *      Updates the claim burning details and returns the token amount to withdraw and the burned CLB token amount.\\n     *      If there are no more CLB tokens remaining for the claim, it is removed from the mapping.\\n     * @param self The BinLiquidity storage.\\n     * @param clbTokenAmount The amount of CLB tokens to withdraw.\\n     * @param oracleVersion The oracle version associated with the claim.\\n     * @return amount The amount of tokens to be withdrawn for the claim.\\n     * @return burnedCLBTokenAmount The amount of CLB tokens to be burned for the claim.\\n     */\\n    function onWithdrawLiquidity(\\n        BinLiquidity storage self,\\n        uint256 clbTokenAmount,\\n        uint256 oracleVersion\\n    ) internal returns (uint256 amount, uint256 burnedCLBTokenAmount) {\\n        _ClaimBurning memory _cb = self._claimBurnings[oracleVersion];\\n        amount = clbTokenAmount.mulDiv(_cb.tokenAmount, _cb.clbTokenAmountRequested);\\n        burnedCLBTokenAmount = clbTokenAmount.mulDiv(\\n            _cb.clbTokenAmount,\\n            _cb.clbTokenAmountRequested\\n        );\\n\\n        _cb.clbTokenAmount -= burnedCLBTokenAmount;\\n        _cb.tokenAmount -= amount;\\n        _cb.clbTokenAmountRequested -= clbTokenAmount;\\n        if (_cb.clbTokenAmountRequested == 0) {\\n            delete self._claimBurnings[oracleVersion];\\n        } else {\\n            self._claimBurnings[oracleVersion] = _cb;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the amount of CLB tokens to be minted\\n     *         for a given token amount, bin value, and CLB token total supply.\\n     * @dev If the CLB token total supply is zero, returns the token amount as is.\\n     *      Otherwise, calculates the minting amount\\n     *      based on the token amount, bin value, and CLB token total supply.\\n     * @param amount The amount of tokens to be minted.\\n     * @param binValue The current bin value.\\n     * @param clbTokenTotalSupply The total supply of CLB tokens.\\n     * @return The amount of CLB tokens to be minted.\\n     */\\n    function calculateCLBTokenMinting(\\n        uint256 amount,\\n        uint256 binValue,\\n        uint256 clbTokenTotalSupply\\n    ) internal pure returns (uint256) {\\n        return\\n            clbTokenTotalSupply == 0\\n                ? amount\\n                : amount.mulDiv(clbTokenTotalSupply, binValue < MIN_AMOUNT ? MIN_AMOUNT : binValue);\\n    }\\n\\n    /**\\n     * @notice Calculates the value of CLB tokens\\n     *         for a given CLB token amount, bin value, and CLB token total supply.\\n     * @dev If the CLB token total supply is zero, returns zero.\\n     *      Otherwise, calculates the value based on the CLB token amount, bin value, and CLB token total supply.\\n     * @param clbTokenAmount The amount of CLB tokens.\\n     * @param binValue The current bin value.\\n     * @param clbTokenTotalSupply The total supply of CLB tokens.\\n     * @return The value of the CLB tokens.\\n     */\\n    function calculateCLBTokenValue(\\n        uint256 clbTokenAmount,\\n        uint256 binValue,\\n        uint256 clbTokenTotalSupply\\n    ) internal pure returns (uint256) {\\n        return clbTokenTotalSupply == 0 ? 0 : clbTokenAmount.mulDiv(binValue, clbTokenTotalSupply);\\n    }\\n\\n    /**\\n     * @dev Settles the pending deposit and pending CLB token burning.\\n     * @param self The BinLiquidity storage.\\n     * @param ctx The LpContext.\\n     * @param binValue The current value of the bin.\\n     * @param totalSupply The total supply of CLB tokens.\\n     * @return pendingDeposit The amount of pending deposit to be settled.\\n     * @return mintingAmount The calculated minting amount of CLB tokens for the pending deposit.\\n     */\\n    function _settlePending(\\n        BinLiquidity storage self,\\n        LpContext memory ctx,\\n        uint256 binValue,\\n        uint256 totalSupply\\n    ) private returns (uint256 pendingDeposit, uint256 mintingAmount) {\\n        uint256 oracleVersion = self._pending.oracleVersion;\\n        if (!ctx.isPastVersion(oracleVersion)) return (0, 0);\\n\\n        pendingDeposit = self._pending.tokenAmount;\\n        uint256 pendingCLBTokenAmount = self._pending.clbTokenAmount;\\n\\n        if (pendingDeposit != 0) {\\n            mintingAmount = calculateCLBTokenMinting(pendingDeposit, binValue, totalSupply);\\n\\n            self.total += pendingDeposit;\\n            self._claimMintings[oracleVersion] = _ClaimMinting({\\n                tokenAmountRequested: pendingDeposit,\\n                clbTokenAmount: mintingAmount\\n            });\\n        }\\n\\n        if (pendingCLBTokenAmount != 0) {\\n            self._burningVersions.pushBack(bytes32(oracleVersion));\\n            self._claimBurnings[oracleVersion] = _ClaimBurning({\\n                clbTokenAmountRequested: pendingCLBTokenAmount,\\n                clbTokenAmount: 0,\\n                tokenAmount: 0\\n            });\\n        }\\n\\n        delete self._pending;\\n    }\\n\\n    /**\\n     * @dev Settles the pending CLB token burning and calculates the burning amount and pending withdrawal.\\n     * @param self The BinLiquidity storage.\\n     * @param freeLiquidity The amount of free liquidity available for burning.\\n     * @param binValue The current value of the bin.\\n     * @param totalSupply The total supply of CLB tokens.\\n     * @return burningAmount The calculated burning amount of CLB tokens.\\n     * @return pendingWithdrawal The calculated pending withdrawal amount.\\n     */\\n    function _settleBurning(\\n        BinLiquidity storage self,\\n        uint256 freeLiquidity,\\n        uint256 binValue,\\n        uint256 totalSupply\\n    ) private returns (uint256 burningAmount, uint256 pendingWithdrawal) {\\n        // trim all claim completed burning versions\\n        while (!self._burningVersions.empty()) {\\n            uint256 _ov = uint256(self._burningVersions.front());\\n            _ClaimBurning memory _cb = self._claimBurnings[_ov];\\n            if (_cb.clbTokenAmount >= _cb.clbTokenAmountRequested) {\\n                self._burningVersions.popFront();\\n                if (_cb.clbTokenAmountRequested == 0) {\\n                    delete self._claimBurnings[_ov];\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        uint256 length = self._burningVersions.length();\\n        for (uint256 i; i < length && freeLiquidity != 0; ) {\\n            uint256 _ov = uint256(self._burningVersions.at(i));\\n            _ClaimBurning storage _cb = self._claimBurnings[_ov];\\n\\n            uint256 _pendingCLBTokenAmount = _cb.clbTokenAmountRequested - _cb.clbTokenAmount;\\n            if (_pendingCLBTokenAmount != 0) {\\n                uint256 _burningAmount;\\n                uint256 _pendingWithdrawal = calculateCLBTokenValue(\\n                    _pendingCLBTokenAmount,\\n                    binValue,\\n                    totalSupply\\n                );\\n\\n                if (freeLiquidity >= _pendingWithdrawal) {\\n                    _burningAmount = _pendingCLBTokenAmount;\\n                } else {\\n                    _burningAmount = calculateCLBTokenMinting(freeLiquidity, binValue, totalSupply);\\n                    require(_burningAmount < _pendingCLBTokenAmount);\\n                    _pendingWithdrawal = freeLiquidity;\\n                }\\n\\n                _cb.clbTokenAmount += _burningAmount;\\n                _cb.tokenAmount += _pendingWithdrawal;\\n                burningAmount += _burningAmount;\\n                pendingWithdrawal += _pendingWithdrawal;\\n                freeLiquidity -= _pendingWithdrawal;\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        self.total -= pendingWithdrawal;\\n    }\\n\\n    /**\\n     * @dev Retrieves the claimable liquidity information for a specific oracle version.\\n     * @param self The reference to the BinLiquidity struct.\\n     * @param oracleVersion The oracle version for which to retrieve the claimable liquidity.\\n     * @return claimableLiquidity An instance of IMarketLiquidity.ClaimableLiquidity representing the claimable liquidity information.\\n     */\\n    function claimableLiquidity(\\n        BinLiquidity storage self,\\n        uint256 oracleVersion\\n    ) internal view returns (IMarketLiquidity.ClaimableLiquidity memory) {\\n        _ClaimMinting memory _cm = self._claimMintings[oracleVersion];\\n        _ClaimBurning memory _cb = self._claimBurnings[oracleVersion];\\n\\n        return\\n            IMarketLiquidity.ClaimableLiquidity({\\n                mintingTokenAmountRequested: _cm.tokenAmountRequested,\\n                mintingCLBTokenAmount: _cm.clbTokenAmount,\\n                burningCLBTokenAmountRequested: _cb.clbTokenAmountRequested,\\n                burningCLBTokenAmount: _cb.clbTokenAmount,\\n                burningTokenAmount: _cb.tokenAmount\\n            });\\n    }\\n}\\n\",\"keccak256\":\"0x9266900a19739e4f9a314c7c643a75f5c7681caf39e0a165dd6053cab00aa1a9\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/BinPendingPosition.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {UFixed18} from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {AccruedInterest, AccruedInterestLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/AccruedInterest.sol\\\";\\nimport {PositionParam} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/PositionParam.sol\\\";\\nimport {PositionUtil} from \\\"@chromatic-protocol/contracts/core/libraries/PositionUtil.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title BinPendingPosition\\n * @notice Represents a pending position within the LiquidityBin\\n */\\nstruct BinPendingPosition {\\n    /// @dev The oracle version when the position was opened.\\n    uint256 openVersion;\\n    /// @dev The total leveraged quantity of the pending position.\\n    int256 totalLeveragedQty;\\n    /// @dev The total maker margin of the pending position.\\n    uint256 totalMakerMargin;\\n    /// @dev The total taker margin of the pending position.\\n    uint256 totalTakerMargin;\\n    /// @dev The accumulated interest of the pending position.\\n    AccruedInterest accruedInterest;\\n}\\n\\n/**\\n * @title BinPendingPositionLib\\n * @notice Library for managing pending positions in the `LiquidityBin`\\n */\\nlibrary BinPendingPositionLib {\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n    using AccruedInterestLib for AccruedInterest;\\n\\n    /**\\n     * @notice Settles the accumulated interest of the pending position.\\n     * @param self The BinPendingPosition storage.\\n     * @param ctx The LpContext.\\n     */\\n    function settleAccruedInterest(BinPendingPosition storage self, LpContext memory ctx) internal {\\n        self.accruedInterest.accumulate(ctx, self.totalMakerMargin, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Handles the opening of a position.\\n     * @dev Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if the `openVersion` is not valid.\\n     * @param self The BinPendingPosition storage.\\n     * @param param The position parameters.\\n     */\\n    function onOpenPosition(\\n        BinPendingPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        uint256 openVersion = self.openVersion;\\n        require(\\n            openVersion == 0 || openVersion == param.openVersion,\\n            Errors.INVALID_ORACLE_VERSION\\n        );\\n\\n        int256 totalLeveragedQty = self.totalLeveragedQty;\\n        int256 leveragedQty = param.leveragedQty;\\n        PositionUtil.checkAddPositionQty(totalLeveragedQty, leveragedQty);\\n\\n        // accumulate interest before update `totalMakerMargin`\\n        settleAccruedInterest(self, ctx);\\n\\n        self.openVersion = param.openVersion;\\n        self.totalLeveragedQty = totalLeveragedQty + leveragedQty;\\n        self.totalMakerMargin += param.makerMargin;\\n        self.totalTakerMargin += param.takerMargin;\\n    }\\n\\n    /**\\n     * @notice Handles the closing of a position.\\n     * @dev Throws an error with the code `Errors.INVALID_ORACLE_VERSION` if the `openVersion` is not valid.\\n     * @param self The BinPendingPosition storage.\\n     * @param ctx The LpContext.\\n     * @param param The position parameters.\\n     */\\n    function onClosePosition(\\n        BinPendingPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        require(self.openVersion == param.openVersion, Errors.INVALID_ORACLE_VERSION);\\n\\n        int256 totalLeveragedQty = self.totalLeveragedQty;\\n        int256 leveragedQty = param.leveragedQty;\\n        PositionUtil.checkRemovePositionQty(totalLeveragedQty, leveragedQty);\\n\\n        // accumulate interest before update `totalMakerMargin`\\n        settleAccruedInterest(self, ctx);\\n\\n        self.totalLeveragedQty = totalLeveragedQty - leveragedQty;\\n        self.totalMakerMargin -= param.makerMargin;\\n        self.totalTakerMargin -= param.takerMargin;\\n        self.accruedInterest.deduct(param.calculateInterest(ctx, block.timestamp));\\n    }\\n\\n    /**\\n     * @notice Calculates the unrealized profit or loss (PnL) of the pending position.\\n     * @param self The BinPendingPosition storage.\\n     * @param ctx The LpContext.\\n     * @return uint256 The unrealized PnL.\\n     */\\n    function unrealizedPnl(\\n        BinPendingPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (int256) {\\n        uint256 openVersion = self.openVersion;\\n        if (!ctx.isPastVersion(openVersion)) return 0;\\n\\n        IOracleProvider.OracleVersion memory currentVersion = ctx.currentOracleVersion();\\n        UFixed18 _entryPrice = PositionUtil.settlePrice(\\n            ctx.oracleProvider,\\n            openVersion,\\n            ctx.currentOracleVersion()\\n        );\\n        UFixed18 _exitPrice = PositionUtil.oraclePrice(currentVersion);\\n\\n        int256 pnl = PositionUtil.pnl(self.totalLeveragedQty, _entryPrice, _exitPrice) +\\n            currentInterest(self, ctx).toInt256();\\n        uint256 absPnl = pnl.abs();\\n\\n        if (pnl >= 0) {\\n            return Math.min(absPnl, self.totalTakerMargin).toInt256();\\n        } else {\\n            return -(Math.min(absPnl, self.totalMakerMargin).toInt256());\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the current accrued interest of the pending position.\\n     * @param self The BinPendingPosition storage.\\n     * @param ctx The LpContext.\\n     * @return uint256 The current accrued interest.\\n     */\\n    function currentInterest(\\n        BinPendingPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (uint256) {\\n        return self.accruedInterest.calculateInterest(ctx, self.totalMakerMargin, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Calculates the entry price of the pending position.\\n     * @param self The BinPendingPosition storage.\\n     * @param ctx The LpContext.\\n     * @return UFixed18 The entry price.\\n     */\\n    function entryPrice(\\n        BinPendingPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (UFixed18) {\\n        return\\n            PositionUtil.settlePrice(\\n                ctx.oracleProvider,\\n                self.openVersion,\\n                ctx.currentOracleVersion()\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x0483d502148a7e694a066d08310a8dccbab05b854a23d5c92b0a00025fb26892\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/BinPosition.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {UFixed18} from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {PositionUtil} from \\\"@chromatic-protocol/contracts/core/libraries/PositionUtil.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {AccruedInterest, AccruedInterestLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/AccruedInterest.sol\\\";\\nimport {BinPendingPosition, BinPendingPositionLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/BinPendingPosition.sol\\\";\\nimport {PositionParam} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/PositionParam.sol\\\";\\n\\n/**\\n * @title BinPosition\\n * @notice Represents a position in the LiquidityBin\\n */\\nstruct BinPosition {\\n    /// @dev The total leveraged quantity of the `LiquidityBin`\\n    int256 totalLeveragedQty;\\n    /// @dev The total entry amount of the `LiquidityBin`\\n    uint256 totalEntryAmount;\\n    /// @dev The total maker margin of the `LiquidityBin`\\n    uint256 _totalMakerMargin;\\n    /// @dev The total taker margin of the `LiquidityBin`\\n    uint256 _totalTakerMargin;\\n    /// @dev The pending position of the `LiquidityBin`\\n    BinPendingPosition _pending;\\n    /// @dev The accumulated interest of the `LiquidityBin`\\n    AccruedInterest _accruedInterest;\\n}\\n\\n/**\\n * @title BinPositionLib\\n * @notice Library for managing positions in the `LiquidityBin`\\n */\\nlibrary BinPositionLib {\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n    using AccruedInterestLib for AccruedInterest;\\n    using BinPendingPositionLib for BinPendingPosition;\\n\\n    /**\\n     * @notice Settles pending positions for a liquidity bin position.\\n     * @param self The BinPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     */\\n    function settlePendingPosition(BinPosition storage self, LpContext memory ctx) internal {\\n        uint256 openVersion = self._pending.openVersion;\\n        if (!ctx.isPastVersion(openVersion)) return;\\n\\n        // accumulate interest before update `_totalMakerMargin`\\n        self._accruedInterest.accumulate(ctx, self._totalMakerMargin, block.timestamp);\\n\\n        int256 pendingQty = self._pending.totalLeveragedQty;\\n        self.totalLeveragedQty += pendingQty;\\n        self.totalEntryAmount += PositionUtil.transactionAmount(\\n            pendingQty,\\n            self._pending.entryPrice(ctx)\\n        );\\n        self._totalMakerMargin += self._pending.totalMakerMargin;\\n        self._totalTakerMargin += self._pending.totalTakerMargin;\\n\\n        self._pending.settleAccruedInterest(ctx);\\n        self._accruedInterest.accumulatedAmount += self._pending.accruedInterest.accumulatedAmount;\\n\\n        delete self._pending;\\n    }\\n\\n    /**\\n     * @notice Handles the opening of a position for a liquidity bin.\\n     * @param self The BinPosition storage.\\n     * @param ctx The LpContext data struct.\\n     * @param param The PositionParam containing the position parameters.\\n     */\\n    function onOpenPosition(\\n        BinPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        self._pending.onOpenPosition(ctx, param);\\n    }\\n\\n    /**\\n     * @notice Handles the closing of a position for a liquidity bin.\\n     * @param self The BinPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     * @param param The PositionParam data struct containing the position parameters.\\n     */\\n    function onClosePosition(\\n        BinPosition storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal {\\n        if (param.openVersion == self._pending.openVersion) {\\n            self._pending.onClosePosition(ctx, param);\\n        } else {\\n            int256 totalLeveragedQty = self.totalLeveragedQty;\\n            int256 leveragedQty = param.leveragedQty;\\n            PositionUtil.checkRemovePositionQty(totalLeveragedQty, leveragedQty);\\n\\n            // accumulate interest before update `_totalMakerMargin`\\n            self._accruedInterest.accumulate(ctx, self._totalMakerMargin, block.timestamp);\\n\\n            self.totalLeveragedQty = totalLeveragedQty - leveragedQty;\\n            self.totalEntryAmount -= param.entryAmount(ctx);\\n            self._totalMakerMargin -= param.makerMargin;\\n            self._totalTakerMargin -= param.takerMargin;\\n            self._accruedInterest.deduct(param.calculateInterest(ctx, block.timestamp));\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the total maker margin for a liquidity bin position.\\n     * @param self The BinPosition storage struct.\\n     * @return uint256 The total maker margin.\\n     */\\n    function totalMakerMargin(BinPosition storage self) internal view returns (uint256) {\\n        return self._totalMakerMargin + self._pending.totalMakerMargin;\\n    }\\n\\n    /**\\n     * @notice Returns the total taker margin for a liquidity bin position.\\n     * @param self The BinPosition storage struct.\\n     * @return uint256 The total taker margin.\\n     */\\n    function totalTakerMargin(BinPosition storage self) internal view returns (uint256) {\\n        return self._totalTakerMargin + self._pending.totalTakerMargin;\\n    }\\n\\n    /**\\n     * @notice Calculates the unrealized profit or loss for a liquidity bin position.\\n     * @param self The BinPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     * @return int256 The unrealized profit or loss.\\n     */\\n    function unrealizedPnl(\\n        BinPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (int256) {\\n        IOracleProvider.OracleVersion memory currentVersion = ctx.currentOracleVersion();\\n\\n        int256 leveragedQty = self.totalLeveragedQty;\\n        int256 sign = leveragedQty < 0 ? int256(-1) : int256(1);\\n        UFixed18 exitPrice = PositionUtil.oraclePrice(currentVersion);\\n\\n        int256 entryAmount = self.totalEntryAmount.toInt256() * sign;\\n        int256 exitAmount = PositionUtil.transactionAmount(leveragedQty, exitPrice).toInt256() *\\n            sign;\\n\\n        int256 rawPnl = exitAmount - entryAmount;\\n        int256 pnl = rawPnl +\\n            self._pending.unrealizedPnl(ctx) +\\n            _currentInterest(self, ctx).toInt256();\\n        uint256 absPnl = pnl.abs();\\n\\n        if (pnl >= 0) {\\n            return Math.min(absPnl, totalTakerMargin(self)).toInt256();\\n        } else {\\n            return -(Math.min(absPnl, totalMakerMargin(self)).toInt256());\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the current interest for a liquidity bin position.\\n     * @param self The BinPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     * @return uint256 The current interest.\\n     */\\n    function currentInterest(\\n        BinPosition storage self,\\n        LpContext memory ctx\\n    ) internal view returns (uint256) {\\n        return _currentInterest(self, ctx) + self._pending.currentInterest(ctx);\\n    }\\n\\n    /**\\n     * @dev Calculates the current interest for a liquidity bin position without pending position.\\n     * @param self The BinPosition storage struct.\\n     * @param ctx The LpContext data struct.\\n     * @return uint256 The current interest.\\n     */\\n    function _currentInterest(\\n        BinPosition storage self,\\n        LpContext memory ctx\\n    ) private view returns (uint256) {\\n        return\\n            self._accruedInterest.calculateInterest(ctx, self._totalMakerMargin, block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0xcd1a6eaa0aba835c80e2350795282626ff210c6082bb241cf3b22876e0061323\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/LiquidityBin.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {IMarketLiquidity} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidity.sol\\\";\\nimport {BinLiquidity, BinLiquidityLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/BinLiquidity.sol\\\";\\nimport {BinPosition, BinPositionLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/BinPosition.sol\\\";\\nimport {BinClosedPosition, BinClosedPositionLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/BinClosedPosition.sol\\\";\\nimport {PositionParam} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/PositionParam.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {CLBTokenLib} from \\\"@chromatic-protocol/contracts/core/libraries/CLBTokenLib.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n/**\\n * @title LiquidityBin\\n * @notice Structure representing a liquidity bin\\n */\\nstruct LiquidityBin {\\n    /// @dev The ID of the CLB token\\n    uint256 clbTokenId;\\n    /// @dev The liquidity data for the bin\\n    BinLiquidity _liquidity;\\n    /// @dev The position data for the bin\\n    BinPosition _position;\\n    /// @dev The closed position data for the bin\\n    BinClosedPosition _closedPosition;\\n}\\n\\n/**\\n * @title LiquidityBinLib\\n * @notice Library for managing liquidity bin\\n */\\nlibrary LiquidityBinLib {\\n    using Math for uint256;\\n    using SignedMath for int256;\\n    using LiquidityBinLib for LiquidityBin;\\n    using BinLiquidityLib for BinLiquidity;\\n    using BinPositionLib for BinPosition;\\n    using BinClosedPositionLib for BinClosedPosition;\\n\\n    /**\\n     * @notice Modifier to settle the pending positions, closing positions,\\n     *         and pending liquidity of the bin before executing a function.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext data struct.\\n     */\\n    modifier _settle(LiquidityBin storage self, LpContext memory ctx) {\\n        self.settle(ctx);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Settles the pending positions, closing positions, and pending liquidity of the bin.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext data struct.\\n     */\\n    function settle(LiquidityBin storage self, LpContext memory ctx) internal {\\n        self._closedPosition.settleClosingPosition(ctx);\\n        self._position.settlePendingPosition(ctx);\\n        self._liquidity.settlePendingLiquidity(\\n            ctx,\\n            self.value(ctx),\\n            self.freeLiquidity(),\\n            self.clbTokenId\\n        );\\n    }\\n\\n    /**\\n     * @notice Initializes the liquidity bin with the given trading fee rate\\n     * @param self The LiquidityBin storage\\n     * @param tradingFeeRate The trading fee rate to set\\n     */\\n    function initialize(LiquidityBin storage self, int16 tradingFeeRate) internal {\\n        self.clbTokenId = CLBTokenLib.encodeId(tradingFeeRate);\\n    }\\n\\n    /**\\n     * @notice Opens a new position in the liquidity bin\\n     * @dev Throws an error with the code `Errors.NOT_ENOUGH_FREE_LIQUIDITY` if there is not enough free liquidity.\\n     * @param self The LiquidityBin storage\\n     * @param ctx The LpContext data struct\\n     * @param param The position parameters\\n     * @param tradingFee The trading fee amount\\n     */\\n    function openPosition(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param,\\n        uint256 tradingFee\\n    ) internal {\\n        require(param.makerMargin <= self.freeLiquidity(), Errors.NOT_ENOUGH_FREE_LIQUIDITY);\\n\\n        self._position.onOpenPosition(ctx, param);\\n        self._liquidity.total += tradingFee;\\n    }\\n\\n    /**\\n     * @notice Closes a position in the liquidity bin\\n     * @param self The LiquidityBin storage\\n     * @param ctx The LpContext data struct\\n     * @param param The position parameters\\n     */\\n    function closePosition(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param\\n    ) internal _settle(self, ctx) {\\n        self._position.onClosePosition(ctx, param);\\n        if (param.closeVersion > param.openVersion) {\\n            self._closedPosition.onClosePosition(ctx, param);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claims an existing liquidity position in the bin.\\n     * @dev This function claims the position using the specified parameters\\n     *      and updates the total by subtracting the absolute value\\n     *      of the taker's profit or loss (takerPnl) from it.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext memory.\\n     * @param param The PositionParam memory.\\n     * @param takerPnl The taker's profit/loss.\\n     */\\n    function claimPosition(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        PositionParam memory param,\\n        int256 takerPnl\\n    ) internal _settle(self, ctx) {\\n        if (param.closeVersion == 0) {\\n            // called when liquidate\\n            self._position.onClosePosition(ctx, param);\\n        } else if (param.closeVersion > param.openVersion) {\\n            self._closedPosition.onClaimPosition(ctx, param);\\n        }\\n\\n        uint256 absTakerPnl = takerPnl.abs();\\n        if (takerPnl < 0) {\\n            self._liquidity.total += absTakerPnl;\\n        } else {\\n            self._liquidity.total -= absTakerPnl;\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the total liquidity in the bin\\n     * @param self The LiquidityBin storage\\n     * @return uint256 The total liquidity in the bin\\n     */\\n    function liquidity(LiquidityBin storage self) internal view returns (uint256) {\\n        return self._liquidity.total;\\n    }\\n\\n    /**\\n     * @notice Retrieves the free liquidity in the bin (liquidity minus total maker margin)\\n     * @param self The LiquidityBin storage\\n     * @return uint256 The free liquidity in the bin\\n     */\\n    function freeLiquidity(LiquidityBin storage self) internal view returns (uint256) {\\n        return\\n            self._liquidity.total -\\n            self._position.totalMakerMargin() -\\n            self._closedPosition.totalMakerMargin();\\n    }\\n\\n    /**\\n     * @notice Applies earnings to the liquidity bin\\n     * @param self The LiquidityBin storage\\n     * @param earning The earning amount to apply\\n     */\\n    function applyEarning(LiquidityBin storage self, uint256 earning) internal {\\n        self._liquidity.total += earning;\\n    }\\n\\n    /**\\n     * @notice Calculates the value of the bin.\\n     * @dev This function considers the unrealized profit or loss of the position\\n     *      and adds it to the total value.\\n     *      Additionally, it includes the pending bin share from the market's vault.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext memory.\\n     * @return uint256 The value of the bin.\\n     */\\n    function value(\\n        LiquidityBin storage self,\\n        LpContext memory ctx\\n    ) internal view returns (uint256) {\\n        int256 unrealizedPnl = self._position.unrealizedPnl(ctx);\\n\\n        uint256 absPnl = unrealizedPnl.abs();\\n\\n        uint256 _liquidity = self.liquidity();\\n        uint256 _value = unrealizedPnl < 0 ? _liquidity - absPnl : _liquidity + absPnl;\\n        return\\n            _value +\\n            self._closedPosition.currentInterest(ctx) +\\n            ctx.vault.getPendingBinShare(ctx.market, ctx.settlementToken, _liquidity);\\n    }\\n\\n    /**\\n     * @notice Accepts an add liquidity request.\\n     * @dev This function adds liquidity to the bin by calling the `onAddLiquidity` function\\n     *      of the liquidity component.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext memory.\\n     * @param amount The amount of liquidity to add.\\n     */\\n    function acceptAddLiquidity(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        uint256 amount\\n    ) internal _settle(self, ctx) {\\n        self._liquidity.onAddLiquidity(amount, ctx.currentOracleVersion().version);\\n    }\\n\\n    /**\\n     * @notice Accepts a claim liquidity request.\\n     * @dev This function claims liquidity from the bin by calling the `onClaimLiquidity` function\\n     *      of the liquidity component.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext memory.\\n     * @param amount The amount of liquidity to claim.\\n     *        (should be the same as the one used in acceptAddLiquidity)\\n     * @param oracleVersion The oracle version used for the claim.\\n     *        (should be the oracle version when call acceptAddLiquidity)\\n     * @return The amount of liquidity (CLB tokens) received as a result of the liquidity claim.\\n     */\\n    function acceptClaimLiquidity(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        uint256 amount,\\n        uint256 oracleVersion\\n    ) internal _settle(self, ctx) returns (uint256) {\\n        return self._liquidity.onClaimLiquidity(amount, oracleVersion);\\n    }\\n\\n    /**\\n     * @notice Accepts a remove liquidity request.\\n     * @dev This function removes liquidity from the bin by calling the `onRemoveLiquidity` function\\n     *      of the liquidity component.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext memory.\\n     * @param clbTokenAmount The amount of CLB tokens to remove.\\n     */\\n    function acceptRemoveLiquidity(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        uint256 clbTokenAmount\\n    ) internal _settle(self, ctx) {\\n        self._liquidity.onRemoveLiquidity(clbTokenAmount, ctx.currentOracleVersion().version);\\n    }\\n\\n    /**\\n     * @notice Accepts a withdraw liquidity request.\\n     * @dev This function withdraws liquidity from the bin by calling the `onWithdrawLiquidity` function\\n     *      of the liquidity component.\\n     * @param self The LiquidityBin storage.\\n     * @param ctx The LpContext memory.\\n     * @param clbTokenAmount The amount of CLB tokens to withdraw.\\n     *        (should be the same as the one used in acceptRemoveLiquidity)\\n     * @param oracleVersion The oracle version used for the withdrawal.\\n     *        (should be the oracle version when call acceptRemoveLiquidity)\\n     * @return amount The amount of liquidity withdrawn\\n     * @return burnedCLBTokenAmount The amount of CLB tokens burned during the withdrawal.\\n     */\\n    function acceptWithdrawLiquidity(\\n        LiquidityBin storage self,\\n        LpContext memory ctx,\\n        uint256 clbTokenAmount,\\n        uint256 oracleVersion\\n    ) internal _settle(self, ctx) returns (uint256 amount, uint256 burnedCLBTokenAmount) {\\n        return self._liquidity.onWithdrawLiquidity(clbTokenAmount, oracleVersion);\\n    }\\n\\n    /**\\n     * @dev Retrieves the claimable liquidity information for a specific oracle version from a LiquidityBin.\\n     * @param self The reference to the LiquidityBin struct.\\n     * @param oracleVersion The oracle version for which to retrieve the claimable liquidity.\\n     * @return claimableLiquidity An instance of IMarketLiquidity.ClaimableLiquidity representing the claimable liquidity information.\\n     */\\n    function claimableLiquidity(\\n        LiquidityBin storage self,\\n        uint256 oracleVersion\\n    ) internal view returns (IMarketLiquidity.ClaimableLiquidity memory) {\\n        return self._liquidity.claimableLiquidity(oracleVersion);\\n    }\\n}\\n\",\"keccak256\":\"0x76569daef20bfd9f6d42b233ca8b7709d2a70dec22ad0c749cd1ca64615f34fa\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/LiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {IMarketLiquidity} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidity.sol\\\";\\nimport {LiquidityBin, LiquidityBinLib} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/LiquidityBin.sol\\\";\\nimport {PositionParam} from \\\"@chromatic-protocol/contracts/core/libraries/liquidity/PositionParam.sol\\\";\\nimport {FEE_RATES_LENGTH} from \\\"@chromatic-protocol/contracts/core/libraries/Constants.sol\\\";\\nimport {Position} from \\\"@chromatic-protocol/contracts/core/libraries/Position.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\nimport {CLBTokenLib} from \\\"@chromatic-protocol/contracts/core/libraries/CLBTokenLib.sol\\\";\\nimport {BinMargin} from \\\"@chromatic-protocol/contracts/core/libraries/BinMargin.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title LiquidityPool\\n * @notice Represents a collection of long and short liquidity bins\\n */\\nstruct LiquidityPool {\\n    mapping(uint16 => LiquidityBin) _longBins;\\n    mapping(uint16 => LiquidityBin) _shortBins;\\n}\\n\\nusing LiquidityPoolLib for LiquidityPool global;\\n\\n/**\\n * @title LiquidityPoolLib\\n * @notice Library for managing liquidity bins in an LiquidityPool\\n */\\nlibrary LiquidityPoolLib {\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n    using LiquidityBinLib for LiquidityBin;\\n\\n    /**\\n     * @notice Emitted when earning is accumulated for a liquidity bin.\\n     * @param feeRate The fee rate of the bin.\\n     * @param binType The type of the bin (\\\"L\\\" for long, \\\"S\\\" for short).\\n     * @param earning The accumulated earning.\\n     */\\n    event LiquidityBinEarningAccumulated(\\n        uint16 indexed feeRate,\\n        bytes1 indexed binType,\\n        uint256 indexed earning\\n    );\\n\\n    struct _proportionalPositionParamValue {\\n        int256 leveragedQty;\\n        uint256 takerMargin;\\n    }\\n\\n    /**\\n     * @notice Modifier to validate the trading fee rate.\\n     * @param tradingFeeRate The trading fee rate to validate.\\n     */\\n    modifier _validTradingFeeRate(int16 tradingFeeRate) {\\n        validateTradingFeeRate(tradingFeeRate);\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the LiquidityPool.\\n     * @param self The reference to the LiquidityPool.\\n     */\\n    function initialize(LiquidityPool storage self) internal {\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates = CLBTokenLib.tradingFeeRates();\\n        for (uint256 i; i < FEE_RATES_LENGTH; ) {\\n            uint16 feeRate = _tradingFeeRates[i];\\n            self._longBins[feeRate].initialize(int16(feeRate));\\n            self._shortBins[feeRate].initialize(-int16(feeRate));\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Settles the liquidity bins in the LiquidityPool.\\n     * @param self The reference to the LiquidityPool.\\n     * @param ctx The LpContext object.\\n     */\\n    function settle(LiquidityPool storage self, LpContext memory ctx) internal {\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates = CLBTokenLib.tradingFeeRates();\\n        for (uint256 i; i < FEE_RATES_LENGTH; ) {\\n            uint16 feeRate = _tradingFeeRates[i];\\n            self._longBins[feeRate].settle(ctx);\\n            self._shortBins[feeRate].settle(ctx);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Prepares bin margins based on the given quantity and maker margin.\\n     * @dev This function prepares bin margins by performing the following steps:\\n     *      1. Calculates the appropriate bin margins\\n     *         for each trading fee rate based on the provided quantity and maker margin.\\n     *      2. Iterates through the target bins based on the quantity,\\n     *         finds the minimum available fee rate,\\n     *         and determines the upper bound for calculating bin margins.\\n     *      3. Iterates from the minimum fee rate until the upper bound,\\n     *         assigning the remaining maker margin to the bins until it is exhausted.\\n     *      4. Creates an array of BinMargin structs\\n     *         containing the trading fee rate and corresponding margin amount for each bin.\\n     *      Throws an error with the code `Errors.NOT_ENOUGH_FREE_LIQUIDITY` if there is not enough free liquidity.\\n     * @param self The reference to the LiquidityPool.\\n     * @param ctx The LpContext data struct\\n     * @param qty The quantity of the position.\\n     * @param makerMargin The maker margin of the position.\\n     * @return binMargins An array of BinMargin representing the calculated bin margins.\\n     */\\n    function prepareBinMargins(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        int224 qty,\\n        uint256 makerMargin,\\n        uint256 minimumBinMargin\\n    ) internal returns (BinMargin[] memory) {\\n        // Retrieve the target liquidity bins based on the position quantity\\n        mapping(uint16 => LiquidityBin) storage _bins = targetBins(self, qty);\\n\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates = CLBTokenLib.tradingFeeRates();\\n        uint256[FEE_RATES_LENGTH] memory _binMargins;\\n\\n        uint256 to;\\n        uint256 cnt;\\n        uint256 remain = makerMargin;\\n        for (; to < FEE_RATES_LENGTH; to++) {\\n            if (remain == 0) break;\\n\\n            LiquidityBin storage _bin = _bins[_tradingFeeRates[to]];\\n            _bin.settle(ctx);\\n\\n            uint256 freeLiquidity = _bin.freeLiquidity();\\n            if (freeLiquidity >= minimumBinMargin) {\\n                if (remain <= freeLiquidity) {\\n                    _binMargins[to] = remain;\\n                    remain = 0;\\n                } else {\\n                    _binMargins[to] = freeLiquidity;\\n                    remain -= freeLiquidity;\\n                }\\n                cnt++;\\n            }\\n        }\\n\\n        require(remain == 0, Errors.NOT_ENOUGH_FREE_LIQUIDITY);\\n\\n        BinMargin[] memory binMargins = new BinMargin[](cnt);\\n        for ((uint256 i, uint256 idx) = (0, 0); i < to; i++) {\\n            if (_binMargins[i] != 0) {\\n                binMargins[idx] = BinMargin({\\n                    tradingFeeRate: _tradingFeeRates[i],\\n                    amount: _binMargins[i]\\n                });\\n\\n                unchecked {\\n                    idx++;\\n                }\\n            }\\n        }\\n\\n        return binMargins;\\n    }\\n\\n    /**\\n     * @notice Accepts an open position and opens corresponding liquidity bins.\\n     * @dev This function calculates the target liquidity bins based on the position quantity.\\n     *      It prepares the bin margins and divides the position parameters accordingly.\\n     *      Then, it opens the liquidity bins with the corresponding parameters and trading fees.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param position The Position object representing the open position.\\n     */\\n    function acceptOpenPosition(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        Position memory position\\n    ) internal {\\n        // Retrieve the target liquidity bins based on the position quantity\\n        mapping(uint16 => LiquidityBin) storage _bins = targetBins(self, position.qty);\\n\\n        uint256 makerMargin = position.makerMargin();\\n        BinMargin[] memory binMargins = position.binMargins();\\n\\n        // Divide the position parameters to match the bin margins\\n        _proportionalPositionParamValue[] memory paramValues = divideToPositionParamValue(\\n            position.leveragedQty(ctx),\\n            makerMargin,\\n            position.takerMargin,\\n            binMargins\\n        );\\n\\n        PositionParam memory param = newPositionParam(position.openVersion, position.openTimestamp);\\n        for (uint256 i; i < binMargins.length; ) {\\n            BinMargin memory binMargin = binMargins[i];\\n\\n            if (binMargin.amount != 0) {\\n                param.leveragedQty = paramValues[i].leveragedQty;\\n                param.takerMargin = paramValues[i].takerMargin;\\n                param.makerMargin = binMargin.amount;\\n\\n                _bins[binMargins[i].tradingFeeRate].openPosition(\\n                    ctx,\\n                    param,\\n                    binMargin.tradingFee(position._feeProtocol)\\n                );\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts a close position request and closes the corresponding liquidity bins.\\n     * @dev This function calculates the target liquidity bins based on the position quantity.\\n     *      It retrieves the maker margin and bin margins from the position.\\n     *      Then, it divides the position parameters to match the bin margins.\\n     *      Finally, it closes the liquidity bins with the provided parameters.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param position The Position object representing the close position request.\\n     */\\n    function acceptClosePosition(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        Position memory position\\n    ) internal {\\n        // Retrieve the target liquidity bins based on the position quantity\\n        mapping(uint16 => LiquidityBin) storage _bins = targetBins(self, position.qty);\\n\\n        uint256 makerMargin = position.makerMargin();\\n        BinMargin[] memory binMargins = position.binMargins();\\n\\n        // Divide the position parameters to match the bin margins\\n        _proportionalPositionParamValue[] memory paramValues = divideToPositionParamValue(\\n            position.leveragedQty(ctx),\\n            makerMargin,\\n            position.takerMargin,\\n            binMargins\\n        );\\n\\n        PositionParam memory param = newPositionParam(\\n            position.openVersion,\\n            position.closeVersion,\\n            position.openTimestamp,\\n            position.closeTimestamp\\n        );\\n\\n        for (uint256 i; i < binMargins.length; ) {\\n            if (binMargins[i].amount != 0) {\\n                LiquidityBin storage _bin = _bins[binMargins[i].tradingFeeRate];\\n\\n                param.leveragedQty = paramValues[i].leveragedQty;\\n                param.takerMargin = paramValues[i].takerMargin;\\n                param.makerMargin = binMargins[i].amount;\\n\\n                _bin.closePosition(ctx, param);\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts a claim position request and processes the corresponding liquidity bins\\n     *         based on the realized position pnl.\\n     * @dev This function verifies if the absolute value of the realized position pnl is within the acceptable margin range.\\n     *      It retrieves the target liquidity bins based on the position quantity and the bin margins from the position.\\n     *      Then, it divides the position parameters to match the bin margins.\\n     *      Depending on the value of the realized position pnl, it either claims the position fully or partially.\\n     *      The claimed pnl is distributed among the liquidity bins according to their respective margins.\\n     *      Throws an error with the code `Errors.EXCEED_MARGIN_RANGE` if the realized profit or loss does not falls within the acceptable margin range.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param position The Position object representing the position to claim.\\n     * @param realizedPnl The realized position pnl (taker side).\\n     */\\n    function acceptClaimPosition(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        Position memory position,\\n        int256 realizedPnl // realized position pnl (taker side)\\n    ) internal {\\n        uint256 absRealizedPnl = realizedPnl.abs();\\n        uint256 makerMargin = position.makerMargin();\\n        // Ensure that the realized position pnl is within the acceptable margin range\\n        require(\\n            !((realizedPnl > 0 && absRealizedPnl > makerMargin) ||\\n                (realizedPnl < 0 && absRealizedPnl > position.takerMargin)),\\n            Errors.EXCEED_MARGIN_RANGE\\n        );\\n\\n        // Retrieve the target liquidity bins based on the position quantity\\n        mapping(uint16 => LiquidityBin) storage _bins = targetBins(self, position.qty);\\n        BinMargin[] memory binMargins = position.binMargins();\\n\\n        // Divide the position parameters to match the bin margins\\n        _proportionalPositionParamValue[] memory paramValues = divideToPositionParamValue(\\n            position.leveragedQty(ctx),\\n            makerMargin,\\n            position.takerMargin,\\n            binMargins\\n        );\\n\\n        PositionParam memory param = newPositionParam(\\n            position.openVersion,\\n            position.closeVersion,\\n            position.openTimestamp,\\n            position.closeTimestamp\\n        );\\n\\n        if (realizedPnl == 0) {\\n            for (uint256 i; i < binMargins.length; ) {\\n                if (binMargins[i].amount != 0) {\\n                    LiquidityBin storage _bin = _bins[binMargins[i].tradingFeeRate];\\n\\n                    param.leveragedQty = paramValues[i].leveragedQty;\\n                    param.takerMargin = paramValues[i].takerMargin;\\n                    param.makerMargin = binMargins[i].amount;\\n\\n                    _bin.claimPosition(ctx, param, 0);\\n                }\\n\\n                unchecked {\\n                    i++;\\n                }\\n            }\\n        } else if (realizedPnl > 0 && absRealizedPnl == makerMargin) {\\n            for (uint256 i; i < binMargins.length; ) {\\n                if (binMargins[i].amount != 0) {\\n                    LiquidityBin storage _bin = _bins[binMargins[i].tradingFeeRate];\\n\\n                    param.leveragedQty = paramValues[i].leveragedQty;\\n                    param.takerMargin = paramValues[i].takerMargin;\\n                    param.makerMargin = binMargins[i].amount;\\n\\n                    _bin.claimPosition(ctx, param, param.makerMargin.toInt256());\\n                }\\n\\n                unchecked {\\n                    i++;\\n                }\\n            }\\n        } else {\\n            uint256 remainMakerMargin = makerMargin;\\n            uint256 remainRealizedPnl = absRealizedPnl;\\n\\n            for (uint256 i; i < binMargins.length; ) {\\n                if (binMargins[i].amount != 0) {\\n                    LiquidityBin storage _bin = _bins[binMargins[i].tradingFeeRate];\\n\\n                    param.leveragedQty = paramValues[i].leveragedQty;\\n                    param.takerMargin = paramValues[i].takerMargin;\\n                    param.makerMargin = binMargins[i].amount;\\n\\n                    uint256 absTakerPnl = remainRealizedPnl.mulDiv(\\n                        param.makerMargin,\\n                        remainMakerMargin\\n                    );\\n                    if (realizedPnl < 0) {\\n                        // maker profit\\n                        absTakerPnl = Math.min(absTakerPnl, param.takerMargin);\\n                    } else {\\n                        // taker profit\\n                        absTakerPnl = Math.min(absTakerPnl, param.makerMargin);\\n                    }\\n\\n                    int256 takerPnl = realizedPnl < 0\\n                        ? -(absTakerPnl.toInt256())\\n                        : absTakerPnl.toInt256();\\n\\n                    _bin.claimPosition(ctx, param, takerPnl);\\n\\n                    remainMakerMargin -= param.makerMargin;\\n                    remainRealizedPnl -= absTakerPnl;\\n                }\\n\\n                unchecked {\\n                    i++;\\n                }\\n            }\\n\\n            require(remainRealizedPnl == 0, Errors.EXCEED_MARGIN_RANGE);\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts an add liquidity request\\n     *         and processes the liquidity bin corresponding to the given trading fee rate.\\n     * @dev This function validates the trading fee rate\\n     *      and calls the acceptAddLiquidity function on the target liquidity bin.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param tradingFeeRate The trading fee rate associated with the liquidity bin.\\n     * @param amount The amount of liquidity to add.\\n     */\\n    function acceptAddLiquidity(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        int16 tradingFeeRate,\\n        uint256 amount\\n    ) internal _validTradingFeeRate(tradingFeeRate) {\\n        // Retrieve the liquidity bin based on the trading fee rate\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        // Process the add liquidity request on the liquidity bin\\n        bin.acceptAddLiquidity(ctx, amount);\\n    }\\n\\n    /**\\n     * @notice Accepts a claim liquidity request\\n     *         and processes the liquidity bin corresponding to the given trading fee rate.\\n     * @dev This function validates the trading fee rate\\n     *      and calls the acceptClaimLiquidity function on the target liquidity bin.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param tradingFeeRate The trading fee rate associated with the liquidity bin.\\n     * @param amount The amount of liquidity to claim.\\n     *        (should be the same as the one used in acceptAddLiquidity)\\n     * @param oracleVersion The oracle version used for the claim.\\n     *        (should be the oracle version when call acceptAddLiquidity)\\n     * @return The amount of liquidity (CLB tokens) received as a result of the liquidity claim.\\n     */\\n    function acceptClaimLiquidity(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        int16 tradingFeeRate,\\n        uint256 amount,\\n        uint256 oracleVersion\\n    ) internal _validTradingFeeRate(tradingFeeRate) returns (uint256) {\\n        // Retrieve the liquidity bin based on the trading fee rate\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        // Process the claim liquidity request on the liquidity bin and return the actual claimed amount\\n        return bin.acceptClaimLiquidity(ctx, amount, oracleVersion);\\n    }\\n\\n    /**\\n     * @notice Accepts a remove liquidity request\\n     *         and processes the liquidity bin corresponding to the given trading fee rate.\\n     * @dev This function validates the trading fee rate\\n     *      and calls the acceptRemoveLiquidity function on the target liquidity bin.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param tradingFeeRate The trading fee rate associated with the liquidity bin.\\n     * @param clbTokenAmount The amount of CLB tokens to remove.\\n     */\\n    function acceptRemoveLiquidity(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        int16 tradingFeeRate,\\n        uint256 clbTokenAmount\\n    ) internal _validTradingFeeRate(tradingFeeRate) {\\n        // Retrieve the liquidity bin based on the trading fee rate\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        // Process the remove liquidity request on the liquidity bin\\n        bin.acceptRemoveLiquidity(ctx, clbTokenAmount);\\n    }\\n\\n    /**\\n     * @notice Accepts a withdraw liquidity request\\n     *         and processes the liquidity bin corresponding to the given trading fee rate.\\n     * @dev This function validates the trading fee rate\\n     *      and calls the acceptWithdrawLiquidity function on the target liquidity bin.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param ctx The LpContext object.\\n     * @param tradingFeeRate The trading fee rate associated with the liquidity bin.\\n     * @param clbTokenAmount The amount of CLB tokens to withdraw.\\n     *        (should be the same as the one used in acceptRemoveLiquidity)\\n     * @param oracleVersion The oracle version used for the withdrawal.\\n     *        (should be the oracle version when call acceptRemoveLiquidity)\\n     * @return amount The amount of base tokens withdrawn\\n     * @return burnedCLBTokenAmount the amount of CLB tokens burned.\\n     */\\n    function acceptWithdrawLiquidity(\\n        LiquidityPool storage self,\\n        LpContext memory ctx,\\n        int16 tradingFeeRate,\\n        uint256 clbTokenAmount,\\n        uint256 oracleVersion\\n    )\\n        internal\\n        _validTradingFeeRate(tradingFeeRate)\\n        returns (uint256 amount, uint256 burnedCLBTokenAmount)\\n    {\\n        // Retrieve the liquidity bin based on the trading fee rate\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        // Process the withdraw liquidity request on the liquidity bin\\n        // and get the amount of base tokens withdrawn and CLB tokens burned\\n        return bin.acceptWithdrawLiquidity(ctx, clbTokenAmount, oracleVersion);\\n    }\\n\\n    /**\\n     * @notice Retrieves the total liquidity amount in base tokens for the specified trading fee rate.\\n     * @dev This function retrieves the liquidity bin based on the trading fee rate\\n     *      and calls the liquidity function on it.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param tradingFeeRate The trading fee rate associated with the liquidity bin.\\n     * @return amount The total liquidity amount in base tokens.\\n     */\\n    function getBinLiquidity(\\n        LiquidityPool storage self,\\n        int16 tradingFeeRate\\n    ) internal view returns (uint256 amount) {\\n        // Retrieve the liquidity bin based on the trading fee rate\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        // Get the total liquidity amount in base tokens from the liquidity bin\\n        return bin.liquidity();\\n    }\\n\\n    /**\\n     * @notice Retrieves the free liquidity amount in base tokens for the specified trading fee rate.\\n     * @dev This function retrieves the liquidity bin based on the trading fee rate\\n     *      and calls the freeLiquidity function on it.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param tradingFeeRate The trading fee rate associated with the liquidity bin.\\n     * @return amount The free liquidity amount in base tokens.\\n     */\\n    function getBinFreeLiquidity(\\n        LiquidityPool storage self,\\n        int16 tradingFeeRate\\n    ) internal view returns (uint256 amount) {\\n        // Retrieve the liquidity bin based on the trading fee rate\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        // Get the free liquidity amount in base tokens from the liquidity bin\\n        return bin.freeLiquidity();\\n    }\\n\\n    /**\\n     * @notice Retrieves the target bins based on the sign of the given value.\\n     * @dev This function retrieves the target bins mapping (short or long) based on the sign of the given value.\\n     * @param self The storage reference to the LiquidityPool.\\n     * @param sign The sign of the value (-1 for negative, 1 for positive).\\n     * @return _bins The target bins mapping associated with the sign of the value.\\n     */\\n    function targetBins(\\n        LiquidityPool storage self,\\n        int256 sign\\n    ) private view returns (mapping(uint16 => LiquidityBin) storage) {\\n        return sign < 0 ? self._shortBins : self._longBins;\\n    }\\n\\n    /**\\n     * @notice Retrieves the target bin based on the trading fee rate.\\n     * @dev This function retrieves the target bin based on the sign of the trading fee rate and returns it.\\n     * @param self The storage reference to the LiquidityPool.\\n     * @param tradingFeeRate The trading fee rate associated with the bin.\\n     * @return bin The target bin associated with the trading fee rate.\\n     */\\n    function targetBin(\\n        LiquidityPool storage self,\\n        int16 tradingFeeRate\\n    ) private view returns (LiquidityBin storage) {\\n        return\\n            tradingFeeRate < 0\\n                ? self._shortBins[abs(tradingFeeRate)]\\n                : self._longBins[abs(tradingFeeRate)];\\n    }\\n\\n    /**\\n     * @notice Divides the leveraged quantity, maker margin, and taker margin\\n     *         into proportional position parameter values.\\n     * @dev This function divides the leveraged quantity, maker margin, and taker margin\\n     *      into proportional position parameter values based on the bin margins.\\n     *      It calculates the proportional values for each bin margin and returns them in an array.\\n     * @param leveragedQty The leveraged quantity.\\n     * @param makerMargin The maker margin amount.\\n     * @param takerMargin The taker margin amount.\\n     * @param binMargins The array of bin margins.\\n     * @return values The array of proportional position parameter values.\\n     */\\n    function divideToPositionParamValue(\\n        int256 leveragedQty,\\n        uint256 makerMargin,\\n        uint256 takerMargin,\\n        BinMargin[] memory binMargins\\n    ) private pure returns (_proportionalPositionParamValue[] memory) {\\n        uint256 remainLeveragedQty = leveragedQty.abs();\\n        uint256 remainTakerMargin = takerMargin;\\n\\n        _proportionalPositionParamValue[] memory values = new _proportionalPositionParamValue[](\\n            binMargins.length\\n        );\\n\\n        for (uint256 i; i < binMargins.length - 1; ) {\\n            uint256 _qty = remainLeveragedQty.mulDiv(binMargins[i].amount, makerMargin);\\n            uint256 _takerMargin = remainTakerMargin.mulDiv(binMargins[i].amount, makerMargin);\\n\\n            values[i] = _proportionalPositionParamValue({\\n                leveragedQty: leveragedQty < 0 ? _qty.toInt256() : -(_qty.toInt256()), // opposit side\\n                takerMargin: _takerMargin\\n            });\\n\\n            remainLeveragedQty -= _qty;\\n            remainTakerMargin -= _takerMargin;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        values[binMargins.length - 1] = _proportionalPositionParamValue({\\n            leveragedQty: leveragedQty < 0\\n                ? remainLeveragedQty.toInt256()\\n                : -(remainLeveragedQty.toInt256()), // opposit side\\n            takerMargin: remainTakerMargin\\n        });\\n\\n        return values;\\n    }\\n\\n    /**\\n     * @notice Creates a new PositionParam struct with the given oracle version and timestamp.\\n     * @param openVersion The version of the oracle when the position was opened\\n     * @param openTimestamp The timestamp when the position was opened\\n     * @return param The new PositionParam struct.\\n     */\\n    function newPositionParam(\\n        uint256 openVersion,\\n        uint256 openTimestamp\\n    ) private pure returns (PositionParam memory param) {\\n        param.openVersion = openVersion;\\n        param.openTimestamp = openTimestamp;\\n    }\\n\\n    /**\\n     * @notice Creates a new PositionParam struct with the given oracle version and timestamp.\\n     * @param openVersion The version of the oracle when the position was opened\\n     * @param closeVersion The version of the oracle when the position was closed\\n     * @param openTimestamp The timestamp when the position was opened\\n     * @param closeTimestamp The timestamp when the position was closed\\n     * @return param The new PositionParam struct.\\n     */\\n    function newPositionParam(\\n        uint256 openVersion,\\n        uint256 closeVersion,\\n        uint256 openTimestamp,\\n        uint256 closeTimestamp\\n    ) private pure returns (PositionParam memory param) {\\n        param.openVersion = openVersion;\\n        param.closeVersion = closeVersion;\\n        param.openTimestamp = openTimestamp;\\n        param.closeTimestamp = closeTimestamp;\\n    }\\n\\n    /**\\n     * @notice Validates the trading fee rate.\\n     * @dev This function validates the trading fee rate by checking if it is supported.\\n     *      It compares the absolute value of the fee rate with the predefined trading fee rates\\n     *      to determine if it is a valid rate.\\n     *      Throws an error with the code `Errors.UNSUPPORTED_TRADING_FEE_RATE` if the trading fee rate is not supported.\\n     * @param tradingFeeRate The trading fee rate to be validated.\\n     */\\n    function validateTradingFeeRate(int16 tradingFeeRate) private pure {\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates = CLBTokenLib.tradingFeeRates();\\n\\n        uint16 absFeeRate = abs(tradingFeeRate);\\n\\n        uint256 idx = findUpperBound(_tradingFeeRates, absFeeRate);\\n        require(\\n            idx < _tradingFeeRates.length && absFeeRate == _tradingFeeRates[idx],\\n            Errors.UNSUPPORTED_TRADING_FEE_RATE\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculates the absolute value of an int16 number.\\n     * @param i The int16 number.\\n     * @return absValue The absolute value of the input number.\\n     */\\n    function abs(int16 i) private pure returns (uint16) {\\n        return i < 0 ? uint16(-i) : uint16(i);\\n    }\\n\\n    /**\\n     * @notice Finds the upper bound index of an element in a sorted array.\\n     * @dev This function performs a binary search on the sorted array\\n     *      to find * the index of the upper bound of the given element.\\n     *      It returns the index as the exclusive upper bound,\\n     *      or the inclusive upper bound if the element is found at the end of the array.\\n     * @param array The sorted array.\\n     * @param element The element to find the upper bound for.\\n     * @return uint256 The index of the upper bound of the element in the array.\\n     */\\n    function findUpperBound(\\n        uint16[FEE_RATES_LENGTH] memory array,\\n        uint16 element\\n    ) private pure returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low != 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @notice Distributes earnings among the liquidity bins.\\n     * @dev This function distributes the earnings among the liquidity bins,\\n     *      proportional to their total balances.\\n     *      It iterates through the trading fee rates\\n     *      and distributes the proportional amount of earnings to each bin\\n     *      based on its total balance relative to the market balance.\\n     * @param self The LiquidityPool storage.\\n     * @param earning The total earnings to be distributed.\\n     * @param marketBalance The market balance.\\n     */\\n    function distributeEarning(\\n        LiquidityPool storage self,\\n        uint256 earning,\\n        uint256 marketBalance\\n    ) internal {\\n        uint256 remainEarning = earning;\\n        uint256 remainBalance = marketBalance;\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates = CLBTokenLib.tradingFeeRates();\\n\\n        (remainEarning, remainBalance) = distributeEarning(\\n            self._longBins,\\n            remainEarning,\\n            remainBalance,\\n            _tradingFeeRates,\\n            \\\"L\\\"\\n        );\\n        (remainEarning, remainBalance) = distributeEarning(\\n            self._shortBins,\\n            remainEarning,\\n            remainBalance,\\n            _tradingFeeRates,\\n            \\\"S\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Distributes earnings among the liquidity bins of a specific type.\\n     * @dev This function distributes the earnings among the liquidity bins of\\n     *      the specified type, proportional to their total balances.\\n     *      It iterates through the trading fee rates\\n     *      and distributes the proportional amount of earnings to each bin\\n     *      based on its total balance relative to the market balance.\\n     * @param bins The liquidity bins mapping.\\n     * @param earning The total earnings to be distributed.\\n     * @param marketBalance The market balance.\\n     * @param _tradingFeeRates The array of supported trading fee rates.\\n     * @param binType The type of liquidity bin (\\\"L\\\" for long, \\\"S\\\" for short).\\n     * @return remainEarning The remaining earnings after distribution.\\n     * @return remainBalance The remaining market balance after distribution.\\n     */\\n    function distributeEarning(\\n        mapping(uint16 => LiquidityBin) storage bins,\\n        uint256 earning,\\n        uint256 marketBalance,\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates,\\n        bytes1 binType\\n    ) private returns (uint256 remainEarning, uint256 remainBalance) {\\n        remainBalance = marketBalance;\\n        remainEarning = earning;\\n\\n        for (uint256 i; i < FEE_RATES_LENGTH; ) {\\n            uint16 feeRate = _tradingFeeRates[i];\\n            LiquidityBin storage bin = bins[feeRate];\\n            uint256 binLiquidity = bin.liquidity();\\n\\n            if (binLiquidity == 0) {\\n                unchecked {\\n                    i++;\\n                }\\n                continue;\\n            }\\n\\n            uint256 binEarning = remainEarning.mulDiv(binLiquidity, remainBalance);\\n\\n            bin.applyEarning(binEarning);\\n\\n            remainBalance -= binLiquidity;\\n            remainEarning -= binEarning;\\n\\n            emit LiquidityBinEarningAccumulated(feeRate, binType, binEarning);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the value of a specific bin in the LiquidityPool storage for the provided trading fee rate.\\n     * @param self The reference to the LiquidityPool storage.\\n     * @param _tradingFeeRate The trading fee rate for which to calculate the bin value.\\n     * @param ctx The LP context containing relevant information for the calculation.\\n     * @return value The value of the specified bin.\\n     */\\n    function binValue(\\n        LiquidityPool storage self,\\n        int16 _tradingFeeRate,\\n        LpContext memory ctx\\n    ) internal view returns (uint256 value) {\\n        value = targetBin(self, _tradingFeeRate).value(ctx);\\n    }\\n\\n    /**\\n     * @dev Retrieves the claimable liquidity information for a specific trading fee rate and oracle version from a LiquidityPool.\\n     * @param self The reference to the LiquidityPool struct.\\n     * @param tradingFeeRate The trading fee rate for which to retrieve the claimable liquidity.\\n     * @param oracleVersion The oracle version for which to retrieve the claimable liquidity.\\n     * @return claimableLiquidity An instance of IMarketLiquidity.ClaimableLiquidity representing the claimable liquidity information.\\n     */\\n    function claimableLiquidity(\\n        LiquidityPool storage self,\\n        int16 tradingFeeRate,\\n        uint256 oracleVersion\\n    )\\n        internal\\n        view\\n        _validTradingFeeRate(tradingFeeRate)\\n        returns (IMarketLiquidity.ClaimableLiquidity memory)\\n    {\\n        LiquidityBin storage bin = targetBin(self, tradingFeeRate);\\n        return bin.claimableLiquidity(oracleVersion);\\n    }\\n\\n    /**\\n     * @dev Retrieves the liquidity bin statuses for the LiquidityPool using the provided context.\\n     * @param self The LiquidityPool storage instance.\\n     * @param ctx The LpContext containing the necessary context for calculating the bin statuses.\\n     * @return stats An array of IMarketLiquidity.LiquidityBinStatus representing the liquidity bin statuses.\\n     */\\n    function liquidityBinStatuses(\\n        LiquidityPool storage self,\\n        LpContext memory ctx\\n    ) internal view returns (IMarketLiquidity.LiquidityBinStatus[] memory) {\\n        uint16[FEE_RATES_LENGTH] memory _tradingFeeRates = CLBTokenLib.tradingFeeRates();\\n\\n        IMarketLiquidity.LiquidityBinStatus[]\\n            memory stats = new IMarketLiquidity.LiquidityBinStatus[](FEE_RATES_LENGTH * 2);\\n        for (uint256 i; i < FEE_RATES_LENGTH; ) {\\n            uint16 _feeRate = _tradingFeeRates[i];\\n            LiquidityBin storage longBin = targetBin(self, int16(_feeRate));\\n            LiquidityBin storage shortBin = targetBin(self, -int16(_feeRate));\\n\\n            stats[i] = IMarketLiquidity.LiquidityBinStatus({\\n                tradingFeeRate: int16(_feeRate),\\n                liquidity: longBin.liquidity(),\\n                freeLiquidity: longBin.freeLiquidity(),\\n                binValue: longBin.value(ctx)\\n            });\\n            stats[i + FEE_RATES_LENGTH] = IMarketLiquidity.LiquidityBinStatus({\\n                tradingFeeRate: -int16(_feeRate),\\n                liquidity: shortBin.liquidity(),\\n                freeLiquidity: shortBin.freeLiquidity(),\\n                binValue: shortBin.value(ctx)\\n            });\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return stats;\\n    }\\n}\\n\",\"keccak256\":\"0xa2540d57985de6d6ced2a8f623cba038996f39d94c461dc79fdcd91cf959ede0\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/liquidity/PositionParam.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SignedMath} from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport {UFixed18} from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport {IOracleProvider} from \\\"@chromatic-protocol/contracts/oracle/interfaces/IOracleProvider.sol\\\";\\nimport {PositionUtil} from \\\"@chromatic-protocol/contracts/core/libraries/PositionUtil.sol\\\";\\nimport {LpContext} from \\\"@chromatic-protocol/contracts/core/libraries/LpContext.sol\\\";\\n\\n/**\\n * @title PositionParam\\n * @dev A struct representing the parameters of a position.\\n */\\nstruct PositionParam {\\n    /// @dev The version of the position's open transaction\\n    uint256 openVersion;\\n    /// @dev The version of the position's close transaction\\n    uint256 closeVersion;\\n    /// @dev The leveraged quantity of the position\\n    int256 leveragedQty;\\n    /// @dev The margin amount provided by the taker\\n    uint256 takerMargin;\\n    /// @dev The margin amount provided by the maker\\n    uint256 makerMargin;\\n    /// @dev The timestamp of the position's open transaction\\n    uint256 openTimestamp;\\n    /// @dev The timestamp of the position's close transaction\\n    uint256 closeTimestamp;\\n    /// @dev Caches the settle oracle version for the position's entry\\n    IOracleProvider.OracleVersion _entryVersionCache;\\n    /// @dev Caches the settle oracle version for the position's exit\\n    IOracleProvider.OracleVersion _exitVersionCache;\\n}\\n\\nusing PositionParamLib for PositionParam global;\\n\\n/**\\n * @title PositionParamLib\\n * @notice Library for manipulating PositionParam struct.\\n */\\nlibrary PositionParamLib {\\n    using Math for uint256;\\n    using SignedMath for int256;\\n\\n    /**\\n     * @notice Returns the settle version for the position's entry.\\n     * @param self The PositionParam struct.\\n     * @return uint256 The settle version for the position's entry.\\n     */\\n    function entryVersion(PositionParam memory self) internal pure returns (uint256) {\\n        return PositionUtil.settleVersion(self.openVersion);\\n    }\\n\\n    /**\\n     * @notice Calculates the entry price for a PositionParam.\\n     * @param self The PositionParam struct.\\n     * @param ctx The LpContext struct.\\n     * @return UFixed18 The entry price.\\n     */\\n    function entryPrice(\\n        PositionParam memory self,\\n        LpContext memory ctx\\n    ) internal view returns (UFixed18) {\\n        return\\n            PositionUtil.settlePrice(\\n                ctx.oracleProvider,\\n                self.openVersion,\\n                self.entryOracleVersion(ctx)\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the entry amount for a PositionParam.\\n     * @param self The PositionParam struct.\\n     * @param ctx The LpContext struct.\\n     * @return uint256 The entry amount.\\n     */\\n    function entryAmount(\\n        PositionParam memory self,\\n        LpContext memory ctx\\n    ) internal view returns (uint256) {\\n        return PositionUtil.transactionAmount(self.leveragedQty, self.entryPrice(ctx));\\n    }\\n\\n    /**\\n     * @notice Retrieves the settle oracle version for the position's entry.\\n     * @param self The PositionParam struct.\\n     * @param ctx The LpContext struct.\\n     * @return OracleVersion The settle oracle version for the position's entry.\\n     */\\n    function entryOracleVersion(\\n        PositionParam memory self,\\n        LpContext memory ctx\\n    ) internal view returns (IOracleProvider.OracleVersion memory) {\\n        if (self._entryVersionCache.version == 0) {\\n            self._entryVersionCache = ctx.oracleVersionAt(self.entryVersion());\\n        }\\n        return self._entryVersionCache;\\n    }\\n\\n    /**\\n     * @dev Calculates the interest for a PositionParam until a specified timestamp.\\n     * @dev It is used only to deduct accumulated accrued interest when close position\\n     * @param self The PositionParam struct.\\n     * @param ctx The LpContext struct.\\n     * @param until The timestamp until which to calculate the interest.\\n     * @return uint256 The calculated interest.\\n     */\\n    function calculateInterest(\\n        PositionParam memory self,\\n        LpContext memory ctx,\\n        uint256 until\\n    ) internal view returns (uint256) {\\n        return ctx.calculateInterest(self.makerMargin, self.openTimestamp, until);\\n    }\\n\\n    /**\\n     * @notice Creates a clone of a PositionParam.\\n     * @param self The PositionParam data struct.\\n     * @return PositionParam The cloned PositionParam.\\n     */\\n    function clone(PositionParam memory self) internal pure returns (PositionParam memory) {\\n        return\\n            PositionParam({\\n                openVersion: self.openVersion,\\n                closeVersion: self.closeVersion,\\n                leveragedQty: self.leveragedQty,\\n                takerMargin: self.takerMargin,\\n                makerMargin: self.makerMargin,\\n                openTimestamp: self.openTimestamp,\\n                closeTimestamp: self.closeTimestamp,\\n                _entryVersionCache: self._entryVersionCache,\\n                _exitVersionCache: self._exitVersionCache\\n            });\\n    }\\n\\n    /**\\n     * @notice Creates the inverse of a PositionParam by negating the leveragedQty.\\n     * @param self The PositionParam data struct.\\n     * @return PositionParam The inverted PositionParam.\\n     */\\n    function inverse(PositionParam memory self) internal pure returns (PositionParam memory) {\\n        PositionParam memory param = self.clone();\\n        param.leveragedQty *= -1;\\n        return param;\\n    }\\n}\\n\",\"keccak256\":\"0x96b344b4d4694cfa13eabe5a120437ee6c841e00c5a1d24c3779041095b39907\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/registry/OracleProviderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title OracleProviderRegistry\\n * @dev A registry for managing oracle providers.\\n */\\nstruct OracleProviderRegistry {\\n    /// @dev Set of registered oracle providers\\n    EnumerableSet.AddressSet _oracleProviders;\\n    mapping(address => uint32) _minTakeProfitBPSs;\\n    mapping(address => uint32) _maxTakeProfitBPSs;\\n    mapping(address => uint8) _leverageLevels;\\n}\\n\\n/**\\n * @title OracleProviderRegistryLib\\n * @notice Library for managing a registry of oracle providers.\\n */\\nlibrary OracleProviderRegistryLib {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /**\\n     * @notice Registers an oracle provider in the registry.\\n     * @dev Throws an error with the code `Errors.ALREADY_REGISTERED_ORACLE_PROVIDER` if the oracle provider is already registered.\\n     * @param self The OracleProviderRegistry storage.\\n     * @param oracleProvider The address of the oracle provider to register.\\n     * @param minTakeProfitBPS The minimum take-profit basis points.\\n     * @param maxTakeProfitBPS The maximum take-profit basis points.\\n     * @param leverageLevel The leverage level of the oracle provider.\\n     */\\n    function register(\\n        OracleProviderRegistry storage self,\\n        address oracleProvider,\\n        uint32 minTakeProfitBPS,\\n        uint32 maxTakeProfitBPS,\\n        uint8 leverageLevel\\n    ) internal {\\n        require(\\n            !self._oracleProviders.contains(oracleProvider),\\n            Errors.ALREADY_REGISTERED_ORACLE_PROVIDER\\n        );\\n\\n        self._oracleProviders.add(oracleProvider);\\n        self._minTakeProfitBPSs[oracleProvider] = minTakeProfitBPS;\\n        self._maxTakeProfitBPSs[oracleProvider] = maxTakeProfitBPS;\\n        self._leverageLevels[oracleProvider] = leverageLevel;\\n    }\\n\\n    /**\\n     * @notice Unregisters an oracle provider from the registry.\\n     * @param self The OracleProviderRegistry storage.\\n     * @param oracleProvider The address of the oracle provider to unregister.\\n     */\\n    function unregister(OracleProviderRegistry storage self, address oracleProvider) internal {\\n        self._oracleProviders.remove(oracleProvider);\\n    }\\n\\n    /**\\n     * @notice Returns an array of all registered oracle providers.\\n     * @param self The OracleProviderRegistry storage.\\n     * @return oracleProviders An array of addresses representing the registered oracle providers.\\n     */\\n    function oracleProviders(\\n        OracleProviderRegistry storage self\\n    ) internal view returns (address[] memory) {\\n        return self._oracleProviders.values();\\n    }\\n\\n    /**\\n     * @notice Checks if an oracle provider is registered in the registry.\\n     * @param self The OracleProviderRegistry storage.\\n     * @param oracleProvider The address of the oracle provider to check.\\n     * @return bool Whether the oracle provider is registered.\\n     */\\n    function isRegistered(\\n        OracleProviderRegistry storage self,\\n        address oracleProvider\\n    ) internal view returns (bool) {\\n        return self._oracleProviders.contains(oracleProvider);\\n    }\\n\\n    /**\\n     * @notice Retrieves the properties of an oracle provider.\\n     * @param self The OracleProviderRegistry storage.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @return minTakeProfitBPS The minimum take-profit basis points.\\n     * @return maxTakeProfitBPS The maximum take-profit basis points.\\n     * @return leverageLevel The leverage level of the oracle provider.\\n     */\\n    function getOracleProviderProperties(\\n        OracleProviderRegistry storage self,\\n        address oracleProvider\\n    )\\n        internal\\n        view\\n        returns (uint32 minTakeProfitBPS, uint32 maxTakeProfitBPS, uint8 leverageLevel)\\n    {\\n        minTakeProfitBPS = self._minTakeProfitBPSs[oracleProvider];\\n        maxTakeProfitBPS = self._maxTakeProfitBPSs[oracleProvider];\\n        leverageLevel = self._leverageLevels[oracleProvider];\\n    }\\n\\n    /**\\n     * @notice Sets the range for take-profit basis points for an oracle provider.\\n     * @param self The OracleProviderRegistry storage.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param minTakeProfitBPS The minimum take-profit basis points.\\n     * @param maxTakeProfitBPS The maximum take-profit basis points.\\n     */\\n    function setTakeProfitBPSRange(\\n        OracleProviderRegistry storage self,\\n        address oracleProvider,\\n        uint32 minTakeProfitBPS,\\n        uint32 maxTakeProfitBPS\\n    ) internal {\\n        self._minTakeProfitBPSs[oracleProvider] = minTakeProfitBPS;\\n        self._maxTakeProfitBPSs[oracleProvider] = maxTakeProfitBPS;\\n    }\\n\\n    /**\\n     * @notice Sets the leverage level of an oracle provider in the registry.\\n     * @dev The leverage level must be either 0 or 1, and the max leverage must be x10 for level 0 or x20 for level 1.\\n     * @param self The storage reference to the OracleProviderRegistry.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param leverageLevel The new leverage level to be set for the oracle provider.\\n     */\\n    function setLeverageLevel(\\n        OracleProviderRegistry storage self,\\n        address oracleProvider,\\n        uint8 leverageLevel\\n    ) internal {\\n        self._leverageLevels[oracleProvider] = leverageLevel;\\n    }\\n}\\n\",\"keccak256\":\"0xd5b33ec1da744a44feb607900afb48b2daba695d22d94d3d6742a4da296e31e7\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/registry/SettlementTokenRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {InterestRate} from \\\"@chromatic-protocol/contracts/core/libraries/InterestRate.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title SettlementTokenRegistry\\n * @dev A registry for managing settlement tokens and their associated parameters.\\n */\\nstruct SettlementTokenRegistry {\\n    /// @dev Set of registered settlement tokens\\n    EnumerableSet.AddressSet _tokens;\\n    /// @dev Mapping of settlement tokens to their interest rate records\\n    mapping(address => InterestRate.Record[]) _interestRateRecords;\\n    /// @dev Mapping of settlement tokens to their minimum margins\\n    mapping(address => uint256) _minimumMargins;\\n    /// @dev Mapping of settlement tokens to their flash loan fee rates\\n    mapping(address => uint256) _flashLoanFeeRates;\\n    /// @dev Mapping of settlement tokens to their earning distribution thresholds\\n    mapping(address => uint256) _earningDistributionThresholds;\\n    /// @dev Mapping of settlement tokens to their Uniswap fee tiers\\n    mapping(address => uint24) _uniswapFeeTiers;\\n}\\n\\n/**\\n * @title SettlementTokenRegistryLib\\n * @notice Library for managing the settlement token registry.\\n */\\nlibrary SettlementTokenRegistryLib {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using InterestRate for InterestRate.Record[];\\n\\n    /**\\n     * @notice Modifier to check if a token is registered in the settlement token registry.\\n     * @dev Throws an error with the code `Errors.UNREGISTERED_TOKEN` if the settlement token is not registered.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the token to check.\\n     */\\n    modifier registeredOnly(SettlementTokenRegistry storage self, address token) {\\n        require(self._tokens.contains(token), Errors.UNREGISTERED_TOKEN);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Registers a token in the settlement token registry.\\n     * @dev Throws an error with the code `Errors.ALREADY_REGISTERED_TOKEN` if the settlement token is already registered.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the token to register.\\n     * @param minimumMargin The minimum margin for the token.\\n     * @param interestRate The initial interest rate for the token.\\n     * @param flashLoanFeeRate The flash loan fee rate for the token.\\n     * @param earningDistributionThreshold The earning distribution threshold for the token.\\n     * @param uniswapFeeTier The Uniswap fee tier for the token.\\n     */\\n    function register(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint256 minimumMargin,\\n        uint256 interestRate,\\n        uint256 flashLoanFeeRate,\\n        uint256 earningDistributionThreshold,\\n        uint24 uniswapFeeTier\\n    ) internal {\\n        require(self._tokens.add(token), Errors.ALREADY_REGISTERED_TOKEN);\\n\\n        self._interestRateRecords[token].initialize(interestRate);\\n        self._minimumMargins[token] = minimumMargin;\\n        self._flashLoanFeeRates[token] = flashLoanFeeRate;\\n        self._earningDistributionThresholds[token] = earningDistributionThreshold;\\n        self._uniswapFeeTiers[token] = uniswapFeeTier;\\n    }\\n\\n    /**\\n     * @notice Returns an array of all registered settlement tokens.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @return An array of addresses representing the registered settlement tokens.\\n     */\\n    function settlementTokens(\\n        SettlementTokenRegistry storage self\\n    ) internal view returns (address[] memory) {\\n        return self._tokens.values();\\n    }\\n\\n    /**\\n     * @notice Checks if a token is registered in the settlement token registry.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the token to check.\\n     * @return bool Whether the token is registered.\\n     */\\n    function isRegistered(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view returns (bool) {\\n        return self._tokens.contains(token);\\n    }\\n\\n    /**\\n     * @notice Retrieves the minimum margin for a asettlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the asettlement token.\\n     * @return uint256 The minimum margin for the asettlement token.\\n     */\\n    function getMinimumMargin(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view returns (uint256) {\\n        return self._minimumMargins[token];\\n    }\\n\\n    /**\\n     * @notice Sets the minimum margin for asettlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @param minimumMargin The new minimum margin for the settlement token.\\n     */\\n    function setMinimumMargin(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint256 minimumMargin\\n    ) internal {\\n        self._minimumMargins[token] = minimumMargin;\\n    }\\n\\n    /**\\n     * @notice Retrieves the flash loan fee rate for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @return uint256 The flash loan fee rate for the settlement token.\\n     */\\n    function getFlashLoanFeeRate(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view returns (uint256) {\\n        return self._flashLoanFeeRates[token];\\n    }\\n\\n    /**\\n     * @notice Sets the flash loan fee rate for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @param flashLoanFeeRate The new flash loan fee rate for the settlement token.\\n     */\\n    function setFlashLoanFeeRate(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint256 flashLoanFeeRate\\n    ) internal {\\n        self._flashLoanFeeRates[token] = flashLoanFeeRate;\\n    }\\n\\n    /**\\n     * @notice Retrieves the earning distribution threshold for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @return uint256 The earning distribution threshold for the token.\\n     */\\n    function getEarningDistributionThreshold(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view returns (uint256) {\\n        return self._earningDistributionThresholds[token];\\n    }\\n\\n    /**\\n     * @notice Sets the earning distribution threshold for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @param earningDistributionThreshold The new earning distribution threshold for the settlement token.\\n     */\\n    function setEarningDistributionThreshold(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint256 earningDistributionThreshold\\n    ) internal {\\n        self._earningDistributionThresholds[token] = earningDistributionThreshold;\\n    }\\n\\n    /**\\n     * @notice Retrieves the Uniswap fee tier for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @return uint24 The Uniswap fee tier for the settlement token.\\n     */\\n    function getUniswapFeeTier(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view returns (uint24) {\\n        return self._uniswapFeeTiers[token];\\n    }\\n\\n    /**\\n     * @notice Sets the Uniswap fee tier for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @param uniswapFeeTier The new Uniswap fee tier for the settlement token.\\n     */\\n    function setUniswapFeeTier(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint24 uniswapFeeTier\\n    ) internal {\\n        self._uniswapFeeTiers[token] = uniswapFeeTier;\\n    }\\n\\n    /**\\n     * @notice Appends an interest rate record for a settlement token.\\n     * @dev Throws an error if the settlement token is not registered.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points.\\n     * @param beginTimestamp The timestamp when the interest rate begins.\\n     */\\n    function appendInterestRateRecord(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint256 annualRateBPS,\\n        uint256 beginTimestamp\\n    ) internal registeredOnly(self, token) {\\n        getInterestRateRecords(self, token).appendRecord(annualRateBPS, beginTimestamp);\\n    }\\n\\n    /**\\n     * @notice Removes the last interest rate record for a settlement token.\\n     * @dev The current time must be less than the begin timestamp of the last record.\\n     *      Throws an error with the code `Errors.INTEREST_RATE_ALREADY_APPLIED` if not.\\n     * @dev Throws an error if the settlement token is not registered.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @return removed Whether the removal was successful\\n     * @return record The removed interest rate record.\\n     */\\n    function removeLastInterestRateRecord(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    )\\n        internal\\n        registeredOnly(self, token)\\n        returns (bool removed, InterestRate.Record memory record)\\n    {\\n        (removed, record) = getInterestRateRecords(self, token).removeLastRecord();\\n    }\\n\\n    /**\\n     * @notice Retrieves the current interest rate for a settlement token.\\n     * @dev Throws an error if the settlement token is not registered.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @return annualRateBPS The current annual interest rate in basis points.\\n     */\\n    function currentInterestRate(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view registeredOnly(self, token) returns (uint256 annualRateBPS) {\\n        (InterestRate.Record memory record, ) = getInterestRateRecords(self, token).findRecordAt(\\n            block.timestamp\\n        );\\n        return record.annualRateBPS;\\n    }\\n\\n    /**\\n     * @notice Calculates the interest accrued for a settlement token within a specified time range.\\n     * @dev Throws an error if the token is not registered.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @param amount The amount of settlement tokens to calculate interest for.\\n     * @param from The starting timestamp of the interest calculation (inclusive).\\n     * @param to The ending timestamp of the interest calculation (exclusive).\\n     * @return uint256 The calculated interest amount.\\n     */\\n    function calculateInterest(\\n        SettlementTokenRegistry storage self,\\n        address token,\\n        uint256 amount,\\n        uint256 from, // timestamp (inclusive)\\n        uint256 to // timestamp (exclusive)\\n    ) internal view registeredOnly(self, token) returns (uint256) {\\n        return getInterestRateRecords(self, token).calculateInterest(amount, from, to);\\n    }\\n\\n    /**\\n     * @notice Retrieves the array of interest rate records for a settlement token.\\n     * @param self The SettlementTokenRegistry storage.\\n     * @param token The address of the settlement token.\\n     * @return The array of interest rate records.\\n     */\\n    function getInterestRateRecords(\\n        SettlementTokenRegistry storage self,\\n        address token\\n    ) internal view returns (InterestRate.Record[] storage) {\\n        return self._interestRateRecords[token];\\n    }\\n}\\n\",\"keccak256\":\"0xfcab05ac04f27a0ca8ccfdf1d8cc53ab2f4178755ebdbed5c40cbfff69122fd9\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/interfaces/IOracleProvider.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@equilibria/root/number/types/Fixed18.sol\\\";\\n\\ninterface IOracleProvider {\\n    /// @dev Error for invalid oracle round\\n    error InvalidOracleRound();\\n\\n    /// @dev A singular oracle version with its corresponding data\\n    struct OracleVersion {\\n        /// @dev The iterative version\\n        uint256 version;\\n        /// @dev the timestamp of the oracle update\\n        uint256 timestamp;\\n        /// @dev The oracle price of the corresponding version\\n        Fixed18 price;\\n    }\\n\\n    /**\\n     * @notice Checks for a new price and updates the internal phase annotation state accordingly\\n     * @dev `sync` is expected to be called soon after a phase update occurs in the underlying proxy.\\n     *      Phase updates should be detected using off-chain mechanism and should trigger a `sync` call\\n     *      This is feasible in the short term due to how infrequent phase updates are, but phase update\\n     *      and roundCount detection should eventually be implemented at the contract level.\\n     *      Reverts if there is more than 1 phase to update in a single sync because we currently cannot\\n     *      determine the startingRoundId for the intermediary phase.\\n     * @return The current oracle version after sync\\n     */\\n    function sync() external returns (OracleVersion memory);\\n\\n    /**\\n     * @notice Returns the current oracle version\\n     * @return oracleVersion Current oracle version\\n     */\\n    function currentVersion() external view returns (OracleVersion memory);\\n\\n    /**\\n     * @notice Returns the current oracle version\\n     * @param version The version of which to lookup\\n     * @return oracleVersion Oracle version at version `version`\\n     */\\n    function atVersion(uint256 version) external view returns (OracleVersion memory);\\n\\n    /**\\n     * @notice Retrieves the description of the Oracle Provider.\\n     * @return A string representing the description of the Oracle Provider.\\n     */\\n    function description() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xf2e30383ce5fd655ef41c85262416fa82eb12dcdff9a72580316e78d5bee86d5\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620035c7380380620035c78339810160408190526200003491620000ea565b60008054336001600160a01b031991821681179092556004805482169092179091556005805482166001600160a01b03998a16179055600680548216978916979097179096556007805487169588169590951790945560088054861693871693909317909255600980548516918616919091179055600a80548416918516919091179055600b805490921692169190911790556200017f565b80516001600160a01b0381168114620000e557600080fd5b919050565b600080600080600080600060e0888a0312156200010657600080fd5b6200011188620000cd565b96506200012160208901620000cd565b95506200013160408901620000cd565b94506200014160608901620000cd565b93506200015160808901620000cd565b92506200016160a08901620000cd565b91506200017160c08901620000cd565b905092959891949750929550565b613438806200018f6000396000f3fe608060405234801561001057600080fd5b50600436106102ad5760003560e01c8063705b170e1161017b578063b38e8bc6116100d8578063ec2c90161161008c578063fbfa77cf11610071578063fbfa77cf14610673578063fc3e902614610693578063fddd4d8f146106a657600080fd5b8063ec2c901614610658578063f76443201461066057600080fd5b8063e4517f09116100bd578063e4517f091461061f578063e4f7b8a914610632578063ea38ff331461064557600080fd5b8063b38e8bc6146105f9578063dc2d7f181461060c57600080fd5b8063890357301161012f578063a1edd04611610114578063a1edd046146105c0578063a7f557d4146105d3578063a8c885af146105e657600080fd5b80638903573014610544578063919c0653146105ad57600080fd5b80637f51bb1f116101605780637f51bb1f146104e6578063827f909f146104f9578063861bef211461050157600080fd5b8063705b170e146104c0578063714af34b146104d357600080fd5b806333c9d5d7116102295780635b5b52c0116101dd57806367250c95116101c257806367250c95146104735780636817031b1461049a5780636cfaa541146104ad57600080fd5b80635b5b52c01461043357806361d027b31461045357600080fd5b80634162169f1161020e5780634162169f146103dd5780634a58e49e146103fd5780634ba1c3781461042057600080fd5b806333c9d5d7146103855780634046ebae1461039857600080fd5b8063207fd1261161028057806327633b5b1161026557806327633b5b1461034c57806328abb7631461035f5780632f4ce9761461037257600080fd5b8063207fd1261461031857806324b101981461032b57600080fd5b806301c76f81146102b257806306216c37146102c75780630ae29d04146102e55780630e1a4f0d146102f8575b600080fd5b6102c56102c0366004612e9f565b6106b9565b005b6102cf6107c9565b6040516102dc9190612ebc565b60405180910390f35b6102c56102f3366004612f16565b6107da565b61030b610306366004612e9f565b61087f565b6040516102dc9190612f42565b6102c5610326366004612f91565b610918565b61033e610339366004612e9f565b610cb6565b6040519081526020016102dc565b61033e61035a366004612e9f565b610cc9565b61033e61036d366004612e9f565b610cf4565b6102c5610380366004612f16565b610d1f565b6102c5610393366004612e9f565b610dc4565b6001546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016102dc565b6000546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b61041061040b366004612e9f565b610e64565b60405190151581526020016102dc565b6102c561042e366004612fe2565b610e71565b6003546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b6004546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b610486610481366004612e9f565b610f44565b60405162ffffff90911681526020016102dc565b6102c56104a8366004612e9f565b610f74565b6102c56104bb366004613017565b611084565b61033e6104ce36600461304c565b61112c565b6103b86104e1366004612f91565b611145565b6102c56104f4366004612e9f565b611310565b6102cf6113d0565b61051461050f366004612e9f565b6113dc565b60408051825163ffffffff9081168252602080850151909116908201529181015160ff16908201526060016102dc565b6105806040805180820190915260185473ffffffffffffffffffffffffffffffffffffffff908116808352601954909116602090920182905291565b6040805173ffffffffffffffffffffffffffffffffffffffff9384168152929091166020830152016102dc565b6102c56105bb366004613098565b6114a2565b6104106105ce366004612e9f565b6115c7565b6102c56105e13660046130c4565b6115d4565b6102c56105f4366004612e9f565b6117b8565b6102c5610607366004612e9f565b611876565b61041061061a366004612e9f565b61192d565b6102c561062d366004613132565b61193a565b6102c5610640366004612f16565b611a16565b6102c5610653366004612e9f565b611abb565b6102cf611bcb565b6102c561066e36600461320c565b611bd7565b6002546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b6102cf6106a1366004612e9f565b611d0a565b61033e6106b4366004612e9f565b611d9a565b60005473ffffffffffffffffffffffffffffffffffffffff16331461070a576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60015473ffffffffffffffffffffffffffffffffffffffff161561075a576040517fb209caed00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f111c6aeb2006d748bdae2ddf082866e6ce7eb3d48ef324b5d9547570f5694e4f90600090a250565b60606107d56011611dc5565b905090565b60005473ffffffffffffffffffffffffffffffffffffffff16331461082b576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8216600081815260146020526040808220849055518392917f4c0223e719940189ef3681b9c0f0450c816c7a262c1963087e3a4911f3bccf5191a35050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152601360205260409020606090805480602002602001604051908101604052809291908181526020016000905b8282101561090d578382906000526020600020906002020160405180604001604052908160008201548152602001600182015481525050815260200190600101906108c7565b505050509050919050565b81610924600c82611dd0565b61095a576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610965601183611dd0565b61099b576040517f12a5f55200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8084166000908152601a602090815260408083209386168352929052205460ff1615610a08576040517fde70de2200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600554600654600754600854600954600a54600b546040517faeb856e30000000000000000000000000000000000000000000000000000000081526018600482015273ffffffffffffffffffffffffffffffffffffffff808c166024830152808b1660448301529788166064820152958716608487015293861660a486015291851660c4850152841660e484015283166101048301529190911661012482015260009073AC66D4d89639dF6A0C4333d0e2B16872FB24eeD99063aeb856e39061014401602060405180830381865af4158015610ae8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0c9190613251565b73ffffffffffffffffffffffffffffffffffffffff8581166000908152601a6020908152604080832088851684528252808320805460017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff009091168117909155601b835290832080549182018155835291200180547fffffffffffffffffffffffff0000000000000000000000000000000000000000169183169190911790559050610bb9601c82611de3565b506002546040517fc440a65c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301529091169063c440a65c90602401600060405180830381600087803b158015610c2757600080fd5b505af1158015610c3b573d6000803e3d6000fd5b505050508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167fe63e6130091e2155004c4b5ac35e8fb9be704d6637ff3068a8f710ba36c9f41a60405160405180910390a450505050565b6000610cc3601183611e05565b92915050565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260146020526040812054610cc3565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260156020526040812054610cc3565b60005473ffffffffffffffffffffffffffffffffffffffff163314610d70576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8216600081815260166020526040808220849055518392917fad9146057238aa90fc2f022eed688ed9c094d5b01a070c1d9ed7140ae1e90b5a91a35050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610e15576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610e20600c82611ec8565b60405173ffffffffffffffffffffffffffffffffffffffff8216907f2204279f4b3dc089ca3bb773580383cc44d6d1414667f78def48751c811422d090600090a250565b6000610cc3601c83611ed2565b60005473ffffffffffffffffffffffffffffffffffffffff163314610ec2576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff821660008181526017602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000001662ffffff861690811790915590519092917fdb5545d4da29cde71057a77fa9788f26638ed7c232145a360e250d112462286a91a35050565b73ffffffffffffffffffffffffffffffffffffffff811660009081526017602052604081205462ffffff16610cc3565b60005473ffffffffffffffffffffffffffffffffffffffff163314610fc5576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025473ffffffffffffffffffffffffffffffffffffffff1615611015576040517fb661034d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517fd459c7242e23d490831b5676a611c4342d899d28f342d89ae80793e56a930f3090600090a250565b60005473ffffffffffffffffffffffffffffffffffffffff1633146110d5576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6110e26011848484611f01565b80828473ffffffffffffffffffffffffffffffffffffffff167ff88fac6bf5acd4c3248b702ace956ada3aed01acc26526e8d25e264af2bd28e860405160405180910390a4505050565b600061113c601186868686611fb6565b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff8083166000908152601a6020908152604080832093851683529290529081205460ff1661118957506000610cc3565b73ffffffffffffffffffffffffffffffffffffffff82166000908152601b602090815260408083208054825181850281018501909352808352919290919083018282801561120d57602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff1681526001909101906020018083116111e2575b5050505050905060005b8151811015611305578473ffffffffffffffffffffffffffffffffffffffff168282815181106112495761124961326e565b602002602001015173ffffffffffffffffffffffffffffffffffffffff16630aa7d2f96040518163ffffffff1660e01b8152600401602060405180830381865afa15801561129b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bf9190613251565b73ffffffffffffffffffffffffffffffffffffffff16036112fd578181815181106112ec576112ec61326e565b602002602001015192505050610cc3565b600101611217565b506000949350505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611361576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600480547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f1f54d231bb9d500b1923e4a1cb25e600f366a8368873d9af7c1c623814df19fc90600090a250565b60606107d5600c611dc5565b604080516060810182526000808252602082018190529181019190915281611405600c82611dd0565b61143b576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505073ffffffffffffffffffffffffffffffffffffffff166000908152600e6020908152604080832054600f835281842054601084529382902054825160608101845263ffffffff9283168152919094169281019290925260ff9092169181019190915290565b60005473ffffffffffffffffffffffffffffffffffffffff1633146114f3576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816114ff600c82611dd0565b611535576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60018260ff16111561154657600080fd5b73ffffffffffffffffffffffffffffffffffffffff831660008181526010602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660ff871690811790915590519092917f8a1c882c046939115ffa25c4b35cc2c2f2950b67b62295c136ecc4a6ab67f9ac91a3505050565b6000610cc3600c83611dd0565b60005473ffffffffffffffffffffffffffffffffffffffff163314611625576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611635601187878787878761207d565b6003546040517ff900a8b400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8881166004830152600160248301529091169063f900a8b490604401600060405180830381600087803b1580156116a957600080fd5b505af11580156116bd573d6000803e3d6000fd5b50506002546040517f687d5dd400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152909116925063687d5dd49150602401600060405180830381600087803b15801561172e57600080fd5b505af1158015611742573d6000803e3d6000fd5b5050505083858773ffffffffffffffffffffffffffffffffffffffff167f24b44a8fe42510e0d47e78dc5be1fcf5ab09678e39e793881b17b75536c1c11b8686866040516117a893929190928352602083019190915262ffffff16604082015260600190565b60405180910390a4505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611809576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8316908117825560405190917f9a2ad28991c4a863dd3516183dfda4db8e8aa1c0e550a73570b1c4616301cbc691a250565b60005473ffffffffffffffffffffffffffffffffffffffff1633146118c7576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000806118d56011846121bc565b915091508115611928576020810151815160405173ffffffffffffffffffffffffffffffffffffffff8616907f87cc7629e5df6261b917b2a00b3640c9e8a60161f4018a2285189d10f08540e190600090a45b505050565b6000610cc3601183611dd0565b60005473ffffffffffffffffffffffffffffffffffffffff16331461198b576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8051602082015160408301516119a592600c928692612293565b60408051825163ffffffff9081168252602080850151909116908201528282015160ff1681830152905173ffffffffffffffffffffffffffffffffffffffff8416917ff99b41a10d1100eaee0ac166534e61bcabeb6bb3a1b683368130fc6b7a5ae4e4919081900360600190a25050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611a67576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8216600081815260156020526040808220849055518392917fed3e1e456a52cdc00b8ea60fb4aae37d7e76d31b3e8e7a5581af66fb75e538a391a35050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611b0c576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60035473ffffffffffffffffffffffffffffffffffffffff1615611b5c576040517f85295cee00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f66a0284e74772dd27a28a7555f29db18bb60baa297a3d8bd5ca654309d6efb3890600090a250565b60606107d5601c6123cb565b60005473ffffffffffffffffffffffffffffffffffffffff163314611c28576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82611c34600c82611dd0565b611c6a576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff84166000818152600e6020908152604080832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000090811663ffffffff8a8116918217909355600f909452828520805490911691881691821790559051909391927fb68a23d4ed61e96aba80d9f6099f4b9b69af02096eea143d56fb385ea97ad3d791a450505050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152601b6020908152604091829020805483518184028101840190945280845260609392830182828015611d8e57602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff168152600190910190602001808311611d63575b50505050509050919050565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260166020526040812054610cc3565b6060610cc3826123cb565b6000611ddc8383611ed2565b9392505050565b6000611ddc8373ffffffffffffffffffffffffffffffffffffffff84166123d8565b60008282611e138282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090611e8a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b60405180910390fd5b5073ffffffffffffffffffffffffffffffffffffffff841660009081526002860160205260408120611ebc9042612427565b50519695505050505050565b6119288282612575565b73ffffffffffffffffffffffffffffffffffffffff811660009081526001830160205260408120541515611ddc565b8383611f0d8282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090611f7b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5073ffffffffffffffffffffffffffffffffffffffff851660009081526002870160205260409020611fae908585612597565b505050505050565b60008585611fc48282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090612032576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b506120718686866120698c8c73ffffffffffffffffffffffffffffffffffffffff1660009081526002919091016020526040902090565b9291906127ec565b98975050505050505050565b6120878787611de3565b6040518060400160405280600381526020017f4152540000000000000000000000000000000000000000000000000000000000815250906120f5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5073ffffffffffffffffffffffffffffffffffffffff959095166000818152600288810160209081526040808420815180830183529889528883018581528154600180820184559287528487209a5195029099019384559751929097019190915591815260038801825284812095909555600487018152838520929092556005860182528284205560069094019093529190912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000001662ffffff909216919091179055565b60006121db604051806040016040528060008152602001600081525090565b83836121e78282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090612255576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5073ffffffffffffffffffffffffffffffffffffffff85166000908152600287016020526040902061228690612973565b9097909650945050505050565b61229d8585611ed2565b156040518060400160405280600381526020017f41524f00000000000000000000000000000000000000000000000000000000008152509061230c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b506123178585611de3565b5073ffffffffffffffffffffffffffffffffffffffff90931660009081526002850160209081526040808320805463ffffffff9687167fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000918216179091556003880183528184208054959096169416939093179093556004909401909152909120805460ff9092167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00909216919091179055565b60606000611ddc83612b51565b600081815260018301602052604081205461241f57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610cc3565b506000610cc3565b6040805180820190915260008082526020820152825460408051808201909152600481527f49524e490000000000000000000000000000000000000000000000000000000060208201526000918591906124ae576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5084545b801561252e576001810392508583815481106124d0576124d061326e565b600091825260209182902060408051808201909152600290920201805482526001015491810182905294508510612507575061256d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016124b2565b50846000815481106125425761254261326e565b6000918252602080832060408051808201909152600290930201805483526001015490820152935091505b509250929050565b6000611ddc8373ffffffffffffffffffffffffffffffffffffffff8416612bac565b825460408051808201909152600481527f49524e490000000000000000000000000000000000000000000000000000000060208201528491612606576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5060408051808201909152600481527f49524f46000000000000000000000000000000000000000000000000000000006020820152612710841115612678576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5060408051808201909152600481527f495250540000000000000000000000000000000000000000000000000000000060208201524283116126e7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b50835460009085906126fb90600190613338565b8154811061270b5761270b61326e565b9060005260206000209060020201604051806040016040529081600082015481526020016001820154815250509050806020015183116040518060400160405280600481526020017f49524e4100000000000000000000000000000000000000000000000000000000815250906127af576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5050604080518082019091529283525060208083019182528354600181810186556000958652919094209251600290940290920192835551910155565b835460408051808201909152600481527f49524e4900000000000000000000000000000000000000000000000000000000602082015260009186919061285f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b50828410612870576000915061296a565b85546000907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905b8015612964576000896128ac600184613338565b815481106128bc576128bc61326e565b90600052602060002090600202016040518060400160405290816000820154815260200160018201548152505090508783116128f85750612964565b61292889826000015161290f8b8560200151612c9f565b6129198b88612cb5565b6129239190613338565b612cc4565b612932908561334b565b60209091015190935091507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01612898565b50909250505b50949350505050565b6000612992604051806040016040528060008152602001600081525090565b825460408051808201909152600481527f49524e490000000000000000000000000000000000000000000000000000000060208201528491612a01576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b508354600110612a2d576000604051806040016040528060008152602001600081525092509250612b4b565b83546000908590612a4090600190613338565b81548110612a5057612a5061326e565b9060005260206000209060020201604051806040016040529081600082015481526020016001820154815250509050806020015142106040518060400160405280600481526020017f495241410000000000000000000000000000000000000000000000000000000081525090612af4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5084805480612b0557612b0561335e565b60008281526020812060027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909301928302018181556001908101919091559155935091505b50915091565b606081600001805480602002602001604051908101604052809291908181526020018280548015611d8e57602002820191906000526020600020905b815481526020019060010190808311612b8d5750505050509050919050565b60008181526001830160205260408120548015612c95576000612bd0600183613338565b8554909150600090612be490600190613338565b9050818114612c49576000866000018281548110612c0457612c0461326e565b9060005260206000200154905080876000018481548110612c2757612c2761326e565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080612c5a57612c5a61335e565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610cc3565b6000915050610cc3565b6000818311612cae5781611ddc565b5090919050565b6000818310612cae5781611ddc565b6000612ced612cd3838561338d565b612ce36301e1338061271061338d565b8691906001612cf5565b949350505050565b600080612d03868686612d50565b90506001836002811115612d1957612d196133a4565b148015612d36575060008480612d3157612d316133d3565b868809115b1561113c57612d4660018261334b565b9695505050505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85870985870292508281108382030391505080600003612da857838281612d9e57612d9e6133d3565b0492505050611ddc565b808411612e11576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4d6174683a206d756c446976206f766572666c6f7700000000000000000000006044820152606401611e81565b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114612e9c57600080fd5b50565b600060208284031215612eb157600080fd5b8135611ddc81612e7a565b6020808252825182820181905260009190848201906040850190845b81811015612f0a57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101612ed8565b50909695505050505050565b60008060408385031215612f2957600080fd5b8235612f3481612e7a565b946020939093013593505050565b602080825282518282018190526000919060409081850190868401855b82811015612f8457815180518552860151868501529284019290850190600101612f5f565b5091979650505050505050565b60008060408385031215612fa457600080fd5b8235612faf81612e7a565b91506020830135612fbf81612e7a565b809150509250929050565b803562ffffff81168114612fdd57600080fd5b919050565b60008060408385031215612ff557600080fd5b823561300081612e7a565b915061300e60208401612fca565b90509250929050565b60008060006060848603121561302c57600080fd5b833561303781612e7a565b95602085013595506040909401359392505050565b6000806000806080858703121561306257600080fd5b843561306d81612e7a565b966020860135965060408601359560600135945092505050565b803560ff81168114612fdd57600080fd5b600080604083850312156130ab57600080fd5b82356130b681612e7a565b915061300e60208401613087565b60008060008060008060c087890312156130dd57600080fd5b86356130e881612e7a565b95506020870135945060408701359350606087013592506080870135915061311260a08801612fca565b90509295509295509295565b803563ffffffff81168114612fdd57600080fd5b600080828403608081121561314657600080fd5b833561315181612e7a565b925060607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08201121561318357600080fd5b506040516060810181811067ffffffffffffffff821117156131ce577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040526131dd6020850161311e565b81526131eb6040850161311e565b60208201526131fc60608501613087565b6040820152809150509250929050565b60008060006060848603121561322157600080fd5b833561322c81612e7a565b925061323a6020850161311e565b91506132486040850161311e565b90509250925092565b60006020828403121561326357600080fd5b8151611ddc81612e7a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060208083528351808285015260005b818110156132ca578581018301518582016040015282016132ae565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610cc357610cc3613309565b80820180821115610cc357610cc3613309565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b8082028115828204841417610cc357610cc3613309565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fdfea2646970667358221220dc6e7b2d70a59f3e788ec7b018e0ab0855590a0fe789ceb5043dc9ea475a024b64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102ad5760003560e01c8063705b170e1161017b578063b38e8bc6116100d8578063ec2c90161161008c578063fbfa77cf11610071578063fbfa77cf14610673578063fc3e902614610693578063fddd4d8f146106a657600080fd5b8063ec2c901614610658578063f76443201461066057600080fd5b8063e4517f09116100bd578063e4517f091461061f578063e4f7b8a914610632578063ea38ff331461064557600080fd5b8063b38e8bc6146105f9578063dc2d7f181461060c57600080fd5b8063890357301161012f578063a1edd04611610114578063a1edd046146105c0578063a7f557d4146105d3578063a8c885af146105e657600080fd5b80638903573014610544578063919c0653146105ad57600080fd5b80637f51bb1f116101605780637f51bb1f146104e6578063827f909f146104f9578063861bef211461050157600080fd5b8063705b170e146104c0578063714af34b146104d357600080fd5b806333c9d5d7116102295780635b5b52c0116101dd57806367250c95116101c257806367250c95146104735780636817031b1461049a5780636cfaa541146104ad57600080fd5b80635b5b52c01461043357806361d027b31461045357600080fd5b80634162169f1161020e5780634162169f146103dd5780634a58e49e146103fd5780634ba1c3781461042057600080fd5b806333c9d5d7146103855780634046ebae1461039857600080fd5b8063207fd1261161028057806327633b5b1161026557806327633b5b1461034c57806328abb7631461035f5780632f4ce9761461037257600080fd5b8063207fd1261461031857806324b101981461032b57600080fd5b806301c76f81146102b257806306216c37146102c75780630ae29d04146102e55780630e1a4f0d146102f8575b600080fd5b6102c56102c0366004612e9f565b6106b9565b005b6102cf6107c9565b6040516102dc9190612ebc565b60405180910390f35b6102c56102f3366004612f16565b6107da565b61030b610306366004612e9f565b61087f565b6040516102dc9190612f42565b6102c5610326366004612f91565b610918565b61033e610339366004612e9f565b610cb6565b6040519081526020016102dc565b61033e61035a366004612e9f565b610cc9565b61033e61036d366004612e9f565b610cf4565b6102c5610380366004612f16565b610d1f565b6102c5610393366004612e9f565b610dc4565b6001546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016102dc565b6000546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b61041061040b366004612e9f565b610e64565b60405190151581526020016102dc565b6102c561042e366004612fe2565b610e71565b6003546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b6004546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b610486610481366004612e9f565b610f44565b60405162ffffff90911681526020016102dc565b6102c56104a8366004612e9f565b610f74565b6102c56104bb366004613017565b611084565b61033e6104ce36600461304c565b61112c565b6103b86104e1366004612f91565b611145565b6102c56104f4366004612e9f565b611310565b6102cf6113d0565b61051461050f366004612e9f565b6113dc565b60408051825163ffffffff9081168252602080850151909116908201529181015160ff16908201526060016102dc565b6105806040805180820190915260185473ffffffffffffffffffffffffffffffffffffffff908116808352601954909116602090920182905291565b6040805173ffffffffffffffffffffffffffffffffffffffff9384168152929091166020830152016102dc565b6102c56105bb366004613098565b6114a2565b6104106105ce366004612e9f565b6115c7565b6102c56105e13660046130c4565b6115d4565b6102c56105f4366004612e9f565b6117b8565b6102c5610607366004612e9f565b611876565b61041061061a366004612e9f565b61192d565b6102c561062d366004613132565b61193a565b6102c5610640366004612f16565b611a16565b6102c5610653366004612e9f565b611abb565b6102cf611bcb565b6102c561066e36600461320c565b611bd7565b6002546103b89073ffffffffffffffffffffffffffffffffffffffff1681565b6102cf6106a1366004612e9f565b611d0a565b61033e6106b4366004612e9f565b611d9a565b60005473ffffffffffffffffffffffffffffffffffffffff16331461070a576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60015473ffffffffffffffffffffffffffffffffffffffff161561075a576040517fb209caed00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f111c6aeb2006d748bdae2ddf082866e6ce7eb3d48ef324b5d9547570f5694e4f90600090a250565b60606107d56011611dc5565b905090565b60005473ffffffffffffffffffffffffffffffffffffffff16331461082b576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8216600081815260146020526040808220849055518392917f4c0223e719940189ef3681b9c0f0450c816c7a262c1963087e3a4911f3bccf5191a35050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152601360205260409020606090805480602002602001604051908101604052809291908181526020016000905b8282101561090d578382906000526020600020906002020160405180604001604052908160008201548152602001600182015481525050815260200190600101906108c7565b505050509050919050565b81610924600c82611dd0565b61095a576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610965601183611dd0565b61099b576040517f12a5f55200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8084166000908152601a602090815260408083209386168352929052205460ff1615610a08576040517fde70de2200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600554600654600754600854600954600a54600b546040517faeb856e30000000000000000000000000000000000000000000000000000000081526018600482015273ffffffffffffffffffffffffffffffffffffffff808c166024830152808b1660448301529788166064820152958716608487015293861660a486015291851660c4850152841660e484015283166101048301529190911661012482015260009073__$def3efb638fd3775ee36c7565ed0f7c2d4$__9063aeb856e39061014401602060405180830381865af4158015610ae8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0c9190613251565b73ffffffffffffffffffffffffffffffffffffffff8581166000908152601a6020908152604080832088851684528252808320805460017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff009091168117909155601b835290832080549182018155835291200180547fffffffffffffffffffffffff0000000000000000000000000000000000000000169183169190911790559050610bb9601c82611de3565b506002546040517fc440a65c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301529091169063c440a65c90602401600060405180830381600087803b158015610c2757600080fd5b505af1158015610c3b573d6000803e3d6000fd5b505050508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167fe63e6130091e2155004c4b5ac35e8fb9be704d6637ff3068a8f710ba36c9f41a60405160405180910390a450505050565b6000610cc3601183611e05565b92915050565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260146020526040812054610cc3565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260156020526040812054610cc3565b60005473ffffffffffffffffffffffffffffffffffffffff163314610d70576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8216600081815260166020526040808220849055518392917fad9146057238aa90fc2f022eed688ed9c094d5b01a070c1d9ed7140ae1e90b5a91a35050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610e15576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610e20600c82611ec8565b60405173ffffffffffffffffffffffffffffffffffffffff8216907f2204279f4b3dc089ca3bb773580383cc44d6d1414667f78def48751c811422d090600090a250565b6000610cc3601c83611ed2565b60005473ffffffffffffffffffffffffffffffffffffffff163314610ec2576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff821660008181526017602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000001662ffffff861690811790915590519092917fdb5545d4da29cde71057a77fa9788f26638ed7c232145a360e250d112462286a91a35050565b73ffffffffffffffffffffffffffffffffffffffff811660009081526017602052604081205462ffffff16610cc3565b60005473ffffffffffffffffffffffffffffffffffffffff163314610fc5576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025473ffffffffffffffffffffffffffffffffffffffff1615611015576040517fb661034d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517fd459c7242e23d490831b5676a611c4342d899d28f342d89ae80793e56a930f3090600090a250565b60005473ffffffffffffffffffffffffffffffffffffffff1633146110d5576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6110e26011848484611f01565b80828473ffffffffffffffffffffffffffffffffffffffff167ff88fac6bf5acd4c3248b702ace956ada3aed01acc26526e8d25e264af2bd28e860405160405180910390a4505050565b600061113c601186868686611fb6565b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff8083166000908152601a6020908152604080832093851683529290529081205460ff1661118957506000610cc3565b73ffffffffffffffffffffffffffffffffffffffff82166000908152601b602090815260408083208054825181850281018501909352808352919290919083018282801561120d57602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff1681526001909101906020018083116111e2575b5050505050905060005b8151811015611305578473ffffffffffffffffffffffffffffffffffffffff168282815181106112495761124961326e565b602002602001015173ffffffffffffffffffffffffffffffffffffffff16630aa7d2f96040518163ffffffff1660e01b8152600401602060405180830381865afa15801561129b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bf9190613251565b73ffffffffffffffffffffffffffffffffffffffff16036112fd578181815181106112ec576112ec61326e565b602002602001015192505050610cc3565b600101611217565b506000949350505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611361576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600480547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f1f54d231bb9d500b1923e4a1cb25e600f366a8368873d9af7c1c623814df19fc90600090a250565b60606107d5600c611dc5565b604080516060810182526000808252602082018190529181019190915281611405600c82611dd0565b61143b576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505073ffffffffffffffffffffffffffffffffffffffff166000908152600e6020908152604080832054600f835281842054601084529382902054825160608101845263ffffffff9283168152919094169281019290925260ff9092169181019190915290565b60005473ffffffffffffffffffffffffffffffffffffffff1633146114f3576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816114ff600c82611dd0565b611535576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60018260ff16111561154657600080fd5b73ffffffffffffffffffffffffffffffffffffffff831660008181526010602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660ff871690811790915590519092917f8a1c882c046939115ffa25c4b35cc2c2f2950b67b62295c136ecc4a6ab67f9ac91a3505050565b6000610cc3600c83611dd0565b60005473ffffffffffffffffffffffffffffffffffffffff163314611625576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611635601187878787878761207d565b6003546040517ff900a8b400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8881166004830152600160248301529091169063f900a8b490604401600060405180830381600087803b1580156116a957600080fd5b505af11580156116bd573d6000803e3d6000fd5b50506002546040517f687d5dd400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152909116925063687d5dd49150602401600060405180830381600087803b15801561172e57600080fd5b505af1158015611742573d6000803e3d6000fd5b5050505083858773ffffffffffffffffffffffffffffffffffffffff167f24b44a8fe42510e0d47e78dc5be1fcf5ab09678e39e793881b17b75536c1c11b8686866040516117a893929190928352602083019190915262ffffff16604082015260600190565b60405180910390a4505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611809576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8316908117825560405190917f9a2ad28991c4a863dd3516183dfda4db8e8aa1c0e550a73570b1c4616301cbc691a250565b60005473ffffffffffffffffffffffffffffffffffffffff1633146118c7576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000806118d56011846121bc565b915091508115611928576020810151815160405173ffffffffffffffffffffffffffffffffffffffff8616907f87cc7629e5df6261b917b2a00b3640c9e8a60161f4018a2285189d10f08540e190600090a45b505050565b6000610cc3601183611dd0565b60005473ffffffffffffffffffffffffffffffffffffffff16331461198b576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8051602082015160408301516119a592600c928692612293565b60408051825163ffffffff9081168252602080850151909116908201528282015160ff1681830152905173ffffffffffffffffffffffffffffffffffffffff8416917ff99b41a10d1100eaee0ac166534e61bcabeb6bb3a1b683368130fc6b7a5ae4e4919081900360600190a25050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611a67576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8216600081815260156020526040808220849055518392917fed3e1e456a52cdc00b8ea60fb4aae37d7e76d31b3e8e7a5581af66fb75e538a391a35050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611b0c576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60035473ffffffffffffffffffffffffffffffffffffffff1615611b5c576040517f85295cee00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f66a0284e74772dd27a28a7555f29db18bb60baa297a3d8bd5ca654309d6efb3890600090a250565b60606107d5601c6123cb565b60005473ffffffffffffffffffffffffffffffffffffffff163314611c28576040517f808ca14f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82611c34600c82611dd0565b611c6a576040517f3c9b573900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff84166000818152600e6020908152604080832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000090811663ffffffff8a8116918217909355600f909452828520805490911691881691821790559051909391927fb68a23d4ed61e96aba80d9f6099f4b9b69af02096eea143d56fb385ea97ad3d791a450505050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152601b6020908152604091829020805483518184028101840190945280845260609392830182828015611d8e57602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff168152600190910190602001808311611d63575b50505050509050919050565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260166020526040812054610cc3565b6060610cc3826123cb565b6000611ddc8383611ed2565b9392505050565b6000611ddc8373ffffffffffffffffffffffffffffffffffffffff84166123d8565b60008282611e138282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090611e8a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b60405180910390fd5b5073ffffffffffffffffffffffffffffffffffffffff841660009081526002860160205260408120611ebc9042612427565b50519695505050505050565b6119288282612575565b73ffffffffffffffffffffffffffffffffffffffff811660009081526001830160205260408120541515611ddc565b8383611f0d8282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090611f7b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5073ffffffffffffffffffffffffffffffffffffffff851660009081526002870160205260409020611fae908585612597565b505050505050565b60008585611fc48282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090612032576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b506120718686866120698c8c73ffffffffffffffffffffffffffffffffffffffff1660009081526002919091016020526040902090565b9291906127ec565b98975050505050505050565b6120878787611de3565b6040518060400160405280600381526020017f4152540000000000000000000000000000000000000000000000000000000000815250906120f5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5073ffffffffffffffffffffffffffffffffffffffff959095166000818152600288810160209081526040808420815180830183529889528883018581528154600180820184559287528487209a5195029099019384559751929097019190915591815260038801825284812095909555600487018152838520929092556005860182528284205560069094019093529190912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000001662ffffff909216919091179055565b60006121db604051806040016040528060008152602001600081525090565b83836121e78282611ed2565b6040518060400160405280600381526020017f555254000000000000000000000000000000000000000000000000000000000081525090612255576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5073ffffffffffffffffffffffffffffffffffffffff85166000908152600287016020526040902061228690612973565b9097909650945050505050565b61229d8585611ed2565b156040518060400160405280600381526020017f41524f00000000000000000000000000000000000000000000000000000000008152509061230c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b506123178585611de3565b5073ffffffffffffffffffffffffffffffffffffffff90931660009081526002850160209081526040808320805463ffffffff9687167fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000918216179091556003880183528184208054959096169416939093179093556004909401909152909120805460ff9092167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00909216919091179055565b60606000611ddc83612b51565b600081815260018301602052604081205461241f57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610cc3565b506000610cc3565b6040805180820190915260008082526020820152825460408051808201909152600481527f49524e490000000000000000000000000000000000000000000000000000000060208201526000918591906124ae576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5084545b801561252e576001810392508583815481106124d0576124d061326e565b600091825260209182902060408051808201909152600290920201805482526001015491810182905294508510612507575061256d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016124b2565b50846000815481106125425761254261326e565b6000918252602080832060408051808201909152600290930201805483526001015490820152935091505b509250929050565b6000611ddc8373ffffffffffffffffffffffffffffffffffffffff8416612bac565b825460408051808201909152600481527f49524e490000000000000000000000000000000000000000000000000000000060208201528491612606576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5060408051808201909152600481527f49524f46000000000000000000000000000000000000000000000000000000006020820152612710841115612678576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5060408051808201909152600481527f495250540000000000000000000000000000000000000000000000000000000060208201524283116126e7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b50835460009085906126fb90600190613338565b8154811061270b5761270b61326e565b9060005260206000209060020201604051806040016040529081600082015481526020016001820154815250509050806020015183116040518060400160405280600481526020017f49524e4100000000000000000000000000000000000000000000000000000000815250906127af576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5050604080518082019091529283525060208083019182528354600181810186556000958652919094209251600290940290920192835551910155565b835460408051808201909152600481527f49524e4900000000000000000000000000000000000000000000000000000000602082015260009186919061285f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b50828410612870576000915061296a565b85546000907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905b8015612964576000896128ac600184613338565b815481106128bc576128bc61326e565b90600052602060002090600202016040518060400160405290816000820154815260200160018201548152505090508783116128f85750612964565b61292889826000015161290f8b8560200151612c9f565b6129198b88612cb5565b6129239190613338565b612cc4565b612932908561334b565b60209091015190935091507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01612898565b50909250505b50949350505050565b6000612992604051806040016040528060008152602001600081525090565b825460408051808201909152600481527f49524e490000000000000000000000000000000000000000000000000000000060208201528491612a01576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b508354600110612a2d576000604051806040016040528060008152602001600081525092509250612b4b565b83546000908590612a4090600190613338565b81548110612a5057612a5061326e565b9060005260206000209060020201604051806040016040529081600082015481526020016001820154815250509050806020015142106040518060400160405280600481526020017f495241410000000000000000000000000000000000000000000000000000000081525090612af4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e81919061329d565b5084805480612b0557612b0561335e565b60008281526020812060027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909301928302018181556001908101919091559155935091505b50915091565b606081600001805480602002602001604051908101604052809291908181526020018280548015611d8e57602002820191906000526020600020905b815481526020019060010190808311612b8d5750505050509050919050565b60008181526001830160205260408120548015612c95576000612bd0600183613338565b8554909150600090612be490600190613338565b9050818114612c49576000866000018281548110612c0457612c0461326e565b9060005260206000200154905080876000018481548110612c2757612c2761326e565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080612c5a57612c5a61335e565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610cc3565b6000915050610cc3565b6000818311612cae5781611ddc565b5090919050565b6000818310612cae5781611ddc565b6000612ced612cd3838561338d565b612ce36301e1338061271061338d565b8691906001612cf5565b949350505050565b600080612d03868686612d50565b90506001836002811115612d1957612d196133a4565b148015612d36575060008480612d3157612d316133d3565b868809115b1561113c57612d4660018261334b565b9695505050505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85870985870292508281108382030391505080600003612da857838281612d9e57612d9e6133d3565b0492505050611ddc565b808411612e11576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4d6174683a206d756c446976206f766572666c6f7700000000000000000000006044820152606401611e81565b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114612e9c57600080fd5b50565b600060208284031215612eb157600080fd5b8135611ddc81612e7a565b6020808252825182820181905260009190848201906040850190845b81811015612f0a57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101612ed8565b50909695505050505050565b60008060408385031215612f2957600080fd5b8235612f3481612e7a565b946020939093013593505050565b602080825282518282018190526000919060409081850190868401855b82811015612f8457815180518552860151868501529284019290850190600101612f5f565b5091979650505050505050565b60008060408385031215612fa457600080fd5b8235612faf81612e7a565b91506020830135612fbf81612e7a565b809150509250929050565b803562ffffff81168114612fdd57600080fd5b919050565b60008060408385031215612ff557600080fd5b823561300081612e7a565b915061300e60208401612fca565b90509250929050565b60008060006060848603121561302c57600080fd5b833561303781612e7a565b95602085013595506040909401359392505050565b6000806000806080858703121561306257600080fd5b843561306d81612e7a565b966020860135965060408601359560600135945092505050565b803560ff81168114612fdd57600080fd5b600080604083850312156130ab57600080fd5b82356130b681612e7a565b915061300e60208401613087565b60008060008060008060c087890312156130dd57600080fd5b86356130e881612e7a565b95506020870135945060408701359350606087013592506080870135915061311260a08801612fca565b90509295509295509295565b803563ffffffff81168114612fdd57600080fd5b600080828403608081121561314657600080fd5b833561315181612e7a565b925060607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08201121561318357600080fd5b506040516060810181811067ffffffffffffffff821117156131ce577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040526131dd6020850161311e565b81526131eb6040850161311e565b60208201526131fc60608501613087565b6040820152809150509250929050565b60008060006060848603121561322157600080fd5b833561322c81612e7a565b925061323a6020850161311e565b91506132486040850161311e565b90509250925092565b60006020828403121561326357600080fd5b8151611ddc81612e7a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060208083528351808285015260005b818110156132ca578581018301518582016040015282016132ae565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610cc357610cc3613309565b80820180821115610cc357610cc3613309565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b8082028115828204841417610cc357610cc3613309565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fdfea2646970667358221220dc6e7b2d70a59f3e788ec7b018e0ab0855590a0fe789ceb5043dc9ea475a024b64736f6c63430008130033",
  "libraries": {
    "MarketDeployerLib": "0xAC66D4d89639dF6A0C4333d0e2B16872FB24eeD9"
  },
  "devdoc": {
    "details": "Contract for managing the creation and registration of Chromatic markets.",
    "errors": {
      "AlreadySetKeeperFeePayer()": [
        {
          "details": "Throws an error indicating that the keeper fee payer address is already set."
        }
      ],
      "AlreadySetLiquidator()": [
        {
          "details": "Throws an error indicating that the chromatic liquidator address is already set."
        }
      ],
      "AlreadySetVault()": [
        {
          "details": "Throws an error indicating that the chromatic vault address is already set."
        }
      ],
      "ExistMarket()": [
        {
          "details": "Throws an error indicating that a market already exists for the given oracle provider and settlement token."
        }
      ],
      "NotRegisteredOracleProvider()": [
        {
          "details": "Throws an error indicating that the oracle provider is not registered."
        }
      ],
      "NotRegisteredSettlementToken()": [
        {
          "details": "Throws an error indicating that the settlement token is not registered."
        }
      ],
      "OnlyAccessableByDao()": [
        {
          "details": "Throws an error indicating that the caller is not the DAO."
        }
      ]
    },
    "events": {
      "InterestRateRecordAppended(address,uint256,uint256)": {
        "details": "Emitted when an interest rate record is appended for a settlement token.",
        "params": {
          "annualRateBPS": "The annual interest rate in basis points (BPS).",
          "beginTimestamp": "The timestamp when the interest rate record begins.",
          "token": "The address of the settlement token."
        }
      },
      "LastInterestRateRecordRemoved(address,uint256,uint256)": {
        "details": "Emitted when the last interest rate record is removed for a settlement token.",
        "params": {
          "annualRateBPS": "The annual interest rate in basis points (BPS).",
          "beginTimestamp": "The timestamp when the interest rate record begins.",
          "token": "The address of the settlement token."
        }
      },
      "MarketCreated(address,address,address)": {
        "params": {
          "market": "The address of the created market.",
          "oracleProvider": "The address of the oracle provider.",
          "settlementToken": "The address of the settlement token."
        }
      },
      "OracleProviderRegistered(address,(uint32,uint32,uint8))": {
        "details": "Emitted when a new oracle provider is registered.",
        "params": {
          "oracleProvider": "The address of the registered oracle provider.",
          "properties": "The properties of the registered oracle provider."
        }
      },
      "OracleProviderUnregistered(address)": {
        "details": "Emitted when an oracle provider is unregistered.",
        "params": {
          "oracleProvider": "The address of the unregistered oracle provider."
        }
      },
      "SetEarningDistributionThreshold(address,uint256)": {
        "details": "Emitted when the earning distribution threshold for a settlement token is set.",
        "params": {
          "earningDistributionThreshold": "The new earning distribution threshold for the settlement token.",
          "token": "The address of the settlement token."
        }
      },
      "SetFlashLoanFeeRate(address,uint256)": {
        "details": "Emitted when the flash loan fee rate for a settlement token is set.",
        "params": {
          "flashLoanFeeRate": "The new flash loan fee rate for the settlement token.",
          "token": "The address of the settlement token."
        }
      },
      "SetKeeperFeePayer(address)": {
        "params": {
          "keeperFeePayer": "The keeper fee payer address."
        }
      },
      "SetLiquidator(address)": {
        "params": {
          "liquidator": "The liquidator address."
        }
      },
      "SetMinimumMargin(address,uint256)": {
        "details": "Emitted when the minimum margin for a settlement token is set.",
        "params": {
          "minimumMargin": "The new minimum margin for the settlement token.",
          "token": "The address of the settlement token."
        }
      },
      "SetUniswapFeeTier(address,uint24)": {
        "details": "Emitted when the Uniswap fee tier for a settlement token is set.",
        "params": {
          "token": "The address of the settlement token.",
          "uniswapFeeTier": "The new Uniswap fee tier for the settlement token."
        }
      },
      "SetVault(address)": {
        "params": {
          "vault": "The vault address."
        }
      },
      "SettlementTokenRegistered(address,uint256,uint256,uint256,uint256,uint24)": {
        "details": "Emitted when a new settlement token is registered.",
        "params": {
          "earningDistributionThreshold": "The earning distribution threshold for the settlement token.",
          "flashLoanFeeRate": "The flash loan fee rate for the settlement token.",
          "interestRate": "The interest rate for the settlement token.",
          "minimumMargin": "The minimum margin for the markets using this settlement token.",
          "token": "The address of the registered settlement token.",
          "uniswapFeeTier": "The Uniswap fee tier for the settlement token."
        }
      },
      "UpdateDao(address)": {
        "params": {
          "dao": "The new DAO address."
        }
      },
      "UpdateLeverageLevel(address,uint8)": {
        "details": "Emitted when the level of an oracle provider is set.",
        "params": {
          "level": "The new level set for the oracle provider.",
          "oracleProvider": "The address of the oracle provider."
        }
      },
      "UpdateTakeProfitBPSRange(address,uint32,uint32)": {
        "details": "Emitted when the take-profit basis points range of an oracle provider is updated.",
        "params": {
          "maxTakeProfitBPS": "The new maximum take-profit basis points.",
          "minTakeProfitBPS": "The new minimum take-profit basis points.",
          "oracleProvider": "The address of the oracle provider."
        }
      },
      "UpdateTreasury(address)": {
        "params": {
          "treasury": "The new DAO treasury address."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "appendInterestRateRecord(address,uint256,uint256)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "annualRateBPS": "The annual interest rate in basis points (BPS).",
          "beginTimestamp": "The timestamp when the interest rate record begins.",
          "token": "The address of the settlement token."
        }
      },
      "calculateInterest(address,uint256,uint256,uint256)": {
        "params": {
          "amount": "The amount of the token.",
          "from": "The starting timestamp (inclusive) of the time range.",
          "to": "The ending timestamp (exclusive) of the time range.",
          "token": "The address of the token."
        },
        "returns": {
          "_0": "The accrued interest for the specified token and amount within the given time range."
        }
      },
      "constructor": {
        "details": "Initializes the ChromaticMarketFactory contract.",
        "params": {
          "_marketDiamondCutFacet": "The market diamond cut facet address.",
          "_marketLiquidateFacet": "The market liquidate facet address.",
          "_marketLiquidityFacet": "The market liquidity facet address.",
          "_marketLoupeFacet": "The market loupe facet address.",
          "_marketSettleFacet": "The market settle facet address.",
          "_marketStateFacet": "The market state facet address.",
          "_marketTradeFacet": "The market trade facet address."
        }
      },
      "createMarket(address,address)": {
        "details": "This function creates a new market using the specified oracle provider and settlement token addresses.      Throws a `NotRegisteredSettlementToken` error if the settlement token is not registered.      Throws an `ExistMarket` error if the market already exists for the given oracle provider and settlement token.",
        "params": {
          "oracleProvider": "The address of the oracle provider.",
          "settlementToken": "The address of the settlement token."
        }
      },
      "currentInterestRate(address)": {
        "params": {
          "token": "The address of the settlement token."
        },
        "returns": {
          "annualRateBPS": "The current interest rate for the settlement token."
        }
      },
      "getEarningDistributionThreshold(address)": {
        "params": {
          "token": "The address of the settlement token."
        },
        "returns": {
          "_0": "The earning distribution threshold for the settlement token."
        }
      },
      "getFlashLoanFeeRate(address)": {
        "params": {
          "token": "The address of the settlement token."
        },
        "returns": {
          "_0": "The flash loan fee rate for the settlement token."
        }
      },
      "getInterestRateRecords(address)": {
        "params": {
          "token": "The address of the settlement token."
        },
        "returns": {
          "_0": "An array of interest rate records for the settlement token."
        }
      },
      "getMarket(address,address)": {
        "params": {
          "oracleProvider": "The address of the oracle provider.",
          "settlementToken": "The address of the settlement token."
        },
        "returns": {
          "_0": "The address of the market."
        }
      },
      "getMarkets()": {
        "returns": {
          "_0": "An array of all market addresses."
        }
      },
      "getMarketsBySettlmentToken(address)": {
        "params": {
          "settlementToken": "The address of the settlement token."
        },
        "returns": {
          "_0": "An array of market addresses."
        }
      },
      "getMinimumMargin(address)": {
        "details": "The minimumMargin is used as the minimum value for the taker margin of a position      or as the minimum value for the maker margin of each bin.",
        "params": {
          "token": "The address of the settlement token."
        },
        "returns": {
          "_0": "The minimum margin for the settlement token."
        }
      },
      "getOracleProviderProperties(address)": {
        "params": {
          "oracleProvider": "The address of the oracle provider."
        },
        "returns": {
          "_0": "The properties of the oracle provider."
        }
      },
      "getUniswapFeeTier(address)": {
        "params": {
          "token": "The address of the settlement token."
        },
        "returns": {
          "_0": "The Uniswap fee tier for the settlement token."
        }
      },
      "isRegisteredMarket(address)": {
        "params": {
          "market": "The address of the market."
        },
        "returns": {
          "_0": "True if the market is registered, false otherwise."
        }
      },
      "isRegisteredOracleProvider(address)": {
        "params": {
          "oracleProvider": "The address of the oracle provider to check."
        },
        "returns": {
          "_0": "A boolean indicating if the oracle provider is registered."
        }
      },
      "isRegisteredSettlementToken(address)": {
        "params": {
          "token": "The address of the settlement token to check."
        },
        "returns": {
          "_0": "True if the settlement token is registered, false otherwise."
        }
      },
      "parameters()": {
        "details": "Called by the market constructor to fetch the parameters of the market Returns underlyingAsset The underlying asset of the market Returns settlementToken The settlement token of the market Returns vPoolCapacity Capacity of virtual future pool Returns vPoolA Amplification coefficient of virtual future pool, precise value"
      },
      "registerOracleProvider(address,(uint32,uint32,uint8))": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "oracleProvider": "The address of the oracle provider to register.",
          "properties": "The properties of the oracle provider."
        }
      },
      "registerSettlementToken(address,uint256,uint256,uint256,uint256,uint24)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "earningDistributionThreshold": "The earning distribution threshold for the settlement token.",
          "flashLoanFeeRate": "The flash loan fee rate for the settlement token.",
          "interestRate": "The interest rate for the settlement token.",
          "minimumMargin": "The minimum margin for the settlement token.",
          "token": "The address of the settlement token to register.",
          "uniswapFeeTier": "The Uniswap fee tier for the settlement token."
        }
      },
      "registeredOracleProviders()": {
        "returns": {
          "_0": "An array of registered oracle provider addresses."
        }
      },
      "registeredSettlementTokens()": {
        "returns": {
          "_0": "An array of addresses representing the registered settlement tokens."
        }
      },
      "removeLastInterestRateRecord(address)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "token": "The address of the settlement token."
        }
      },
      "setEarningDistributionThreshold(address,uint256)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "earningDistributionThreshold": "The new earning distribution threshold for the settlement token.",
          "token": "The address of the settlement token."
        }
      },
      "setFlashLoanFeeRate(address,uint256)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "flashLoanFeeRate": "The new flash loan fee rate for the settlement token.",
          "token": "The address of the settlement token."
        }
      },
      "setKeeperFeePayer(address)": {
        "details": "This function can only be called by the DAO address.      Throws an `AlreadySetKeeperFeePayer` error if the keeper fee payer address has already been set.",
        "params": {
          "keeperFeePayer": "The keeper fee payer address."
        }
      },
      "setLiquidator(address)": {
        "details": "This function can only be called by the DAO address.      Throws an `AlreadySetLiquidator` error if the liquidator address has already been set.",
        "params": {
          "liquidator": "The liquidator address."
        }
      },
      "setMinimumMargin(address,uint256)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "minimumMargin": "The new minimum margin for the settlement token.",
          "token": "The address of the settlement token."
        }
      },
      "setUniswapFeeTier(address,uint24)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "token": "The address of the settlement token.",
          "uniswapFeeTier": "The new Uniswap fee tier for the settlement token."
        }
      },
      "setVault(address)": {
        "details": "This function can only be called by the DAO address.      Throws an `AlreadySetVault` error if the vault address has already been set.",
        "params": {
          "vault": "The vault address."
        }
      },
      "unregisterOracleProvider(address)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "oracleProvider": "The address of the oracle provider to unregister."
        }
      },
      "updateDao(address)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "dao": "The new DAO address."
        }
      },
      "updateLeverageLevel(address,uint8)": {
        "details": "This function can only be called by the DAO and registered oracle providers.",
        "params": {
          "level": "The new leverage level to be set for the oracle provider.",
          "oracleProvider": "The address of the oracle provider."
        }
      },
      "updateTakeProfitBPSRange(address,uint32,uint32)": {
        "details": "This function can only be called by the DAO and registered oracle providers.",
        "params": {
          "maxTakeProfitBPS": "The new maximum take-profit basis points.",
          "minTakeProfitBPS": "The new minimum take-profit basis points.",
          "oracleProvider": "The address of the oracle provider."
        }
      },
      "updateTreasury(address)": {
        "details": "This function can only be called by the DAO address.",
        "params": {
          "treasury": "The new DAO treasury address."
        }
      }
    },
    "stateVariables": {
      "dao": {
        "return": "The address of the DAO.",
        "returns": {
          "_0": "The address of the DAO."
        }
      },
      "keeperFeePayer": {
        "return": "The address of the keeper fee payer.",
        "returns": {
          "_0": "The address of the keeper fee payer."
        }
      },
      "liquidator": {
        "return": "The address of the liquidator.",
        "returns": {
          "_0": "The address of the liquidator."
        }
      },
      "treasury": {
        "return": "The address of the DAO treasury.",
        "returns": {
          "_0": "The address of the DAO treasury."
        }
      },
      "vault": {
        "return": "The address of the vault.",
        "returns": {
          "_0": "The address of the vault."
        }
      }
    },
    "title": "ChromaticMarketFactory",
    "version": 1
  },
  "userdoc": {
    "events": {
      "MarketCreated(address,address,address)": {
        "notice": "Emitted when a market is created."
      },
      "SetKeeperFeePayer(address)": {
        "notice": "Emitted when the keeper fee payer address is set."
      },
      "SetLiquidator(address)": {
        "notice": "Emitted when the liquidator address is set."
      },
      "SetVault(address)": {
        "notice": "Emitted when the vault address is set."
      },
      "UpdateDao(address)": {
        "notice": "Emitted when the DAO address is updated."
      },
      "UpdateTreasury(address)": {
        "notice": "Emitted when the DAO treasury address is updated."
      }
    },
    "kind": "user",
    "methods": {
      "appendInterestRateRecord(address,uint256,uint256)": {
        "notice": "Appends an interest rate record for a settlement token."
      },
      "calculateInterest(address,uint256,uint256,uint256)": {
        "notice": "Calculates the interest accrued for a given token and amount within a specified time range."
      },
      "createMarket(address,address)": {
        "notice": "Creates a new market associated with an oracle provider and settlement token."
      },
      "currentInterestRate(address)": {
        "notice": "Gets the current interest rate for a settlement token."
      },
      "dao()": {
        "notice": "Returns the address of the DAO."
      },
      "getEarningDistributionThreshold(address)": {
        "notice": "Gets the earning distribution threshold for a settlement token."
      },
      "getFlashLoanFeeRate(address)": {
        "notice": "Gets the flash loan fee rate for a settlement token."
      },
      "getInterestRateRecords(address)": {
        "notice": "Gets all the interest rate records for a settlement token."
      },
      "getMarket(address,address)": {
        "notice": "Returns the address of a market associated with an oracle provider and settlement token."
      },
      "getMarkets()": {
        "notice": "Returns an array of all market addresses."
      },
      "getMarketsBySettlmentToken(address)": {
        "notice": "Returns an array of market addresses associated with a settlement token."
      },
      "getMinimumMargin(address)": {
        "notice": "Gets the minimum margin for a settlement token."
      },
      "getOracleProviderProperties(address)": {
        "notice": "Retrieves the properties of an oracle provider."
      },
      "getUniswapFeeTier(address)": {
        "notice": "Gets the Uniswap fee tier for a settlement token."
      },
      "isRegisteredMarket(address)": {
        "notice": "Checks if a market is registered."
      },
      "isRegisteredOracleProvider(address)": {
        "notice": "Checks if an oracle provider is registered."
      },
      "isRegisteredSettlementToken(address)": {
        "notice": "Checks if a settlement token is registered."
      },
      "keeperFeePayer()": {
        "notice": "Returns the address of the keeper fee payer."
      },
      "liquidator()": {
        "notice": "Returns the address of the liquidator."
      },
      "parameters()": {
        "notice": "Get the parameters to be used in constructing the market, set transiently during market creation."
      },
      "registerOracleProvider(address,(uint32,uint32,uint8))": {
        "notice": "Registers an oracle provider."
      },
      "registerSettlementToken(address,uint256,uint256,uint256,uint256,uint24)": {
        "notice": "Registers a new settlement token."
      },
      "registeredOracleProviders()": {
        "notice": "Gets the registered oracle providers."
      },
      "registeredSettlementTokens()": {
        "notice": "Gets the list of registered settlement tokens."
      },
      "removeLastInterestRateRecord(address)": {
        "notice": "Removes the last interest rate record for a settlement token."
      },
      "setEarningDistributionThreshold(address,uint256)": {
        "notice": "Sets the earning distribution threshold for a settlement token."
      },
      "setFlashLoanFeeRate(address,uint256)": {
        "notice": "Sets the flash loan fee rate for a settlement token."
      },
      "setKeeperFeePayer(address)": {
        "notice": "Sets the keeper fee payer address."
      },
      "setLiquidator(address)": {
        "notice": "Sets the liquidator address."
      },
      "setMinimumMargin(address,uint256)": {
        "notice": "Sets the minimum margin for a settlement token."
      },
      "setUniswapFeeTier(address,uint24)": {
        "notice": "Sets the Uniswap fee tier for a settlement token."
      },
      "setVault(address)": {
        "notice": "Sets the vault address."
      },
      "treasury()": {
        "notice": "Returns the address of the DAO treasury."
      },
      "unregisterOracleProvider(address)": {
        "notice": "Unregisters an oracle provider."
      },
      "updateDao(address)": {
        "notice": "Updates the DAO address."
      },
      "updateLeverageLevel(address,uint8)": {
        "notice": "Updates the leverage level of an oracle provider in the registry."
      },
      "updateTakeProfitBPSRange(address,uint32,uint32)": {
        "notice": "Updates the take-profit basis points range of an oracle provider."
      },
      "updateTreasury(address)": {
        "notice": "Updates the DAO treasury address."
      },
      "vault()": {
        "notice": "Returns the address of the vault."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11054,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "dao",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 11057,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "liquidator",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 11060,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "vault",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 11063,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "keeperFeePayer",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 11066,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "treasury",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 11068,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketDiamondCutFacet",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 11070,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketLoupeFacet",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 11072,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketStateFacet",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 11074,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketLiquidityFacet",
        "offset": 0,
        "slot": "8",
        "type": "t_address"
      },
      {
        "astId": 11076,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketTradeFacet",
        "offset": 0,
        "slot": "9",
        "type": "t_address"
      },
      {
        "astId": 11078,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketLiquidateFacet",
        "offset": 0,
        "slot": "10",
        "type": "t_address"
      },
      {
        "astId": 11080,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "marketSettleFacet",
        "offset": 0,
        "slot": "11",
        "type": "t_address"
      },
      {
        "astId": 11083,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "_oracleProviderRegistry",
        "offset": 0,
        "slot": "12",
        "type": "t_struct(OracleProviderRegistry)26583_storage"
      },
      {
        "astId": 11086,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "_settlementTokenRegistry",
        "offset": 0,
        "slot": "17",
        "type": "t_struct(SettlementTokenRegistry)26827_storage"
      },
      {
        "astId": 11089,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "_deployer",
        "offset": 0,
        "slot": "24",
        "type": "t_struct(MarketDeployer)20537_storage"
      },
      {
        "astId": 11095,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "_registered",
        "offset": 0,
        "slot": "26",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 11100,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "_marketsBySettlementToken",
        "offset": 0,
        "slot": "27",
        "type": "t_mapping(t_address,t_array(t_address)dyn_storage)"
      },
      {
        "astId": 11103,
        "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
        "label": "_markets",
        "offset": 0,
        "slot": "28",
        "type": "t_struct(AddressSet)9315_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Record)18767_storage)dyn_storage": {
        "base": "t_struct(Record)18767_storage",
        "encoding": "dynamic_array",
        "label": "struct InterestRate.Record[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_array(t_address)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address[])",
        "numberOfBytes": "32",
        "value": "t_array(t_address)dyn_storage"
      },
      "t_mapping(t_address,t_array(t_struct(Record)18767_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct InterestRate.Record[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(Record)18767_storage)dyn_storage"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_uint24)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint24)",
        "numberOfBytes": "32",
        "value": "t_uint24"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_address,t_uint32)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint32)",
        "numberOfBytes": "32",
        "value": "t_uint32"
      },
      "t_mapping(t_address,t_uint8)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint8)",
        "numberOfBytes": "32",
        "value": "t_uint8"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(AddressSet)9315_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.AddressSet",
        "members": [
          {
            "astId": 9314,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_inner",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Set)9000_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(MarketDeployer)20537_storage": {
        "encoding": "inplace",
        "label": "struct MarketDeployer",
        "members": [
          {
            "astId": 20536,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "parameters",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Parameters)20542_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(OracleProviderRegistry)26583_storage": {
        "encoding": "inplace",
        "label": "struct OracleProviderRegistry",
        "members": [
          {
            "astId": 26570,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_oracleProviders",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(AddressSet)9315_storage"
          },
          {
            "astId": 26574,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_minTakeProfitBPSs",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_address,t_uint32)"
          },
          {
            "astId": 26578,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_maxTakeProfitBPSs",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_address,t_uint32)"
          },
          {
            "astId": 26582,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_leverageLevels",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_address,t_uint8)"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(Parameters)20542_storage": {
        "encoding": "inplace",
        "label": "struct Parameters",
        "members": [
          {
            "astId": 20539,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "oracleProvider",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 20541,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "settlementToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Record)18767_storage": {
        "encoding": "inplace",
        "label": "struct InterestRate.Record",
        "members": [
          {
            "astId": 18763,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "annualRateBPS",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 18766,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "beginTimestamp",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Set)9000_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.Set",
        "members": [
          {
            "astId": 8995,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_values",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_bytes32)dyn_storage"
          },
          {
            "astId": 8999,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_indexes",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_bytes32,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(SettlementTokenRegistry)26827_storage": {
        "encoding": "inplace",
        "label": "struct SettlementTokenRegistry",
        "members": [
          {
            "astId": 26799,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_tokens",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(AddressSet)9315_storage"
          },
          {
            "astId": 26806,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_interestRateRecords",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_address,t_array(t_struct(Record)18767_storage)dyn_storage)"
          },
          {
            "astId": 26811,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_minimumMargins",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 26816,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_flashLoanFeeRates",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 26821,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_earningDistributionThresholds",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 26826,
            "contract": "contracts/core/ChromaticMarketFactory.sol:ChromaticMarketFactory",
            "label": "_uniswapFeeTiers",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_address,t_uint24)"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}